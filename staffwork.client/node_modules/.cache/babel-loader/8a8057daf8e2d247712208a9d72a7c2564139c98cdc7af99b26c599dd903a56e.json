{"ast":null,"code":"function WebGLUniformsGroups(gl, info, capabilities, state) {\n  let buffers = {};\n  let updateList = {};\n  let allocatedBindingPoints = [];\n  const maxBindingPoints = capabilities.isWebGL2 ? gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS) : 0; // binding points are global whereas block indices are per shader program\n\n  function bind(uniformsGroup, program) {\n    const webglProgram = program.program;\n    state.uniformBlockBinding(uniformsGroup, webglProgram);\n  }\n  function update(uniformsGroup, program) {\n    let buffer = buffers[uniformsGroup.id];\n    if (buffer === undefined) {\n      prepareUniformsGroup(uniformsGroup);\n      buffer = createBuffer(uniformsGroup);\n      buffers[uniformsGroup.id] = buffer;\n      uniformsGroup.addEventListener('dispose', onUniformsGroupsDispose);\n    }\n\n    // ensure to update the binding points/block indices mapping for this program\n\n    const webglProgram = program.program;\n    state.updateUBOMapping(uniformsGroup, webglProgram);\n\n    // update UBO once per frame\n\n    const frame = info.render.frame;\n    if (updateList[uniformsGroup.id] !== frame) {\n      updateBufferData(uniformsGroup);\n      updateList[uniformsGroup.id] = frame;\n    }\n  }\n  function createBuffer(uniformsGroup) {\n    // the setup of an UBO is independent of a particular shader program but global\n\n    const bindingPointIndex = allocateBindingPointIndex();\n    uniformsGroup.__bindingPointIndex = bindingPointIndex;\n    const buffer = gl.createBuffer();\n    const size = uniformsGroup.__size;\n    const usage = uniformsGroup.usage;\n    gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);\n    gl.bufferData(gl.UNIFORM_BUFFER, size, usage);\n    gl.bindBuffer(gl.UNIFORM_BUFFER, null);\n    gl.bindBufferBase(gl.UNIFORM_BUFFER, bindingPointIndex, buffer);\n    return buffer;\n  }\n  function allocateBindingPointIndex() {\n    for (let i = 0; i < maxBindingPoints; i++) {\n      if (allocatedBindingPoints.indexOf(i) === -1) {\n        allocatedBindingPoints.push(i);\n        return i;\n      }\n    }\n    console.error('THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.');\n    return 0;\n  }\n  function updateBufferData(uniformsGroup) {\n    const buffer = buffers[uniformsGroup.id];\n    const uniforms = uniformsGroup.uniforms;\n    const cache = uniformsGroup.__cache;\n    gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);\n    for (let i = 0, il = uniforms.length; i < il; i++) {\n      const uniform = uniforms[i];\n\n      // partly update the buffer if necessary\n\n      if (hasUniformChanged(uniform, i, cache) === true) {\n        const value = uniform.value;\n        const offset = uniform.__offset;\n        if (typeof value === 'number') {\n          uniform.__data[0] = value;\n          gl.bufferSubData(gl.UNIFORM_BUFFER, offset, uniform.__data);\n        } else {\n          if (uniform.value.isMatrix3) {\n            // manually converting 3x3 to 3x4\n\n            uniform.__data[0] = uniform.value.elements[0];\n            uniform.__data[1] = uniform.value.elements[1];\n            uniform.__data[2] = uniform.value.elements[2];\n            uniform.__data[3] = uniform.value.elements[0];\n            uniform.__data[4] = uniform.value.elements[3];\n            uniform.__data[5] = uniform.value.elements[4];\n            uniform.__data[6] = uniform.value.elements[5];\n            uniform.__data[7] = uniform.value.elements[0];\n            uniform.__data[8] = uniform.value.elements[6];\n            uniform.__data[9] = uniform.value.elements[7];\n            uniform.__data[10] = uniform.value.elements[8];\n            uniform.__data[11] = uniform.value.elements[0];\n          } else {\n            value.toArray(uniform.__data);\n          }\n          gl.bufferSubData(gl.UNIFORM_BUFFER, offset, uniform.__data);\n        }\n      }\n    }\n    gl.bindBuffer(gl.UNIFORM_BUFFER, null);\n  }\n  function hasUniformChanged(uniform, index, cache) {\n    const value = uniform.value;\n    if (cache[index] === undefined) {\n      // cache entry does not exist so far\n\n      if (typeof value === 'number') {\n        cache[index] = value;\n      } else {\n        cache[index] = value.clone();\n      }\n      return true;\n    } else {\n      // compare current value with cached entry\n\n      if (typeof value === 'number') {\n        if (cache[index] !== value) {\n          cache[index] = value;\n          return true;\n        }\n      } else {\n        const cachedObject = cache[index];\n        if (cachedObject.equals(value) === false) {\n          cachedObject.copy(value);\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  function prepareUniformsGroup(uniformsGroup) {\n    // determine total buffer size according to the STD140 layout\n    // Hint: STD140 is the only supported layout in WebGL 2\n\n    const uniforms = uniformsGroup.uniforms;\n    let offset = 0; // global buffer offset in bytes\n    const chunkSize = 16; // size of a chunk in bytes\n    let chunkOffset = 0; // offset within a single chunk in bytes\n\n    for (let i = 0, l = uniforms.length; i < l; i++) {\n      const uniform = uniforms[i];\n      const info = getUniformSize(uniform);\n\n      // the following two properties will be used for partial buffer updates\n\n      uniform.__data = new Float32Array(info.storage / Float32Array.BYTES_PER_ELEMENT);\n      uniform.__offset = offset;\n\n      //\n\n      if (i > 0) {\n        chunkOffset = offset % chunkSize;\n        const remainingSizeInChunk = chunkSize - chunkOffset;\n\n        // check for chunk overflow\n\n        if (chunkOffset !== 0 && remainingSizeInChunk - info.boundary < 0) {\n          // add padding and adjust offset\n\n          offset += chunkSize - chunkOffset;\n          uniform.__offset = offset;\n        }\n      }\n      offset += info.storage;\n    }\n\n    // ensure correct final padding\n\n    chunkOffset = offset % chunkSize;\n    if (chunkOffset > 0) offset += chunkSize - chunkOffset;\n\n    //\n\n    uniformsGroup.__size = offset;\n    uniformsGroup.__cache = {};\n    return this;\n  }\n  function getUniformSize(uniform) {\n    const value = uniform.value;\n    const info = {\n      boundary: 0,\n      // bytes\n      storage: 0 // bytes\n    };\n\n    // determine sizes according to STD140\n\n    if (typeof value === 'number') {\n      // float/int\n\n      info.boundary = 4;\n      info.storage = 4;\n    } else if (value.isVector2) {\n      // vec2\n\n      info.boundary = 8;\n      info.storage = 8;\n    } else if (value.isVector3 || value.isColor) {\n      // vec3\n\n      info.boundary = 16;\n      info.storage = 12; // evil: vec3 must start on a 16-byte boundary but it only consumes 12 bytes\n    } else if (value.isVector4) {\n      // vec4\n\n      info.boundary = 16;\n      info.storage = 16;\n    } else if (value.isMatrix3) {\n      // mat3 (in STD140 a 3x3 matrix is represented as 3x4)\n\n      info.boundary = 48;\n      info.storage = 48;\n    } else if (value.isMatrix4) {\n      // mat4\n\n      info.boundary = 64;\n      info.storage = 64;\n    } else if (value.isTexture) {\n      console.warn('THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.');\n    } else {\n      console.warn('THREE.WebGLRenderer: Unsupported uniform value type.', value);\n    }\n    return info;\n  }\n  function onUniformsGroupsDispose(event) {\n    const uniformsGroup = event.target;\n    uniformsGroup.removeEventListener('dispose', onUniformsGroupsDispose);\n    const index = allocatedBindingPoints.indexOf(uniformsGroup.__bindingPointIndex);\n    allocatedBindingPoints.splice(index, 1);\n    gl.deleteBuffer(buffers[uniformsGroup.id]);\n    delete buffers[uniformsGroup.id];\n    delete updateList[uniformsGroup.id];\n  }\n  function dispose() {\n    for (const id in buffers) {\n      gl.deleteBuffer(buffers[id]);\n    }\n    allocatedBindingPoints = [];\n    buffers = {};\n    updateList = {};\n  }\n  return {\n    bind: bind,\n    update: update,\n    dispose: dispose\n  };\n}\nexport { WebGLUniformsGroups };","map":{"version":3,"names":["WebGLUniformsGroups","gl","info","capabilities","state","buffers","updateList","allocatedBindingPoints","maxBindingPoints","isWebGL2","getParameter","MAX_UNIFORM_BUFFER_BINDINGS","bind","uniformsGroup","program","webglProgram","uniformBlockBinding","update","buffer","id","undefined","prepareUniformsGroup","createBuffer","addEventListener","onUniformsGroupsDispose","updateUBOMapping","frame","render","updateBufferData","bindingPointIndex","allocateBindingPointIndex","__bindingPointIndex","size","__size","usage","bindBuffer","UNIFORM_BUFFER","bufferData","bindBufferBase","i","indexOf","push","console","error","uniforms","cache","__cache","il","length","uniform","hasUniformChanged","value","offset","__offset","__data","bufferSubData","isMatrix3","elements","toArray","index","clone","cachedObject","equals","copy","chunkSize","chunkOffset","l","getUniformSize","Float32Array","storage","BYTES_PER_ELEMENT","remainingSizeInChunk","boundary","isVector2","isVector3","isColor","isVector4","isMatrix4","isTexture","warn","event","target","removeEventListener","splice","deleteBuffer","dispose"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/renderers/webgl/WebGLUniformsGroups.js"],"sourcesContent":["function WebGLUniformsGroups( gl, info, capabilities, state ) {\n\n\tlet buffers = {};\n\tlet updateList = {};\n\tlet allocatedBindingPoints = [];\n\n\tconst maxBindingPoints = ( capabilities.isWebGL2 ) ? gl.getParameter( gl.MAX_UNIFORM_BUFFER_BINDINGS ) : 0; // binding points are global whereas block indices are per shader program\n\n\tfunction bind( uniformsGroup, program ) {\n\n\t\tconst webglProgram = program.program;\n\t\tstate.uniformBlockBinding( uniformsGroup, webglProgram );\n\n\t}\n\n\tfunction update( uniformsGroup, program ) {\n\n\t\tlet buffer = buffers[ uniformsGroup.id ];\n\n\t\tif ( buffer === undefined ) {\n\n\t\t\tprepareUniformsGroup( uniformsGroup );\n\n\t\t\tbuffer = createBuffer( uniformsGroup );\n\t\t\tbuffers[ uniformsGroup.id ] = buffer;\n\n\t\t\tuniformsGroup.addEventListener( 'dispose', onUniformsGroupsDispose );\n\n\t\t}\n\n\t\t// ensure to update the binding points/block indices mapping for this program\n\n\t\tconst webglProgram = program.program;\n\t\tstate.updateUBOMapping( uniformsGroup, webglProgram );\n\n\t\t// update UBO once per frame\n\n\t\tconst frame = info.render.frame;\n\n\t\tif ( updateList[ uniformsGroup.id ] !== frame ) {\n\n\t\t\tupdateBufferData( uniformsGroup );\n\n\t\t\tupdateList[ uniformsGroup.id ] = frame;\n\n\t\t}\n\n\t}\n\n\tfunction createBuffer( uniformsGroup ) {\n\n\t\t// the setup of an UBO is independent of a particular shader program but global\n\n\t\tconst bindingPointIndex = allocateBindingPointIndex();\n\t\tuniformsGroup.__bindingPointIndex = bindingPointIndex;\n\n\t\tconst buffer = gl.createBuffer();\n\t\tconst size = uniformsGroup.__size;\n\t\tconst usage = uniformsGroup.usage;\n\n\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, buffer );\n\t\tgl.bufferData( gl.UNIFORM_BUFFER, size, usage );\n\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, null );\n\t\tgl.bindBufferBase( gl.UNIFORM_BUFFER, bindingPointIndex, buffer );\n\n\t\treturn buffer;\n\n\t}\n\n\tfunction allocateBindingPointIndex() {\n\n\t\tfor ( let i = 0; i < maxBindingPoints; i ++ ) {\n\n\t\t\tif ( allocatedBindingPoints.indexOf( i ) === - 1 ) {\n\n\t\t\t\tallocatedBindingPoints.push( i );\n\t\t\t\treturn i;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconsole.error( 'THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.' );\n\n\t\treturn 0;\n\n\t}\n\n\tfunction updateBufferData( uniformsGroup ) {\n\n\t\tconst buffer = buffers[ uniformsGroup.id ];\n\t\tconst uniforms = uniformsGroup.uniforms;\n\t\tconst cache = uniformsGroup.__cache;\n\n\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, buffer );\n\n\t\tfor ( let i = 0, il = uniforms.length; i < il; i ++ ) {\n\n\t\t\tconst uniform = uniforms[ i ];\n\n\t\t\t// partly update the buffer if necessary\n\n\t\t\tif ( hasUniformChanged( uniform, i, cache ) === true ) {\n\n\t\t\t\tconst value = uniform.value;\n\t\t\t\tconst offset = uniform.__offset;\n\n\t\t\t\tif ( typeof value === 'number' ) {\n\n\t\t\t\t\tuniform.__data[ 0 ] = value;\n\t\t\t\t\tgl.bufferSubData( gl.UNIFORM_BUFFER, offset, uniform.__data );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( uniform.value.isMatrix3 ) {\n\n\t\t\t\t\t\t// manually converting 3x3 to 3x4\n\n\t\t\t\t\t\tuniform.__data[ 0 ] = uniform.value.elements[ 0 ];\n\t\t\t\t\t\tuniform.__data[ 1 ] = uniform.value.elements[ 1 ];\n\t\t\t\t\t\tuniform.__data[ 2 ] = uniform.value.elements[ 2 ];\n\t\t\t\t\t\tuniform.__data[ 3 ] = uniform.value.elements[ 0 ];\n\t\t\t\t\t\tuniform.__data[ 4 ] = uniform.value.elements[ 3 ];\n\t\t\t\t\t\tuniform.__data[ 5 ] = uniform.value.elements[ 4 ];\n\t\t\t\t\t\tuniform.__data[ 6 ] = uniform.value.elements[ 5 ];\n\t\t\t\t\t\tuniform.__data[ 7 ] = uniform.value.elements[ 0 ];\n\t\t\t\t\t\tuniform.__data[ 8 ] = uniform.value.elements[ 6 ];\n\t\t\t\t\t\tuniform.__data[ 9 ] = uniform.value.elements[ 7 ];\n\t\t\t\t\t\tuniform.__data[ 10 ] = uniform.value.elements[ 8 ];\n\t\t\t\t\t\tuniform.__data[ 11 ] = uniform.value.elements[ 0 ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvalue.toArray( uniform.__data );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgl.bufferSubData( gl.UNIFORM_BUFFER, offset, uniform.__data );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, null );\n\n\t}\n\n\tfunction hasUniformChanged( uniform, index, cache ) {\n\n\t\tconst value = uniform.value;\n\n\t\tif ( cache[ index ] === undefined ) {\n\n\t\t\t// cache entry does not exist so far\n\n\t\t\tif ( typeof value === 'number' ) {\n\n\t\t\t\tcache[ index ] = value;\n\n\t\t\t} else {\n\n\t\t\t\tcache[ index ] = value.clone();\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\t// compare current value with cached entry\n\n\t\t\tif ( typeof value === 'number' ) {\n\n\t\t\t\tif ( cache[ index ] !== value ) {\n\n\t\t\t\t\tcache[ index ] = value;\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst cachedObject = cache[ index ];\n\n\t\t\t\tif ( cachedObject.equals( value ) === false ) {\n\n\t\t\t\t\tcachedObject.copy( value );\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tfunction prepareUniformsGroup( uniformsGroup ) {\n\n\t\t// determine total buffer size according to the STD140 layout\n\t\t// Hint: STD140 is the only supported layout in WebGL 2\n\n\t\tconst uniforms = uniformsGroup.uniforms;\n\n\t\tlet offset = 0; // global buffer offset in bytes\n\t\tconst chunkSize = 16; // size of a chunk in bytes\n\t\tlet chunkOffset = 0; // offset within a single chunk in bytes\n\n\t\tfor ( let i = 0, l = uniforms.length; i < l; i ++ ) {\n\n\t\t\tconst uniform = uniforms[ i ];\n\t\t\tconst info = getUniformSize( uniform );\n\n\t\t\t// the following two properties will be used for partial buffer updates\n\n\t\t\tuniform.__data = new Float32Array( info.storage / Float32Array.BYTES_PER_ELEMENT );\n\t\t\tuniform.__offset = offset;\n\n\t\t\t//\n\n\t\t\tif ( i > 0 ) {\n\n\t\t\t\tchunkOffset = offset % chunkSize;\n\n\t\t\t\tconst remainingSizeInChunk = chunkSize - chunkOffset;\n\n\t\t\t\t// check for chunk overflow\n\n\t\t\t\tif ( chunkOffset !== 0 && ( remainingSizeInChunk - info.boundary ) < 0 ) {\n\n\t\t\t\t\t// add padding and adjust offset\n\n\t\t\t\t\toffset += ( chunkSize - chunkOffset );\n\t\t\t\t\tuniform.__offset = offset;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\toffset += info.storage;\n\n\t\t}\n\n\t\t// ensure correct final padding\n\n\t\tchunkOffset = offset % chunkSize;\n\n\t\tif ( chunkOffset > 0 ) offset += ( chunkSize - chunkOffset );\n\n\t\t//\n\n\t\tuniformsGroup.__size = offset;\n\t\tuniformsGroup.__cache = {};\n\n\t\treturn this;\n\n\t}\n\n\tfunction getUniformSize( uniform ) {\n\n\t\tconst value = uniform.value;\n\n\t\tconst info = {\n\t\t\tboundary: 0, // bytes\n\t\t\tstorage: 0 // bytes\n\t\t};\n\n\t\t// determine sizes according to STD140\n\n\t\tif ( typeof value === 'number' ) {\n\n\t\t\t// float/int\n\n\t\t\tinfo.boundary = 4;\n\t\t\tinfo.storage = 4;\n\n\t\t} else if ( value.isVector2 ) {\n\n\t\t\t// vec2\n\n\t\t\tinfo.boundary = 8;\n\t\t\tinfo.storage = 8;\n\n\t\t} else if ( value.isVector3 || value.isColor ) {\n\n\t\t\t// vec3\n\n\t\t\tinfo.boundary = 16;\n\t\t\tinfo.storage = 12; // evil: vec3 must start on a 16-byte boundary but it only consumes 12 bytes\n\n\t\t} else if ( value.isVector4 ) {\n\n\t\t\t// vec4\n\n\t\t\tinfo.boundary = 16;\n\t\t\tinfo.storage = 16;\n\n\t\t} else if ( value.isMatrix3 ) {\n\n\t\t\t// mat3 (in STD140 a 3x3 matrix is represented as 3x4)\n\n\t\t\tinfo.boundary = 48;\n\t\t\tinfo.storage = 48;\n\n\t\t} else if ( value.isMatrix4 ) {\n\n\t\t\t// mat4\n\n\t\t\tinfo.boundary = 64;\n\t\t\tinfo.storage = 64;\n\n\t\t} else if ( value.isTexture ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.' );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Unsupported uniform value type.', value );\n\n\t\t}\n\n\t\treturn info;\n\n\t}\n\n\tfunction onUniformsGroupsDispose( event ) {\n\n\t\tconst uniformsGroup = event.target;\n\n\t\tuniformsGroup.removeEventListener( 'dispose', onUniformsGroupsDispose );\n\n\t\tconst index = allocatedBindingPoints.indexOf( uniformsGroup.__bindingPointIndex );\n\t\tallocatedBindingPoints.splice( index, 1 );\n\n\t\tgl.deleteBuffer( buffers[ uniformsGroup.id ] );\n\n\t\tdelete buffers[ uniformsGroup.id ];\n\t\tdelete updateList[ uniformsGroup.id ];\n\n\t}\n\n\tfunction dispose() {\n\n\t\tfor ( const id in buffers ) {\n\n\t\t\tgl.deleteBuffer( buffers[ id ] );\n\n\t\t}\n\n\t\tallocatedBindingPoints = [];\n\t\tbuffers = {};\n\t\tupdateList = {};\n\n\t}\n\n\treturn {\n\n\t\tbind: bind,\n\t\tupdate: update,\n\n\t\tdispose: dispose\n\n\t};\n\n}\n\n\nexport { WebGLUniformsGroups };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}