{"ast":null,"code":"import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\nclass TorusKnotGeometry extends BufferGeometry {\n  constructor() {\n    let radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    let tube = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.4;\n    let tubularSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 64;\n    let radialSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 8;\n    let p = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 2;\n    let q = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 3;\n    super();\n    this.type = 'TorusKnotGeometry';\n    this.parameters = {\n      radius: radius,\n      tube: tube,\n      tubularSegments: tubularSegments,\n      radialSegments: radialSegments,\n      p: p,\n      q: q\n    };\n    tubularSegments = Math.floor(tubularSegments);\n    radialSegments = Math.floor(radialSegments);\n\n    // buffers\n\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n\n    // helper variables\n\n    const vertex = new Vector3();\n    const normal = new Vector3();\n    const P1 = new Vector3();\n    const P2 = new Vector3();\n    const B = new Vector3();\n    const T = new Vector3();\n    const N = new Vector3();\n\n    // generate vertices, normals and uvs\n\n    for (let i = 0; i <= tubularSegments; ++i) {\n      // the radian \"u\" is used to calculate the position on the torus curve of the current tubular segment\n\n      const u = i / tubularSegments * p * Math.PI * 2;\n\n      // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n      // these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\n      calculatePositionOnCurve(u, p, q, radius, P1);\n      calculatePositionOnCurve(u + 0.01, p, q, radius, P2);\n\n      // calculate orthonormal basis\n\n      T.subVectors(P2, P1);\n      N.addVectors(P2, P1);\n      B.crossVectors(T, N);\n      N.crossVectors(B, T);\n\n      // normalize B, N. T can be ignored, we don't use it\n\n      B.normalize();\n      N.normalize();\n      for (let j = 0; j <= radialSegments; ++j) {\n        // now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n        // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\n        const v = j / radialSegments * Math.PI * 2;\n        const cx = -tube * Math.cos(v);\n        const cy = tube * Math.sin(v);\n\n        // now calculate the final vertex position.\n        // first we orient the extrusion with our basis vectors, then we add it to the current position on the curve\n\n        vertex.x = P1.x + (cx * N.x + cy * B.x);\n        vertex.y = P1.y + (cx * N.y + cy * B.y);\n        vertex.z = P1.z + (cx * N.z + cy * B.z);\n        vertices.push(vertex.x, vertex.y, vertex.z);\n\n        // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\n        normal.subVectors(vertex, P1).normalize();\n        normals.push(normal.x, normal.y, normal.z);\n\n        // uv\n\n        uvs.push(i / tubularSegments);\n        uvs.push(j / radialSegments);\n      }\n    }\n\n    // generate indices\n\n    for (let j = 1; j <= tubularSegments; j++) {\n      for (let i = 1; i <= radialSegments; i++) {\n        // indices\n\n        const a = (radialSegments + 1) * (j - 1) + (i - 1);\n        const b = (radialSegments + 1) * j + (i - 1);\n        const c = (radialSegments + 1) * j + i;\n        const d = (radialSegments + 1) * (j - 1) + i;\n\n        // faces\n\n        indices.push(a, b, d);\n        indices.push(b, c, d);\n      }\n    }\n\n    // build geometry\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\n    // this function calculates the current position on the torus curve\n\n    function calculatePositionOnCurve(u, p, q, radius, position) {\n      const cu = Math.cos(u);\n      const su = Math.sin(u);\n      const quOverP = q / p * u;\n      const cs = Math.cos(quOverP);\n      position.x = radius * (2 + cs) * 0.5 * cu;\n      position.y = radius * (2 + cs) * su * 0.5;\n      position.z = radius * Math.sin(quOverP) * 0.5;\n    }\n  }\n  static fromJSON(data) {\n    return new TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);\n  }\n}\nexport { TorusKnotGeometry };","map":{"version":3,"names":["BufferGeometry","Float32BufferAttribute","Vector3","TorusKnotGeometry","constructor","radius","tube","tubularSegments","radialSegments","p","q","type","parameters","Math","floor","indices","vertices","normals","uvs","vertex","normal","P1","P2","B","T","N","i","u","PI","calculatePositionOnCurve","subVectors","addVectors","crossVectors","normalize","j","v","cx","cos","cy","sin","x","y","z","push","a","b","c","d","setIndex","setAttribute","position","cu","su","quOverP","cs","fromJSON","data"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/geometries/TorusKnotGeometry.js"],"sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nclass TorusKnotGeometry extends BufferGeometry {\n\n\tconstructor( radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'TorusKnotGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradialSegments: radialSegments,\n\t\t\tp: p,\n\t\t\tq: q\n\t\t};\n\n\t\ttubularSegments = Math.floor( tubularSegments );\n\t\tradialSegments = Math.floor( radialSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\tconst P1 = new Vector3();\n\t\tconst P2 = new Vector3();\n\n\t\tconst B = new Vector3();\n\t\tconst T = new Vector3();\n\t\tconst N = new Vector3();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let i = 0; i <= tubularSegments; ++ i ) {\n\n\t\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segment\n\n\t\t\tconst u = i / tubularSegments * p * Math.PI * 2;\n\n\t\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n\t\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\n\t\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\n\t\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\n\n\t\t\t// calculate orthonormal basis\n\n\t\t\tT.subVectors( P2, P1 );\n\t\t\tN.addVectors( P2, P1 );\n\t\t\tB.crossVectors( T, N );\n\t\t\tN.crossVectors( B, T );\n\n\t\t\t// normalize B, N. T can be ignored, we don't use it\n\n\t\t\tB.normalize();\n\t\t\tN.normalize();\n\n\t\t\tfor ( let j = 0; j <= radialSegments; ++ j ) {\n\n\t\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n\t\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\n\t\t\t\tconst v = j / radialSegments * Math.PI * 2;\n\t\t\t\tconst cx = - tube * Math.cos( v );\n\t\t\t\tconst cy = tube * Math.sin( v );\n\n\t\t\t\t// now calculate the final vertex position.\n\t\t\t\t// first we orient the extrusion with our basis vectors, then we add it to the current position on the curve\n\n\t\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\n\t\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\n\t\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\n\t\t\t\tnormal.subVectors( vertex, P1 ).normalize();\n\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( i / tubularSegments );\n\t\t\t\tuvs.push( j / radialSegments );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( let j = 1; j <= tubularSegments; j ++ ) {\n\n\t\t\tfor ( let i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t\t// indices\n\n\t\t\t\tconst a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\tconst b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\tconst c = ( radialSegments + 1 ) * j + i;\n\t\t\t\tconst d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\t// this function calculates the current position on the torus curve\n\n\t\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\n\n\t\t\tconst cu = Math.cos( u );\n\t\t\tconst su = Math.sin( u );\n\t\t\tconst quOverP = q / p * u;\n\t\t\tconst cs = Math.cos( quOverP );\n\n\t\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\n\t\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\n\t\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\n\n\t\t}\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new TorusKnotGeometry( data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q );\n\n\t}\n\n}\n\nexport { TorusKnotGeometry };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}