{"ast":null,"code":"import Node from '../core/Node.js';\nimport ArrayElementNode from '../utils/ArrayElementNode.js';\nimport ConvertNode from '../utils/ConvertNode.js';\nimport JoinNode from '../utils/JoinNode.js';\nimport SplitNode from '../utils/SplitNode.js';\nimport ConstNode from '../core/ConstNode.js';\nimport { getValueFromType } from '../core/NodeUtils.js';\nconst shaderNodeHandler = {\n  construct(NodeClosure, params) {\n    const inputs = params.shift();\n    return NodeClosure(nodeObjects(inputs), ...params);\n  },\n  get: function (node, prop) {\n    if (typeof prop === 'string' && node[prop] === undefined) {\n      if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true) {\n        // accessing properties ( swizzle )\n\n        prop = prop.replace(/r|s/g, 'x').replace(/g|t/g, 'y').replace(/b|p/g, 'z').replace(/a|q/g, 'w');\n        return nodeObject(new SplitNode(node, prop));\n      } else if (/^\\d+$/.test(prop) === true) {\n        // accessing array\n\n        return nodeObject(new ArrayElementNode(node, new ConstNode(Number(prop), 'uint')));\n      }\n    }\n    return node[prop];\n  }\n};\nconst nodeObjectsCacheMap = new WeakMap();\nconst ShaderNodeObject = function (obj) {\n  const type = typeof obj;\n  if (type === 'number' || type === 'boolean') {\n    return nodeObject(getAutoTypedConstNode(obj));\n  } else if (type === 'object') {\n    if (obj?.isNode === true) {\n      let nodeObject = nodeObjectsCacheMap.get(obj);\n      if (nodeObject === undefined) {\n        nodeObject = new Proxy(obj, shaderNodeHandler);\n        nodeObjectsCacheMap.set(obj, nodeObject);\n        nodeObjectsCacheMap.set(nodeObject, nodeObject);\n      }\n      return nodeObject;\n    }\n  }\n  return obj;\n};\nconst ShaderNodeObjects = function (objects) {\n  for (const name in objects) {\n    objects[name] = nodeObject(objects[name]);\n  }\n  return objects;\n};\nconst ShaderNodeArray = function (array) {\n  const len = array.length;\n  for (let i = 0; i < len; i++) {\n    array[i] = nodeObject(array[i]);\n  }\n  return array;\n};\nconst ShaderNodeProxy = function (NodeClass) {\n  let scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let factor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  let settings = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  const assignNode = node => nodeObject(settings !== null ? Object.assign(node, settings) : node);\n  if (scope === null) {\n    return function () {\n      for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {\n        params[_key] = arguments[_key];\n      }\n      return assignNode(new NodeClass(...nodeArray(params)));\n    };\n  } else if (factor !== null) {\n    factor = nodeObject(factor);\n    return function () {\n      for (var _len2 = arguments.length, params = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        params[_key2] = arguments[_key2];\n      }\n      return assignNode(new NodeClass(scope, ...nodeArray(params), factor));\n    };\n  } else {\n    return function () {\n      for (var _len3 = arguments.length, params = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        params[_key3] = arguments[_key3];\n      }\n      return assignNode(new NodeClass(scope, ...nodeArray(params)));\n    };\n  }\n};\nconst ShaderNodeImmutable = function (NodeClass) {\n  for (var _len4 = arguments.length, params = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    params[_key4 - 1] = arguments[_key4];\n  }\n  return nodeObject(new NodeClass(...nodeArray(params)));\n};\nclass ShaderNodeInternal extends Node {\n  constructor(jsFunc) {\n    super();\n    this._jsFunc = jsFunc;\n  }\n  call(inputs, builder) {\n    inputs = nodeObjects(inputs);\n    return nodeObject(this._jsFunc(inputs, builder));\n  }\n  generate(builder, output) {\n    const nodeCall = this.call({}, builder);\n    if (nodeCall === undefined) {\n      return '';\n    }\n    return builder.format(nodeCall.build(builder), nodeCall.getNodeType(builder), output);\n  }\n}\nconst ShaderNodeScript = function (jsFunc) {\n  return new ShaderNodeInternal(jsFunc);\n};\nexport const ShaderNode = new Proxy(ShaderNodeScript, shaderNodeHandler);\nexport const nodeObject = val => /* new */ShaderNodeObject(val);\nexport const nodeObjects = val => new ShaderNodeObjects(val);\nexport const nodeArray = val => new ShaderNodeArray(val);\nexport const nodeProxy = function () {\n  for (var _len5 = arguments.length, val = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    val[_key5] = arguments[_key5];\n  }\n  return new ShaderNodeProxy(...val);\n};\nexport const nodeImmutable = function () {\n  for (var _len6 = arguments.length, val = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    val[_key6] = arguments[_key6];\n  }\n  return new ShaderNodeImmutable(...val);\n};\nconst bools = [false, true];\nconst uints = [0, 1, 2, 3];\nconst ints = [-1, -2];\nconst floats = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2];\nconst boolsCacheMap = new Map();\nfor (const bool of bools) boolsCacheMap.set(bool, new ConstNode(bool));\nconst uintsCacheMap = new Map();\nfor (const uint of uints) uintsCacheMap.set(uint, new ConstNode(uint, 'uint'));\nconst intsCacheMap = new Map([...uintsCacheMap].map(el => new ConstNode(el.value, 'int')));\nfor (const int of ints) intsCacheMap.set(int, new ConstNode(int, 'int'));\nconst floatsCacheMap = new Map([...intsCacheMap].map(el => new ConstNode(el.value)));\nfor (const float of floats) floatsCacheMap.set(float, new ConstNode(float));\nfor (const float of floats) floatsCacheMap.set(-float, new ConstNode(-float));\nexport const cacheMaps = {\n  bool: boolsCacheMap,\n  uint: uintsCacheMap,\n  ints: intsCacheMap,\n  float: floatsCacheMap\n};\nconst constNodesCacheMap = new Map([...boolsCacheMap, ...floatsCacheMap]);\nconst getAutoTypedConstNode = value => {\n  if (constNodesCacheMap.has(value)) {\n    return constNodesCacheMap.get(value);\n  } else if (value.isNode === true) {\n    return value;\n  } else {\n    return new ConstNode(value);\n  }\n};\nexport const ConvertType = function (type) {\n  let cacheMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return function () {\n    for (var _len7 = arguments.length, params = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      params[_key7] = arguments[_key7];\n    }\n    if (params.length === 0) {\n      return nodeObject(new ConstNode(getValueFromType(type), type));\n    } else {\n      if (type === 'color' && params[0].isNode !== true) {\n        params = [getValueFromType(type, ...params)];\n      }\n      if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {\n        return cacheMap.get(params[0]);\n      }\n      const nodes = params.map(getAutoTypedConstNode);\n      if (nodes.length === 1) {\n        return nodeObject(nodes[0].nodeType === type ? nodes[0] : new ConvertNode(nodes[0], type));\n      }\n      return nodeObject(new JoinNode(nodes, type));\n    }\n  };\n};\nexport const getConstNodeType = value => value.nodeType || value.convertTo || (typeof value === 'string' ? value : null);","map":{"version":3,"names":["Node","ArrayElementNode","ConvertNode","JoinNode","SplitNode","ConstNode","getValueFromType","shaderNodeHandler","construct","NodeClosure","params","inputs","shift","nodeObjects","get","node","prop","undefined","test","replace","nodeObject","Number","nodeObjectsCacheMap","WeakMap","ShaderNodeObject","obj","type","getAutoTypedConstNode","isNode","Proxy","set","ShaderNodeObjects","objects","name","ShaderNodeArray","array","len","length","i","ShaderNodeProxy","NodeClass","scope","factor","settings","assignNode","Object","assign","nodeArray","ShaderNodeImmutable","ShaderNodeInternal","constructor","jsFunc","_jsFunc","call","builder","generate","output","nodeCall","format","build","getNodeType","ShaderNodeScript","ShaderNode","val","nodeProxy","nodeImmutable","bools","uints","ints","floats","Math","PI","boolsCacheMap","Map","bool","uintsCacheMap","uint","intsCacheMap","map","el","value","int","floatsCacheMap","float","cacheMaps","constNodesCacheMap","has","ConvertType","cacheMap","nodes","nodeType","getConstNodeType","convertTo"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/examples/jsm/nodes/shadernode/ShaderNode.js"],"sourcesContent":["import Node from '../core/Node.js';\nimport ArrayElementNode from '../utils/ArrayElementNode.js';\nimport ConvertNode from '../utils/ConvertNode.js';\nimport JoinNode from '../utils/JoinNode.js';\nimport SplitNode from '../utils/SplitNode.js';\nimport ConstNode from '../core/ConstNode.js';\nimport { getValueFromType } from '../core/NodeUtils.js';\n\nconst shaderNodeHandler = {\n\n\tconstruct( NodeClosure, params ) {\n\n\t\tconst inputs = params.shift();\n\n\t\treturn NodeClosure( nodeObjects( inputs ), ...params );\n\n\t},\n\n\tget: function ( node, prop ) {\n\n\t\tif ( typeof prop === 'string' && node[ prop ] === undefined ) {\n\n\t\t\tif ( /^[xyzwrgbastpq]{1,4}$/.test( prop ) === true ) {\n\n\t\t\t\t// accessing properties ( swizzle )\n\n\t\t\t\tprop = prop\n\t\t\t\t\t.replace( /r|s/g, 'x' )\n\t\t\t\t\t.replace( /g|t/g, 'y' )\n\t\t\t\t\t.replace( /b|p/g, 'z' )\n\t\t\t\t\t.replace( /a|q/g, 'w' );\n\n\t\t\t\treturn nodeObject( new SplitNode( node, prop ) );\n\n\t\t\t} else if ( /^\\d+$/.test( prop ) === true ) {\n\n\t\t\t\t// accessing array\n\n\t\t\t\treturn nodeObject( new ArrayElementNode( node, new ConstNode( Number( prop ), 'uint' ) ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn node[ prop ];\n\n\t}\n\n};\n\nconst nodeObjectsCacheMap = new WeakMap();\n\nconst ShaderNodeObject = function ( obj ) {\n\n\tconst type = typeof obj;\n\n\tif ( ( type === 'number' ) || ( type === 'boolean' ) ) {\n\n\t\treturn nodeObject( getAutoTypedConstNode( obj ) );\n\n\t} else if ( type === 'object' ) {\n\n\t\tif ( obj?.isNode === true ) {\n\n\t\t\tlet nodeObject = nodeObjectsCacheMap.get( obj );\n\n\t\t\tif ( nodeObject === undefined ) {\n\n\t\t\t\tnodeObject = new Proxy( obj, shaderNodeHandler );\n\t\t\t\tnodeObjectsCacheMap.set( obj, nodeObject );\n\t\t\t\tnodeObjectsCacheMap.set( nodeObject, nodeObject );\n\n\t\t\t}\n\n\t\t\treturn nodeObject;\n\n\t\t}\n\n\t}\n\n\treturn obj;\n\n};\n\nconst ShaderNodeObjects = function ( objects ) {\n\n\tfor ( const name in objects ) {\n\n\t\tobjects[ name ] = nodeObject( objects[ name ] );\n\n\t}\n\n\treturn objects;\n\n};\n\nconst ShaderNodeArray = function ( array ) {\n\n\tconst len = array.length;\n\n\tfor ( let i = 0; i < len; i ++ ) {\n\n\t\tarray[ i ] = nodeObject( array[ i ] );\n\n\t}\n\n\treturn array;\n\n};\n\nconst ShaderNodeProxy = function ( NodeClass, scope = null, factor = null, settings = null ) {\n\n\tconst assignNode = ( node ) => nodeObject( settings !== null ? Object.assign( node, settings ) : node );\n\n\tif ( scope === null ) {\n\n\t\treturn ( ...params ) => {\n\n\t\t\treturn assignNode( new NodeClass( ...nodeArray( params ) ) );\n\n\t\t};\n\n\t} else if ( factor !== null ) {\n\n\t\tfactor = nodeObject( factor );\n\n\t\treturn ( ...params ) => {\n\n\t\t\treturn assignNode( new NodeClass( scope, ...nodeArray( params ), factor ) );\n\n\t\t};\n\n\t} else {\n\n\t\treturn ( ...params ) => {\n\n\t\t\treturn assignNode( new NodeClass( scope, ...nodeArray( params ) ) );\n\n\t\t};\n\n\t}\n\n};\n\nconst ShaderNodeImmutable = function ( NodeClass, ...params ) {\n\n\treturn nodeObject( new NodeClass( ...nodeArray( params ) ) );\n\n};\n\nclass ShaderNodeInternal extends Node {\n\n\tconstructor( jsFunc ) {\n\n\t\tsuper();\n\n\t\tthis._jsFunc = jsFunc;\n\n\t}\n\n\tcall( inputs, builder ) {\n\n\t\tinputs = nodeObjects( inputs );\n\n\t\treturn nodeObject( this._jsFunc( inputs, builder ) );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst nodeCall = this.call( {}, builder );\n\n\t\tif ( nodeCall === undefined ) {\n\n\t\t\treturn '';\n\n\t\t}\n\n\t\treturn builder.format( nodeCall.build( builder ), nodeCall.getNodeType( builder ), output );\n\n\t}\n\n}\n\nconst ShaderNodeScript = function ( jsFunc ) {\n\n\treturn new ShaderNodeInternal( jsFunc );\n\n};\n\nexport const ShaderNode = new Proxy( ShaderNodeScript, shaderNodeHandler );\n\nexport const nodeObject = ( val ) => /* new */ ShaderNodeObject( val );\nexport const nodeObjects = ( val ) => new ShaderNodeObjects( val );\nexport const nodeArray = ( val ) => new ShaderNodeArray( val );\nexport const nodeProxy = ( ...val ) => new ShaderNodeProxy( ...val );\nexport const nodeImmutable = ( ...val ) => new ShaderNodeImmutable( ...val );\n\nconst bools = [ false, true ];\nconst uints = [ 0, 1, 2, 3 ];\nconst ints = [ - 1, - 2 ];\nconst floats = [ 0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / ( Math.PI * 2 ), Math.PI / 2 ];\n\nconst boolsCacheMap = new Map();\nfor ( const bool of bools ) boolsCacheMap.set( bool, new ConstNode( bool ) );\n\nconst uintsCacheMap = new Map();\nfor ( const uint of uints ) uintsCacheMap.set( uint, new ConstNode( uint, 'uint' ) );\n\nconst intsCacheMap = new Map( [ ...uintsCacheMap ].map( el => new ConstNode( el.value, 'int' ) ) );\nfor ( const int of ints ) intsCacheMap.set( int, new ConstNode( int, 'int' ) );\n\nconst floatsCacheMap = new Map( [ ...intsCacheMap ].map( el => new ConstNode( el.value ) ) );\nfor ( const float of floats ) floatsCacheMap.set( float, new ConstNode( float ) );\nfor ( const float of floats ) floatsCacheMap.set( - float, new ConstNode( - float ) );\n\nexport const cacheMaps = { bool: boolsCacheMap, uint: uintsCacheMap, ints: intsCacheMap, float: floatsCacheMap };\n\nconst constNodesCacheMap = new Map( [ ...boolsCacheMap, ...floatsCacheMap ] );\n\nconst getAutoTypedConstNode = ( value ) => {\n\n\tif ( constNodesCacheMap.has( value ) ) {\n\n\t\treturn constNodesCacheMap.get( value );\n\n\t} else if ( value.isNode === true ) {\n\n\t\treturn value;\n\n\t} else {\n\n\t\treturn new ConstNode( value );\n\n\t}\n\n};\n\nexport const ConvertType = function ( type, cacheMap = null ) {\n\n\treturn ( ...params ) => {\n\n\t\tif ( params.length === 0 ) {\n\n\t\t\treturn nodeObject( new ConstNode( getValueFromType( type ), type ) );\n\n\t\t} else {\n\n\t\t\tif ( type === 'color' && params[ 0 ].isNode !== true ) {\n\n\t\t\t\tparams = [ getValueFromType( type, ...params ) ];\n\n\t\t\t}\n\n\t\t\tif ( params.length === 1 && cacheMap !== null && cacheMap.has( params[ 0 ] ) ) {\n\n\t\t\t\treturn cacheMap.get( params[ 0 ] );\n\n\t\t\t}\n\n\t\t\tconst nodes = params.map( getAutoTypedConstNode );\n\n\t\t\tif ( nodes.length === 1 ) {\n\n\t\t\t\treturn nodeObject( nodes[ 0 ].nodeType === type ? nodes[ 0 ] : new ConvertNode( nodes[ 0 ], type ) );\n\n\t\t\t}\n\n\t\t\treturn nodeObject( new JoinNode( nodes, type ) );\n\n\t\t}\n\n\t};\n\n};\n\nexport const getConstNodeType = ( value ) => value.nodeType || value.convertTo || ( typeof value === 'string' ? value : null );\n"],"mappings":"AAAA,OAAOA,IAAI,MAAM,iBAAiB;AAClC,OAAOC,gBAAgB,MAAM,8BAA8B;AAC3D,OAAOC,WAAW,MAAM,yBAAyB;AACjD,OAAOC,QAAQ,MAAM,sBAAsB;AAC3C,OAAOC,SAAS,MAAM,uBAAuB;AAC7C,OAAOC,SAAS,MAAM,sBAAsB;AAC5C,SAASC,gBAAgB,QAAQ,sBAAsB;AAEvD,MAAMC,iBAAiB,GAAG;EAEzBC,SAAS,CAAEC,WAAW,EAAEC,MAAM,EAAG;IAEhC,MAAMC,MAAM,GAAGD,MAAM,CAACE,KAAK,EAAE;IAE7B,OAAOH,WAAW,CAAEI,WAAW,CAAEF,MAAM,CAAE,EAAE,GAAGD,MAAM,CAAE;EAEvD,CAAC;EAEDI,GAAG,EAAE,UAAWC,IAAI,EAAEC,IAAI,EAAG;IAE5B,IAAK,OAAOA,IAAI,KAAK,QAAQ,IAAID,IAAI,CAAEC,IAAI,CAAE,KAAKC,SAAS,EAAG;MAE7D,IAAK,uBAAuB,CAACC,IAAI,CAAEF,IAAI,CAAE,KAAK,IAAI,EAAG;QAEpD;;QAEAA,IAAI,GAAGA,IAAI,CACTG,OAAO,CAAE,MAAM,EAAE,GAAG,CAAE,CACtBA,OAAO,CAAE,MAAM,EAAE,GAAG,CAAE,CACtBA,OAAO,CAAE,MAAM,EAAE,GAAG,CAAE,CACtBA,OAAO,CAAE,MAAM,EAAE,GAAG,CAAE;QAExB,OAAOC,UAAU,CAAE,IAAIhB,SAAS,CAAEW,IAAI,EAAEC,IAAI,CAAE,CAAE;MAEjD,CAAC,MAAM,IAAK,OAAO,CAACE,IAAI,CAAEF,IAAI,CAAE,KAAK,IAAI,EAAG;QAE3C;;QAEA,OAAOI,UAAU,CAAE,IAAInB,gBAAgB,CAAEc,IAAI,EAAE,IAAIV,SAAS,CAAEgB,MAAM,CAAEL,IAAI,CAAE,EAAE,MAAM,CAAE,CAAE,CAAE;MAE3F;IAED;IAEA,OAAOD,IAAI,CAAEC,IAAI,CAAE;EAEpB;AAED,CAAC;AAED,MAAMM,mBAAmB,GAAG,IAAIC,OAAO,EAAE;AAEzC,MAAMC,gBAAgB,GAAG,UAAWC,GAAG,EAAG;EAEzC,MAAMC,IAAI,GAAG,OAAOD,GAAG;EAEvB,IAAOC,IAAI,KAAK,QAAQ,IAAQA,IAAI,KAAK,SAAW,EAAG;IAEtD,OAAON,UAAU,CAAEO,qBAAqB,CAAEF,GAAG,CAAE,CAAE;EAElD,CAAC,MAAM,IAAKC,IAAI,KAAK,QAAQ,EAAG;IAE/B,IAAKD,GAAG,EAAEG,MAAM,KAAK,IAAI,EAAG;MAE3B,IAAIR,UAAU,GAAGE,mBAAmB,CAACR,GAAG,CAAEW,GAAG,CAAE;MAE/C,IAAKL,UAAU,KAAKH,SAAS,EAAG;QAE/BG,UAAU,GAAG,IAAIS,KAAK,CAAEJ,GAAG,EAAElB,iBAAiB,CAAE;QAChDe,mBAAmB,CAACQ,GAAG,CAAEL,GAAG,EAAEL,UAAU,CAAE;QAC1CE,mBAAmB,CAACQ,GAAG,CAAEV,UAAU,EAAEA,UAAU,CAAE;MAElD;MAEA,OAAOA,UAAU;IAElB;EAED;EAEA,OAAOK,GAAG;AAEX,CAAC;AAED,MAAMM,iBAAiB,GAAG,UAAWC,OAAO,EAAG;EAE9C,KAAM,MAAMC,IAAI,IAAID,OAAO,EAAG;IAE7BA,OAAO,CAAEC,IAAI,CAAE,GAAGb,UAAU,CAAEY,OAAO,CAAEC,IAAI,CAAE,CAAE;EAEhD;EAEA,OAAOD,OAAO;AAEf,CAAC;AAED,MAAME,eAAe,GAAG,UAAWC,KAAK,EAAG;EAE1C,MAAMC,GAAG,GAAGD,KAAK,CAACE,MAAM;EAExB,KAAM,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,GAAG,EAAEE,CAAC,EAAG,EAAG;IAEhCH,KAAK,CAAEG,CAAC,CAAE,GAAGlB,UAAU,CAAEe,KAAK,CAAEG,CAAC,CAAE,CAAE;EAEtC;EAEA,OAAOH,KAAK;AAEb,CAAC;AAED,MAAMI,eAAe,GAAG,UAAWC,SAAS,EAAiD;EAAA,IAA/CC,KAAK,uEAAG,IAAI;EAAA,IAAEC,MAAM,uEAAG,IAAI;EAAA,IAAEC,QAAQ,uEAAG,IAAI;EAEzF,MAAMC,UAAU,GAAK7B,IAAI,IAAMK,UAAU,CAAEuB,QAAQ,KAAK,IAAI,GAAGE,MAAM,CAACC,MAAM,CAAE/B,IAAI,EAAE4B,QAAQ,CAAE,GAAG5B,IAAI,CAAE;EAEvG,IAAK0B,KAAK,KAAK,IAAI,EAAG;IAErB,OAAO,YAAiB;MAAA,kCAAZ/B,MAAM;QAANA,MAAM;MAAA;MAEjB,OAAOkC,UAAU,CAAE,IAAIJ,SAAS,CAAE,GAAGO,SAAS,CAAErC,MAAM,CAAE,CAAE,CAAE;IAE7D,CAAC;EAEF,CAAC,MAAM,IAAKgC,MAAM,KAAK,IAAI,EAAG;IAE7BA,MAAM,GAAGtB,UAAU,CAAEsB,MAAM,CAAE;IAE7B,OAAO,YAAiB;MAAA,mCAAZhC,MAAM;QAANA,MAAM;MAAA;MAEjB,OAAOkC,UAAU,CAAE,IAAIJ,SAAS,CAAEC,KAAK,EAAE,GAAGM,SAAS,CAAErC,MAAM,CAAE,EAAEgC,MAAM,CAAE,CAAE;IAE5E,CAAC;EAEF,CAAC,MAAM;IAEN,OAAO,YAAiB;MAAA,mCAAZhC,MAAM;QAANA,MAAM;MAAA;MAEjB,OAAOkC,UAAU,CAAE,IAAIJ,SAAS,CAAEC,KAAK,EAAE,GAAGM,SAAS,CAAErC,MAAM,CAAE,CAAE,CAAE;IAEpE,CAAC;EAEF;AAED,CAAC;AAED,MAAMsC,mBAAmB,GAAG,UAAWR,SAAS,EAAc;EAAA,mCAAT9B,MAAM;IAANA,MAAM;EAAA;EAE1D,OAAOU,UAAU,CAAE,IAAIoB,SAAS,CAAE,GAAGO,SAAS,CAAErC,MAAM,CAAE,CAAE,CAAE;AAE7D,CAAC;AAED,MAAMuC,kBAAkB,SAASjD,IAAI,CAAC;EAErCkD,WAAW,CAAEC,MAAM,EAAG;IAErB,KAAK,EAAE;IAEP,IAAI,CAACC,OAAO,GAAGD,MAAM;EAEtB;EAEAE,IAAI,CAAE1C,MAAM,EAAE2C,OAAO,EAAG;IAEvB3C,MAAM,GAAGE,WAAW,CAAEF,MAAM,CAAE;IAE9B,OAAOS,UAAU,CAAE,IAAI,CAACgC,OAAO,CAAEzC,MAAM,EAAE2C,OAAO,CAAE,CAAE;EAErD;EAEAC,QAAQ,CAAED,OAAO,EAAEE,MAAM,EAAG;IAE3B,MAAMC,QAAQ,GAAG,IAAI,CAACJ,IAAI,CAAE,CAAC,CAAC,EAAEC,OAAO,CAAE;IAEzC,IAAKG,QAAQ,KAAKxC,SAAS,EAAG;MAE7B,OAAO,EAAE;IAEV;IAEA,OAAOqC,OAAO,CAACI,MAAM,CAAED,QAAQ,CAACE,KAAK,CAAEL,OAAO,CAAE,EAAEG,QAAQ,CAACG,WAAW,CAAEN,OAAO,CAAE,EAAEE,MAAM,CAAE;EAE5F;AAED;AAEA,MAAMK,gBAAgB,GAAG,UAAWV,MAAM,EAAG;EAE5C,OAAO,IAAIF,kBAAkB,CAAEE,MAAM,CAAE;AAExC,CAAC;AAED,OAAO,MAAMW,UAAU,GAAG,IAAIjC,KAAK,CAAEgC,gBAAgB,EAAEtD,iBAAiB,CAAE;AAE1E,OAAO,MAAMa,UAAU,GAAK2C,GAAG,IAAM,SAAUvC,gBAAgB,CAAEuC,GAAG,CAAE;AACtE,OAAO,MAAMlD,WAAW,GAAKkD,GAAG,IAAM,IAAIhC,iBAAiB,CAAEgC,GAAG,CAAE;AAClE,OAAO,MAAMhB,SAAS,GAAKgB,GAAG,IAAM,IAAI7B,eAAe,CAAE6B,GAAG,CAAE;AAC9D,OAAO,MAAMC,SAAS,GAAG;EAAA,mCAAKD,GAAG;IAAHA,GAAG;EAAA;EAAA,OAAM,IAAIxB,eAAe,CAAE,GAAGwB,GAAG,CAAE;AAAA;AACpE,OAAO,MAAME,aAAa,GAAG;EAAA,mCAAKF,GAAG;IAAHA,GAAG;EAAA;EAAA,OAAM,IAAIf,mBAAmB,CAAE,GAAGe,GAAG,CAAE;AAAA;AAE5E,MAAMG,KAAK,GAAG,CAAE,KAAK,EAAE,IAAI,CAAE;AAC7B,MAAMC,KAAK,GAAG,CAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAE;AAC5B,MAAMC,IAAI,GAAG,CAAE,CAAE,CAAC,EAAE,CAAE,CAAC,CAAE;AACzB,MAAMC,MAAM,GAAG,CAAE,GAAG,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,EAAE,IAAI,EAAE,GAAG,EAAEC,IAAI,CAACC,EAAE,EAAED,IAAI,CAACC,EAAE,GAAG,CAAC,EAAE,CAAC,GAAGD,IAAI,CAACC,EAAE,EAAE,CAAC,GAAGD,IAAI,CAACC,EAAE,EAAE,CAAC,IAAKD,IAAI,CAACC,EAAE,GAAG,CAAC,CAAE,EAAED,IAAI,CAACC,EAAE,GAAG,CAAC,CAAE;AAE/H,MAAMC,aAAa,GAAG,IAAIC,GAAG,EAAE;AAC/B,KAAM,MAAMC,IAAI,IAAIR,KAAK,EAAGM,aAAa,CAAC1C,GAAG,CAAE4C,IAAI,EAAE,IAAIrE,SAAS,CAAEqE,IAAI,CAAE,CAAE;AAE5E,MAAMC,aAAa,GAAG,IAAIF,GAAG,EAAE;AAC/B,KAAM,MAAMG,IAAI,IAAIT,KAAK,EAAGQ,aAAa,CAAC7C,GAAG,CAAE8C,IAAI,EAAE,IAAIvE,SAAS,CAAEuE,IAAI,EAAE,MAAM,CAAE,CAAE;AAEpF,MAAMC,YAAY,GAAG,IAAIJ,GAAG,CAAE,CAAE,GAAGE,aAAa,CAAE,CAACG,GAAG,CAAEC,EAAE,IAAI,IAAI1E,SAAS,CAAE0E,EAAE,CAACC,KAAK,EAAE,KAAK,CAAE,CAAE,CAAE;AAClG,KAAM,MAAMC,GAAG,IAAIb,IAAI,EAAGS,YAAY,CAAC/C,GAAG,CAAEmD,GAAG,EAAE,IAAI5E,SAAS,CAAE4E,GAAG,EAAE,KAAK,CAAE,CAAE;AAE9E,MAAMC,cAAc,GAAG,IAAIT,GAAG,CAAE,CAAE,GAAGI,YAAY,CAAE,CAACC,GAAG,CAAEC,EAAE,IAAI,IAAI1E,SAAS,CAAE0E,EAAE,CAACC,KAAK,CAAE,CAAE,CAAE;AAC5F,KAAM,MAAMG,KAAK,IAAId,MAAM,EAAGa,cAAc,CAACpD,GAAG,CAAEqD,KAAK,EAAE,IAAI9E,SAAS,CAAE8E,KAAK,CAAE,CAAE;AACjF,KAAM,MAAMA,KAAK,IAAId,MAAM,EAAGa,cAAc,CAACpD,GAAG,CAAE,CAAEqD,KAAK,EAAE,IAAI9E,SAAS,CAAE,CAAE8E,KAAK,CAAE,CAAE;AAErF,OAAO,MAAMC,SAAS,GAAG;EAAEV,IAAI,EAAEF,aAAa;EAAEI,IAAI,EAAED,aAAa;EAAEP,IAAI,EAAES,YAAY;EAAEM,KAAK,EAAED;AAAe,CAAC;AAEhH,MAAMG,kBAAkB,GAAG,IAAIZ,GAAG,CAAE,CAAE,GAAGD,aAAa,EAAE,GAAGU,cAAc,CAAE,CAAE;AAE7E,MAAMvD,qBAAqB,GAAKqD,KAAK,IAAM;EAE1C,IAAKK,kBAAkB,CAACC,GAAG,CAAEN,KAAK,CAAE,EAAG;IAEtC,OAAOK,kBAAkB,CAACvE,GAAG,CAAEkE,KAAK,CAAE;EAEvC,CAAC,MAAM,IAAKA,KAAK,CAACpD,MAAM,KAAK,IAAI,EAAG;IAEnC,OAAOoD,KAAK;EAEb,CAAC,MAAM;IAEN,OAAO,IAAI3E,SAAS,CAAE2E,KAAK,CAAE;EAE9B;AAED,CAAC;AAED,OAAO,MAAMO,WAAW,GAAG,UAAW7D,IAAI,EAAoB;EAAA,IAAlB8D,QAAQ,uEAAG,IAAI;EAE1D,OAAO,YAAiB;IAAA,mCAAZ9E,MAAM;MAANA,MAAM;IAAA;IAEjB,IAAKA,MAAM,CAAC2B,MAAM,KAAK,CAAC,EAAG;MAE1B,OAAOjB,UAAU,CAAE,IAAIf,SAAS,CAAEC,gBAAgB,CAAEoB,IAAI,CAAE,EAAEA,IAAI,CAAE,CAAE;IAErE,CAAC,MAAM;MAEN,IAAKA,IAAI,KAAK,OAAO,IAAIhB,MAAM,CAAE,CAAC,CAAE,CAACkB,MAAM,KAAK,IAAI,EAAG;QAEtDlB,MAAM,GAAG,CAAEJ,gBAAgB,CAAEoB,IAAI,EAAE,GAAGhB,MAAM,CAAE,CAAE;MAEjD;MAEA,IAAKA,MAAM,CAAC2B,MAAM,KAAK,CAAC,IAAImD,QAAQ,KAAK,IAAI,IAAIA,QAAQ,CAACF,GAAG,CAAE5E,MAAM,CAAE,CAAC,CAAE,CAAE,EAAG;QAE9E,OAAO8E,QAAQ,CAAC1E,GAAG,CAAEJ,MAAM,CAAE,CAAC,CAAE,CAAE;MAEnC;MAEA,MAAM+E,KAAK,GAAG/E,MAAM,CAACoE,GAAG,CAAEnD,qBAAqB,CAAE;MAEjD,IAAK8D,KAAK,CAACpD,MAAM,KAAK,CAAC,EAAG;QAEzB,OAAOjB,UAAU,CAAEqE,KAAK,CAAE,CAAC,CAAE,CAACC,QAAQ,KAAKhE,IAAI,GAAG+D,KAAK,CAAE,CAAC,CAAE,GAAG,IAAIvF,WAAW,CAAEuF,KAAK,CAAE,CAAC,CAAE,EAAE/D,IAAI,CAAE,CAAE;MAErG;MAEA,OAAON,UAAU,CAAE,IAAIjB,QAAQ,CAAEsF,KAAK,EAAE/D,IAAI,CAAE,CAAE;IAEjD;EAED,CAAC;AAEF,CAAC;AAED,OAAO,MAAMiE,gBAAgB,GAAKX,KAAK,IAAMA,KAAK,CAACU,QAAQ,IAAIV,KAAK,CAACY,SAAS,KAAM,OAAOZ,KAAK,KAAK,QAAQ,GAAGA,KAAK,GAAG,IAAI,CAAE"},"metadata":{},"sourceType":"module","externalDependencies":[]}