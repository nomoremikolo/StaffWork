{"ast":null,"code":"import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport * as MathUtils from '../math/MathUtils.js';\nimport { Triangle } from '../math/Triangle.js';\nimport { Vector3 } from '../math/Vector3.js';\nconst _v0 = /*@__PURE__*/new Vector3();\nconst _v1 = /*@__PURE__*/new Vector3();\nconst _normal = /*@__PURE__*/new Vector3();\nconst _triangle = /*@__PURE__*/new Triangle();\nclass EdgesGeometry extends BufferGeometry {\n  constructor() {\n    let geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let thresholdAngle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    super();\n    this.type = 'EdgesGeometry';\n    this.parameters = {\n      geometry: geometry,\n      thresholdAngle: thresholdAngle\n    };\n    if (geometry !== null) {\n      const precisionPoints = 4;\n      const precision = Math.pow(10, precisionPoints);\n      const thresholdDot = Math.cos(MathUtils.DEG2RAD * thresholdAngle);\n      const indexAttr = geometry.getIndex();\n      const positionAttr = geometry.getAttribute('position');\n      const indexCount = indexAttr ? indexAttr.count : positionAttr.count;\n      const indexArr = [0, 0, 0];\n      const vertKeys = ['a', 'b', 'c'];\n      const hashes = new Array(3);\n      const edgeData = {};\n      const vertices = [];\n      for (let i = 0; i < indexCount; i += 3) {\n        if (indexAttr) {\n          indexArr[0] = indexAttr.getX(i);\n          indexArr[1] = indexAttr.getX(i + 1);\n          indexArr[2] = indexAttr.getX(i + 2);\n        } else {\n          indexArr[0] = i;\n          indexArr[1] = i + 1;\n          indexArr[2] = i + 2;\n        }\n        const {\n          a,\n          b,\n          c\n        } = _triangle;\n        a.fromBufferAttribute(positionAttr, indexArr[0]);\n        b.fromBufferAttribute(positionAttr, indexArr[1]);\n        c.fromBufferAttribute(positionAttr, indexArr[2]);\n        _triangle.getNormal(_normal);\n\n        // create hashes for the edge from the vertices\n        hashes[0] = `${Math.round(a.x * precision)},${Math.round(a.y * precision)},${Math.round(a.z * precision)}`;\n        hashes[1] = `${Math.round(b.x * precision)},${Math.round(b.y * precision)},${Math.round(b.z * precision)}`;\n        hashes[2] = `${Math.round(c.x * precision)},${Math.round(c.y * precision)},${Math.round(c.z * precision)}`;\n\n        // skip degenerate triangles\n        if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {\n          continue;\n        }\n\n        // iterate over every edge\n        for (let j = 0; j < 3; j++) {\n          // get the first and next vertex making up the edge\n          const jNext = (j + 1) % 3;\n          const vecHash0 = hashes[j];\n          const vecHash1 = hashes[jNext];\n          const v0 = _triangle[vertKeys[j]];\n          const v1 = _triangle[vertKeys[jNext]];\n          const hash = `${vecHash0}_${vecHash1}`;\n          const reverseHash = `${vecHash1}_${vecHash0}`;\n          if (reverseHash in edgeData && edgeData[reverseHash]) {\n            // if we found a sibling edge add it into the vertex array if\n            // it meets the angle threshold and delete the edge from the map.\n            if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {\n              vertices.push(v0.x, v0.y, v0.z);\n              vertices.push(v1.x, v1.y, v1.z);\n            }\n            edgeData[reverseHash] = null;\n          } else if (!(hash in edgeData)) {\n            // if we've already got an edge here then skip adding a new one\n            edgeData[hash] = {\n              index0: indexArr[j],\n              index1: indexArr[jNext],\n              normal: _normal.clone()\n            };\n          }\n        }\n      }\n\n      // iterate over all remaining, unmatched edges and add them to the vertex array\n      for (const key in edgeData) {\n        if (edgeData[key]) {\n          const {\n            index0,\n            index1\n          } = edgeData[key];\n          _v0.fromBufferAttribute(positionAttr, index0);\n          _v1.fromBufferAttribute(positionAttr, index1);\n          vertices.push(_v0.x, _v0.y, _v0.z);\n          vertices.push(_v1.x, _v1.y, _v1.z);\n        }\n      }\n      this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    }\n  }\n}\nexport { EdgesGeometry };","map":{"version":3,"names":["BufferGeometry","Float32BufferAttribute","MathUtils","Triangle","Vector3","_v0","_v1","_normal","_triangle","EdgesGeometry","constructor","geometry","thresholdAngle","type","parameters","precisionPoints","precision","Math","pow","thresholdDot","cos","DEG2RAD","indexAttr","getIndex","positionAttr","getAttribute","indexCount","count","indexArr","vertKeys","hashes","Array","edgeData","vertices","i","getX","a","b","c","fromBufferAttribute","getNormal","round","x","y","z","j","jNext","vecHash0","vecHash1","v0","v1","hash","reverseHash","dot","normal","push","index0","index1","clone","key","setAttribute"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/geometries/EdgesGeometry.js"],"sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport * as MathUtils from '../math/MathUtils.js';\nimport { Triangle } from '../math/Triangle.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nconst _v0 = /*@__PURE__*/ new Vector3();\nconst _v1 = /*@__PURE__*/ new Vector3();\nconst _normal = /*@__PURE__*/ new Vector3();\nconst _triangle = /*@__PURE__*/ new Triangle();\n\nclass EdgesGeometry extends BufferGeometry {\n\n\tconstructor( geometry = null, thresholdAngle = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'EdgesGeometry';\n\n\t\tthis.parameters = {\n\t\t\tgeometry: geometry,\n\t\t\tthresholdAngle: thresholdAngle\n\t\t};\n\n\t\tif ( geometry !== null ) {\n\n\t\t\tconst precisionPoints = 4;\n\t\t\tconst precision = Math.pow( 10, precisionPoints );\n\t\t\tconst thresholdDot = Math.cos( MathUtils.DEG2RAD * thresholdAngle );\n\n\t\t\tconst indexAttr = geometry.getIndex();\n\t\t\tconst positionAttr = geometry.getAttribute( 'position' );\n\t\t\tconst indexCount = indexAttr ? indexAttr.count : positionAttr.count;\n\n\t\t\tconst indexArr = [ 0, 0, 0 ];\n\t\t\tconst vertKeys = [ 'a', 'b', 'c' ];\n\t\t\tconst hashes = new Array( 3 );\n\n\t\t\tconst edgeData = {};\n\t\t\tconst vertices = [];\n\t\t\tfor ( let i = 0; i < indexCount; i += 3 ) {\n\n\t\t\t\tif ( indexAttr ) {\n\n\t\t\t\t\tindexArr[ 0 ] = indexAttr.getX( i );\n\t\t\t\t\tindexArr[ 1 ] = indexAttr.getX( i + 1 );\n\t\t\t\t\tindexArr[ 2 ] = indexAttr.getX( i + 2 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindexArr[ 0 ] = i;\n\t\t\t\t\tindexArr[ 1 ] = i + 1;\n\t\t\t\t\tindexArr[ 2 ] = i + 2;\n\n\t\t\t\t}\n\n\t\t\t\tconst { a, b, c } = _triangle;\n\t\t\t\ta.fromBufferAttribute( positionAttr, indexArr[ 0 ] );\n\t\t\t\tb.fromBufferAttribute( positionAttr, indexArr[ 1 ] );\n\t\t\t\tc.fromBufferAttribute( positionAttr, indexArr[ 2 ] );\n\t\t\t\t_triangle.getNormal( _normal );\n\n\t\t\t\t// create hashes for the edge from the vertices\n\t\t\t\thashes[ 0 ] = `${ Math.round( a.x * precision ) },${ Math.round( a.y * precision ) },${ Math.round( a.z * precision ) }`;\n\t\t\t\thashes[ 1 ] = `${ Math.round( b.x * precision ) },${ Math.round( b.y * precision ) },${ Math.round( b.z * precision ) }`;\n\t\t\t\thashes[ 2 ] = `${ Math.round( c.x * precision ) },${ Math.round( c.y * precision ) },${ Math.round( c.z * precision ) }`;\n\n\t\t\t\t// skip degenerate triangles\n\t\t\t\tif ( hashes[ 0 ] === hashes[ 1 ] || hashes[ 1 ] === hashes[ 2 ] || hashes[ 2 ] === hashes[ 0 ] ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// iterate over every edge\n\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t// get the first and next vertex making up the edge\n\t\t\t\t\tconst jNext = ( j + 1 ) % 3;\n\t\t\t\t\tconst vecHash0 = hashes[ j ];\n\t\t\t\t\tconst vecHash1 = hashes[ jNext ];\n\t\t\t\t\tconst v0 = _triangle[ vertKeys[ j ] ];\n\t\t\t\t\tconst v1 = _triangle[ vertKeys[ jNext ] ];\n\n\t\t\t\t\tconst hash = `${ vecHash0 }_${ vecHash1 }`;\n\t\t\t\t\tconst reverseHash = `${ vecHash1 }_${ vecHash0 }`;\n\n\t\t\t\t\tif ( reverseHash in edgeData && edgeData[ reverseHash ] ) {\n\n\t\t\t\t\t\t// if we found a sibling edge add it into the vertex array if\n\t\t\t\t\t\t// it meets the angle threshold and delete the edge from the map.\n\t\t\t\t\t\tif ( _normal.dot( edgeData[ reverseHash ].normal ) <= thresholdDot ) {\n\n\t\t\t\t\t\t\tvertices.push( v0.x, v0.y, v0.z );\n\t\t\t\t\t\t\tvertices.push( v1.x, v1.y, v1.z );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tedgeData[ reverseHash ] = null;\n\n\t\t\t\t\t} else if ( ! ( hash in edgeData ) ) {\n\n\t\t\t\t\t\t// if we've already got an edge here then skip adding a new one\n\t\t\t\t\t\tedgeData[ hash ] = {\n\n\t\t\t\t\t\t\tindex0: indexArr[ j ],\n\t\t\t\t\t\t\tindex1: indexArr[ jNext ],\n\t\t\t\t\t\t\tnormal: _normal.clone(),\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// iterate over all remaining, unmatched edges and add them to the vertex array\n\t\t\tfor ( const key in edgeData ) {\n\n\t\t\t\tif ( edgeData[ key ] ) {\n\n\t\t\t\t\tconst { index0, index1 } = edgeData[ key ];\n\t\t\t\t\t_v0.fromBufferAttribute( positionAttr, index0 );\n\t\t\t\t\t_v1.fromBufferAttribute( positionAttr, index1 );\n\n\t\t\t\t\tvertices.push( _v0.x, _v0.y, _v0.z );\n\t\t\t\t\tvertices.push( _v1.x, _v1.y, _v1.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\n\t\t}\n\n\t}\n\n}\n\nexport { EdgesGeometry };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}