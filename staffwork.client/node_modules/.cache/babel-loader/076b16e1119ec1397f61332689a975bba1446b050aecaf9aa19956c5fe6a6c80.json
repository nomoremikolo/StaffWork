{"ast":null,"code":"import { InterpolateLinear, InterpolateSmooth, InterpolateDiscrete } from '../constants.js';\nimport { CubicInterpolant } from '../math/interpolants/CubicInterpolant.js';\nimport { LinearInterpolant } from '../math/interpolants/LinearInterpolant.js';\nimport { DiscreteInterpolant } from '../math/interpolants/DiscreteInterpolant.js';\nimport * as AnimationUtils from './AnimationUtils.js';\nclass KeyframeTrack {\n  constructor(name, times, values, interpolation) {\n    if (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');\n    if (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);\n    this.name = name;\n    this.times = AnimationUtils.convertArray(times, this.TimeBufferType);\n    this.values = AnimationUtils.convertArray(values, this.ValueBufferType);\n    this.setInterpolation(interpolation || this.DefaultInterpolation);\n  }\n\n  // Serialization (in static context, because of constructor invocation\n  // and automatic invocation of .toJSON):\n\n  static toJSON(track) {\n    const trackType = track.constructor;\n    let json;\n\n    // derived classes can define a static toJSON method\n    if (trackType.toJSON !== this.toJSON) {\n      json = trackType.toJSON(track);\n    } else {\n      // by default, we assume the data can be serialized as-is\n      json = {\n        'name': track.name,\n        'times': AnimationUtils.convertArray(track.times, Array),\n        'values': AnimationUtils.convertArray(track.values, Array)\n      };\n      const interpolation = track.getInterpolation();\n      if (interpolation !== track.DefaultInterpolation) {\n        json.interpolation = interpolation;\n      }\n    }\n    json.type = track.ValueTypeName; // mandatory\n\n    return json;\n  }\n  InterpolantFactoryMethodDiscrete(result) {\n    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);\n  }\n  InterpolantFactoryMethodLinear(result) {\n    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);\n  }\n  InterpolantFactoryMethodSmooth(result) {\n    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);\n  }\n  setInterpolation(interpolation) {\n    let factoryMethod;\n    switch (interpolation) {\n      case InterpolateDiscrete:\n        factoryMethod = this.InterpolantFactoryMethodDiscrete;\n        break;\n      case InterpolateLinear:\n        factoryMethod = this.InterpolantFactoryMethodLinear;\n        break;\n      case InterpolateSmooth:\n        factoryMethod = this.InterpolantFactoryMethodSmooth;\n        break;\n    }\n    if (factoryMethod === undefined) {\n      const message = 'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name;\n      if (this.createInterpolant === undefined) {\n        // fall back to default, unless the default itself is messed up\n        if (interpolation !== this.DefaultInterpolation) {\n          this.setInterpolation(this.DefaultInterpolation);\n        } else {\n          throw new Error(message); // fatal, in this case\n        }\n      }\n\n      console.warn('THREE.KeyframeTrack:', message);\n      return this;\n    }\n    this.createInterpolant = factoryMethod;\n    return this;\n  }\n  getInterpolation() {\n    switch (this.createInterpolant) {\n      case this.InterpolantFactoryMethodDiscrete:\n        return InterpolateDiscrete;\n      case this.InterpolantFactoryMethodLinear:\n        return InterpolateLinear;\n      case this.InterpolantFactoryMethodSmooth:\n        return InterpolateSmooth;\n    }\n  }\n  getValueSize() {\n    return this.values.length / this.times.length;\n  }\n\n  // move all keyframes either forwards or backwards in time\n  shift(timeOffset) {\n    if (timeOffset !== 0.0) {\n      const times = this.times;\n      for (let i = 0, n = times.length; i !== n; ++i) {\n        times[i] += timeOffset;\n      }\n    }\n    return this;\n  }\n\n  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n  scale(timeScale) {\n    if (timeScale !== 1.0) {\n      const times = this.times;\n      for (let i = 0, n = times.length; i !== n; ++i) {\n        times[i] *= timeScale;\n      }\n    }\n    return this;\n  }\n\n  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n  trim(startTime, endTime) {\n    const times = this.times,\n      nKeys = times.length;\n    let from = 0,\n      to = nKeys - 1;\n    while (from !== nKeys && times[from] < startTime) {\n      ++from;\n    }\n    while (to !== -1 && times[to] > endTime) {\n      --to;\n    }\n    ++to; // inclusive -> exclusive bound\n\n    if (from !== 0 || to !== nKeys) {\n      // empty tracks are forbidden, so keep at least one keyframe\n      if (from >= to) {\n        to = Math.max(to, 1);\n        from = to - 1;\n      }\n      const stride = this.getValueSize();\n      this.times = AnimationUtils.arraySlice(times, from, to);\n      this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);\n    }\n    return this;\n  }\n\n  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n  validate() {\n    let valid = true;\n    const valueSize = this.getValueSize();\n    if (valueSize - Math.floor(valueSize) !== 0) {\n      console.error('THREE.KeyframeTrack: Invalid value size in track.', this);\n      valid = false;\n    }\n    const times = this.times,\n      values = this.values,\n      nKeys = times.length;\n    if (nKeys === 0) {\n      console.error('THREE.KeyframeTrack: Track is empty.', this);\n      valid = false;\n    }\n    let prevTime = null;\n    for (let i = 0; i !== nKeys; i++) {\n      const currTime = times[i];\n      if (typeof currTime === 'number' && isNaN(currTime)) {\n        console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime);\n        valid = false;\n        break;\n      }\n      if (prevTime !== null && prevTime > currTime) {\n        console.error('THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime);\n        valid = false;\n        break;\n      }\n      prevTime = currTime;\n    }\n    if (values !== undefined) {\n      if (AnimationUtils.isTypedArray(values)) {\n        for (let i = 0, n = values.length; i !== n; ++i) {\n          const value = values[i];\n          if (isNaN(value)) {\n            console.error('THREE.KeyframeTrack: Value is not a valid number.', this, i, value);\n            valid = false;\n            break;\n          }\n        }\n      }\n    }\n    return valid;\n  }\n\n  // removes equivalent sequential keys as common in morph target sequences\n  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n  optimize() {\n    // times or values may be shared with other tracks, so overwriting is unsafe\n    const times = AnimationUtils.arraySlice(this.times),\n      values = AnimationUtils.arraySlice(this.values),\n      stride = this.getValueSize(),\n      smoothInterpolation = this.getInterpolation() === InterpolateSmooth,\n      lastIndex = times.length - 1;\n    let writeIndex = 1;\n    for (let i = 1; i < lastIndex; ++i) {\n      let keep = false;\n      const time = times[i];\n      const timeNext = times[i + 1];\n\n      // remove adjacent keyframes scheduled at the same time\n\n      if (time !== timeNext && (i !== 1 || time !== times[0])) {\n        if (!smoothInterpolation) {\n          // remove unnecessary keyframes same as their neighbors\n\n          const offset = i * stride,\n            offsetP = offset - stride,\n            offsetN = offset + stride;\n          for (let j = 0; j !== stride; ++j) {\n            const value = values[offset + j];\n            if (value !== values[offsetP + j] || value !== values[offsetN + j]) {\n              keep = true;\n              break;\n            }\n          }\n        } else {\n          keep = true;\n        }\n      }\n\n      // in-place compaction\n\n      if (keep) {\n        if (i !== writeIndex) {\n          times[writeIndex] = times[i];\n          const readOffset = i * stride,\n            writeOffset = writeIndex * stride;\n          for (let j = 0; j !== stride; ++j) {\n            values[writeOffset + j] = values[readOffset + j];\n          }\n        }\n        ++writeIndex;\n      }\n    }\n\n    // flush last keyframe (compaction looks ahead)\n\n    if (lastIndex > 0) {\n      times[writeIndex] = times[lastIndex];\n      for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {\n        values[writeOffset + j] = values[readOffset + j];\n      }\n      ++writeIndex;\n    }\n    if (writeIndex !== times.length) {\n      this.times = AnimationUtils.arraySlice(times, 0, writeIndex);\n      this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);\n    } else {\n      this.times = times;\n      this.values = values;\n    }\n    return this;\n  }\n  clone() {\n    const times = AnimationUtils.arraySlice(this.times, 0);\n    const values = AnimationUtils.arraySlice(this.values, 0);\n    const TypedKeyframeTrack = this.constructor;\n    const track = new TypedKeyframeTrack(this.name, times, values);\n\n    // Interpolant argument to constructor is not saved, so copy the factory method directly.\n    track.createInterpolant = this.createInterpolant;\n    return track;\n  }\n}\nKeyframeTrack.prototype.TimeBufferType = Float32Array;\nKeyframeTrack.prototype.ValueBufferType = Float32Array;\nKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;\nexport { KeyframeTrack };","map":{"version":3,"names":["InterpolateLinear","InterpolateSmooth","InterpolateDiscrete","CubicInterpolant","LinearInterpolant","DiscreteInterpolant","AnimationUtils","KeyframeTrack","constructor","name","times","values","interpolation","undefined","Error","length","convertArray","TimeBufferType","ValueBufferType","setInterpolation","DefaultInterpolation","toJSON","track","trackType","json","Array","getInterpolation","type","ValueTypeName","InterpolantFactoryMethodDiscrete","result","getValueSize","InterpolantFactoryMethodLinear","InterpolantFactoryMethodSmooth","factoryMethod","message","createInterpolant","console","warn","shift","timeOffset","i","n","scale","timeScale","trim","startTime","endTime","nKeys","from","to","Math","max","stride","arraySlice","validate","valid","valueSize","floor","error","prevTime","currTime","isNaN","isTypedArray","value","optimize","smoothInterpolation","lastIndex","writeIndex","keep","time","timeNext","offset","offsetP","offsetN","j","readOffset","writeOffset","clone","TypedKeyframeTrack","prototype","Float32Array"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/animation/KeyframeTrack.js"],"sourcesContent":["import {\n\tInterpolateLinear,\n\tInterpolateSmooth,\n\tInterpolateDiscrete\n} from '../constants.js';\nimport { CubicInterpolant } from '../math/interpolants/CubicInterpolant.js';\nimport { LinearInterpolant } from '../math/interpolants/LinearInterpolant.js';\nimport { DiscreteInterpolant } from '../math/interpolants/DiscreteInterpolant.js';\nimport * as AnimationUtils from './AnimationUtils.js';\n\nclass KeyframeTrack {\n\n\tconstructor( name, times, values, interpolation ) {\n\n\t\tif ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );\n\t\tif ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );\n\n\t\tthis.name = name;\n\n\t\tthis.times = AnimationUtils.convertArray( times, this.TimeBufferType );\n\t\tthis.values = AnimationUtils.convertArray( values, this.ValueBufferType );\n\n\t\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\n\n\t}\n\n\t// Serialization (in static context, because of constructor invocation\n\t// and automatic invocation of .toJSON):\n\n\tstatic toJSON( track ) {\n\n\t\tconst trackType = track.constructor;\n\n\t\tlet json;\n\n\t\t// derived classes can define a static toJSON method\n\t\tif ( trackType.toJSON !== this.toJSON ) {\n\n\t\t\tjson = trackType.toJSON( track );\n\n\t\t} else {\n\n\t\t\t// by default, we assume the data can be serialized as-is\n\t\t\tjson = {\n\n\t\t\t\t'name': track.name,\n\t\t\t\t'times': AnimationUtils.convertArray( track.times, Array ),\n\t\t\t\t'values': AnimationUtils.convertArray( track.values, Array )\n\n\t\t\t};\n\n\t\t\tconst interpolation = track.getInterpolation();\n\n\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\n\n\t\t\t\tjson.interpolation = interpolation;\n\n\t\t\t}\n\n\t\t}\n\n\t\tjson.type = track.ValueTypeName; // mandatory\n\n\t\treturn json;\n\n\t}\n\n\tInterpolantFactoryMethodDiscrete( result ) {\n\n\t\treturn new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n\tInterpolantFactoryMethodLinear( result ) {\n\n\t\treturn new LinearInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n\tInterpolantFactoryMethodSmooth( result ) {\n\n\t\treturn new CubicInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n\tsetInterpolation( interpolation ) {\n\n\t\tlet factoryMethod;\n\n\t\tswitch ( interpolation ) {\n\n\t\t\tcase InterpolateDiscrete:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\n\n\t\t\t\tbreak;\n\n\t\t\tcase InterpolateLinear:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\n\n\t\t\t\tbreak;\n\n\t\t\tcase InterpolateSmooth:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tif ( factoryMethod === undefined ) {\n\n\t\t\tconst message = 'unsupported interpolation for ' +\n\t\t\t\tthis.ValueTypeName + ' keyframe track named ' + this.name;\n\n\t\t\tif ( this.createInterpolant === undefined ) {\n\n\t\t\t\t// fall back to default, unless the default itself is messed up\n\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\n\n\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( message ); // fatal, in this case\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.KeyframeTrack:', message );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tthis.createInterpolant = factoryMethod;\n\n\t\treturn this;\n\n\t}\n\n\tgetInterpolation() {\n\n\t\tswitch ( this.createInterpolant ) {\n\n\t\t\tcase this.InterpolantFactoryMethodDiscrete:\n\n\t\t\t\treturn InterpolateDiscrete;\n\n\t\t\tcase this.InterpolantFactoryMethodLinear:\n\n\t\t\t\treturn InterpolateLinear;\n\n\t\t\tcase this.InterpolantFactoryMethodSmooth:\n\n\t\t\t\treturn InterpolateSmooth;\n\n\t\t}\n\n\t}\n\n\tgetValueSize() {\n\n\t\treturn this.values.length / this.times.length;\n\n\t}\n\n\t// move all keyframes either forwards or backwards in time\n\tshift( timeOffset ) {\n\n\t\tif ( timeOffset !== 0.0 ) {\n\n\t\t\tconst times = this.times;\n\n\t\t\tfor ( let i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] += timeOffset;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n\tscale( timeScale ) {\n\n\t\tif ( timeScale !== 1.0 ) {\n\n\t\t\tconst times = this.times;\n\n\t\t\tfor ( let i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] *= timeScale;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n\ttrim( startTime, endTime ) {\n\n\t\tconst times = this.times,\n\t\t\tnKeys = times.length;\n\n\t\tlet from = 0,\n\t\t\tto = nKeys - 1;\n\n\t\twhile ( from !== nKeys && times[ from ] < startTime ) {\n\n\t\t\t++ from;\n\n\t\t}\n\n\t\twhile ( to !== - 1 && times[ to ] > endTime ) {\n\n\t\t\t-- to;\n\n\t\t}\n\n\t\t++ to; // inclusive -> exclusive bound\n\n\t\tif ( from !== 0 || to !== nKeys ) {\n\n\t\t\t// empty tracks are forbidden, so keep at least one keyframe\n\t\t\tif ( from >= to ) {\n\n\t\t\t\tto = Math.max( to, 1 );\n\t\t\t\tfrom = to - 1;\n\n\t\t\t}\n\n\t\t\tconst stride = this.getValueSize();\n\t\t\tthis.times = AnimationUtils.arraySlice( times, from, to );\n\t\t\tthis.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n\tvalidate() {\n\n\t\tlet valid = true;\n\n\t\tconst valueSize = this.getValueSize();\n\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\n\n\t\t\tconsole.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tconst times = this.times,\n\t\t\tvalues = this.values,\n\n\t\t\tnKeys = times.length;\n\n\t\tif ( nKeys === 0 ) {\n\n\t\t\tconsole.error( 'THREE.KeyframeTrack: Track is empty.', this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tlet prevTime = null;\n\n\t\tfor ( let i = 0; i !== nKeys; i ++ ) {\n\n\t\t\tconst currTime = times[ i ];\n\n\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\n\n\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( prevTime !== null && prevTime > currTime ) {\n\n\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tprevTime = currTime;\n\n\t\t}\n\n\t\tif ( values !== undefined ) {\n\n\t\t\tif ( AnimationUtils.isTypedArray( values ) ) {\n\n\t\t\t\tfor ( let i = 0, n = values.length; i !== n; ++ i ) {\n\n\t\t\t\t\tconst value = values[ i ];\n\n\t\t\t\t\tif ( isNaN( value ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );\n\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn valid;\n\n\t}\n\n\t// removes equivalent sequential keys as common in morph target sequences\n\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n\toptimize() {\n\n\t\t// times or values may be shared with other tracks, so overwriting is unsafe\n\t\tconst times = AnimationUtils.arraySlice( this.times ),\n\t\t\tvalues = AnimationUtils.arraySlice( this.values ),\n\t\t\tstride = this.getValueSize(),\n\n\t\t\tsmoothInterpolation = this.getInterpolation() === InterpolateSmooth,\n\n\t\t\tlastIndex = times.length - 1;\n\n\t\tlet writeIndex = 1;\n\n\t\tfor ( let i = 1; i < lastIndex; ++ i ) {\n\n\t\t\tlet keep = false;\n\n\t\t\tconst time = times[ i ];\n\t\t\tconst timeNext = times[ i + 1 ];\n\n\t\t\t// remove adjacent keyframes scheduled at the same time\n\n\t\t\tif ( time !== timeNext && ( i !== 1 || time !== times[ 0 ] ) ) {\n\n\t\t\t\tif ( ! smoothInterpolation ) {\n\n\t\t\t\t\t// remove unnecessary keyframes same as their neighbors\n\n\t\t\t\t\tconst offset = i * stride,\n\t\t\t\t\t\toffsetP = offset - stride,\n\t\t\t\t\t\toffsetN = offset + stride;\n\n\t\t\t\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\tconst value = values[ offset + j ];\n\n\t\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\n\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\n\n\t\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tkeep = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// in-place compaction\n\n\t\t\tif ( keep ) {\n\n\t\t\t\tif ( i !== writeIndex ) {\n\n\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\n\n\t\t\t\t\tconst readOffset = i * stride,\n\t\t\t\t\t\twriteOffset = writeIndex * stride;\n\n\t\t\t\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t++ writeIndex;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// flush last keyframe (compaction looks ahead)\n\n\t\tif ( lastIndex > 0 ) {\n\n\t\t\ttimes[ writeIndex ] = times[ lastIndex ];\n\n\t\t\tfor ( let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {\n\n\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t}\n\n\t\t\t++ writeIndex;\n\n\t\t}\n\n\t\tif ( writeIndex !== times.length ) {\n\n\t\t\tthis.times = AnimationUtils.arraySlice( times, 0, writeIndex );\n\t\t\tthis.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );\n\n\t\t} else {\n\n\t\t\tthis.times = times;\n\t\t\tthis.values = values;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\tconst times = AnimationUtils.arraySlice( this.times, 0 );\n\t\tconst values = AnimationUtils.arraySlice( this.values, 0 );\n\n\t\tconst TypedKeyframeTrack = this.constructor;\n\t\tconst track = new TypedKeyframeTrack( this.name, times, values );\n\n\t\t// Interpolant argument to constructor is not saved, so copy the factory method directly.\n\t\ttrack.createInterpolant = this.createInterpolant;\n\n\t\treturn track;\n\n\t}\n\n}\n\nKeyframeTrack.prototype.TimeBufferType = Float32Array;\nKeyframeTrack.prototype.ValueBufferType = Float32Array;\nKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;\n\nexport { KeyframeTrack };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}