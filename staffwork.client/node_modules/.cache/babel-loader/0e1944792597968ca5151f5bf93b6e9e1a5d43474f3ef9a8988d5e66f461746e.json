{"ast":null,"code":"import { Sphere } from '../math/Sphere.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { BufferAttribute } from '../core/BufferAttribute.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { FileLoader } from './FileLoader.js';\nimport { Loader } from './Loader.js';\nimport { InstancedBufferGeometry } from '../core/InstancedBufferGeometry.js';\nimport { InstancedBufferAttribute } from '../core/InstancedBufferAttribute.js';\nimport { InterleavedBufferAttribute } from '../core/InterleavedBufferAttribute.js';\nimport { InterleavedBuffer } from '../core/InterleavedBuffer.js';\nimport { getTypedArray } from '../utils.js';\nclass BufferGeometryLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(JSON.parse(text)));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(json) {\n    const interleavedBufferMap = {};\n    const arrayBufferMap = {};\n    function getInterleavedBuffer(json, uuid) {\n      if (interleavedBufferMap[uuid] !== undefined) return interleavedBufferMap[uuid];\n      const interleavedBuffers = json.interleavedBuffers;\n      const interleavedBuffer = interleavedBuffers[uuid];\n      const buffer = getArrayBuffer(json, interleavedBuffer.buffer);\n      const array = getTypedArray(interleavedBuffer.type, buffer);\n      const ib = new InterleavedBuffer(array, interleavedBuffer.stride);\n      ib.uuid = interleavedBuffer.uuid;\n      interleavedBufferMap[uuid] = ib;\n      return ib;\n    }\n    function getArrayBuffer(json, uuid) {\n      if (arrayBufferMap[uuid] !== undefined) return arrayBufferMap[uuid];\n      const arrayBuffers = json.arrayBuffers;\n      const arrayBuffer = arrayBuffers[uuid];\n      const ab = new Uint32Array(arrayBuffer).buffer;\n      arrayBufferMap[uuid] = ab;\n      return ab;\n    }\n    const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();\n    const index = json.data.index;\n    if (index !== undefined) {\n      const typedArray = getTypedArray(index.type, index.array);\n      geometry.setIndex(new BufferAttribute(typedArray, 1));\n    }\n    const attributes = json.data.attributes;\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      let bufferAttribute;\n      if (attribute.isInterleavedBufferAttribute) {\n        const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);\n        bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);\n      } else {\n        const typedArray = getTypedArray(attribute.type, attribute.array);\n        const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;\n        bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);\n      }\n      if (attribute.name !== undefined) bufferAttribute.name = attribute.name;\n      if (attribute.usage !== undefined) bufferAttribute.setUsage(attribute.usage);\n      if (attribute.updateRange !== undefined) {\n        bufferAttribute.updateRange.offset = attribute.updateRange.offset;\n        bufferAttribute.updateRange.count = attribute.updateRange.count;\n      }\n      geometry.setAttribute(key, bufferAttribute);\n    }\n    const morphAttributes = json.data.morphAttributes;\n    if (morphAttributes) {\n      for (const key in morphAttributes) {\n        const attributeArray = morphAttributes[key];\n        const array = [];\n        for (let i = 0, il = attributeArray.length; i < il; i++) {\n          const attribute = attributeArray[i];\n          let bufferAttribute;\n          if (attribute.isInterleavedBufferAttribute) {\n            const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);\n            bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);\n          } else {\n            const typedArray = getTypedArray(attribute.type, attribute.array);\n            bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);\n          }\n          if (attribute.name !== undefined) bufferAttribute.name = attribute.name;\n          array.push(bufferAttribute);\n        }\n        geometry.morphAttributes[key] = array;\n      }\n    }\n    const morphTargetsRelative = json.data.morphTargetsRelative;\n    if (morphTargetsRelative) {\n      geometry.morphTargetsRelative = true;\n    }\n    const groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n    if (groups !== undefined) {\n      for (let i = 0, n = groups.length; i !== n; ++i) {\n        const group = groups[i];\n        geometry.addGroup(group.start, group.count, group.materialIndex);\n      }\n    }\n    const boundingSphere = json.data.boundingSphere;\n    if (boundingSphere !== undefined) {\n      const center = new Vector3();\n      if (boundingSphere.center !== undefined) {\n        center.fromArray(boundingSphere.center);\n      }\n      geometry.boundingSphere = new Sphere(center, boundingSphere.radius);\n    }\n    if (json.name) geometry.name = json.name;\n    if (json.userData) geometry.userData = json.userData;\n    return geometry;\n  }\n}\nexport { BufferGeometryLoader };","map":{"version":3,"names":["Sphere","Vector3","BufferAttribute","BufferGeometry","FileLoader","Loader","InstancedBufferGeometry","InstancedBufferAttribute","InterleavedBufferAttribute","InterleavedBuffer","getTypedArray","BufferGeometryLoader","constructor","manager","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","JSON","e","console","error","itemError","json","interleavedBufferMap","arrayBufferMap","getInterleavedBuffer","uuid","undefined","interleavedBuffers","interleavedBuffer","buffer","getArrayBuffer","array","type","ib","stride","arrayBuffers","arrayBuffer","ab","Uint32Array","geometry","isInstancedBufferGeometry","index","data","typedArray","setIndex","attributes","key","attribute","bufferAttribute","isInterleavedBufferAttribute","itemSize","offset","normalized","bufferAttributeConstr","isInstancedBufferAttribute","name","usage","setUsage","updateRange","count","setAttribute","morphAttributes","attributeArray","i","il","length","push","morphTargetsRelative","groups","drawcalls","offsets","n","group","addGroup","start","materialIndex","boundingSphere","center","fromArray","radius","userData"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/loaders/BufferGeometryLoader.js"],"sourcesContent":["import { Sphere } from '../math/Sphere.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { BufferAttribute } from '../core/BufferAttribute.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { FileLoader } from './FileLoader.js';\nimport { Loader } from './Loader.js';\nimport { InstancedBufferGeometry } from '../core/InstancedBufferGeometry.js';\nimport { InstancedBufferAttribute } from '../core/InstancedBufferAttribute.js';\nimport { InterleavedBufferAttribute } from '../core/InterleavedBufferAttribute.js';\nimport { InterleavedBuffer } from '../core/InterleavedBuffer.js';\nimport { getTypedArray } from '../utils.js';\n\nclass BufferGeometryLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( json ) {\n\n\t\tconst interleavedBufferMap = {};\n\t\tconst arrayBufferMap = {};\n\n\t\tfunction getInterleavedBuffer( json, uuid ) {\n\n\t\t\tif ( interleavedBufferMap[ uuid ] !== undefined ) return interleavedBufferMap[ uuid ];\n\n\t\t\tconst interleavedBuffers = json.interleavedBuffers;\n\t\t\tconst interleavedBuffer = interleavedBuffers[ uuid ];\n\n\t\t\tconst buffer = getArrayBuffer( json, interleavedBuffer.buffer );\n\n\t\t\tconst array = getTypedArray( interleavedBuffer.type, buffer );\n\t\t\tconst ib = new InterleavedBuffer( array, interleavedBuffer.stride );\n\t\t\tib.uuid = interleavedBuffer.uuid;\n\n\t\t\tinterleavedBufferMap[ uuid ] = ib;\n\n\t\t\treturn ib;\n\n\t\t}\n\n\t\tfunction getArrayBuffer( json, uuid ) {\n\n\t\t\tif ( arrayBufferMap[ uuid ] !== undefined ) return arrayBufferMap[ uuid ];\n\n\t\t\tconst arrayBuffers = json.arrayBuffers;\n\t\t\tconst arrayBuffer = arrayBuffers[ uuid ];\n\n\t\t\tconst ab = new Uint32Array( arrayBuffer ).buffer;\n\n\t\t\tarrayBufferMap[ uuid ] = ab;\n\n\t\t\treturn ab;\n\n\t\t}\n\n\t\tconst geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();\n\n\t\tconst index = json.data.index;\n\n\t\tif ( index !== undefined ) {\n\n\t\t\tconst typedArray = getTypedArray( index.type, index.array );\n\t\t\tgeometry.setIndex( new BufferAttribute( typedArray, 1 ) );\n\n\t\t}\n\n\t\tconst attributes = json.data.attributes;\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attribute = attributes[ key ];\n\t\t\tlet bufferAttribute;\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\tconst interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );\n\t\t\t\tbufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );\n\n\t\t\t} else {\n\n\t\t\t\tconst typedArray = getTypedArray( attribute.type, attribute.array );\n\t\t\t\tconst bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;\n\t\t\t\tbufferAttribute = new bufferAttributeConstr( typedArray, attribute.itemSize, attribute.normalized );\n\n\t\t\t}\n\n\t\t\tif ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;\n\t\t\tif ( attribute.usage !== undefined ) bufferAttribute.setUsage( attribute.usage );\n\n\t\t\tif ( attribute.updateRange !== undefined ) {\n\n\t\t\t\tbufferAttribute.updateRange.offset = attribute.updateRange.offset;\n\t\t\t\tbufferAttribute.updateRange.count = attribute.updateRange.count;\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( key, bufferAttribute );\n\n\t\t}\n\n\t\tconst morphAttributes = json.data.morphAttributes;\n\n\t\tif ( morphAttributes ) {\n\n\t\t\tfor ( const key in morphAttributes ) {\n\n\t\t\t\tconst attributeArray = morphAttributes[ key ];\n\n\t\t\t\tconst array = [];\n\n\t\t\t\tfor ( let i = 0, il = attributeArray.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst attribute = attributeArray[ i ];\n\t\t\t\t\tlet bufferAttribute;\n\n\t\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\t\tconst interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );\n\t\t\t\t\t\tbufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst typedArray = getTypedArray( attribute.type, attribute.array );\n\t\t\t\t\t\tbufferAttribute = new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;\n\t\t\t\t\tarray.push( bufferAttribute );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.morphAttributes[ key ] = array;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst morphTargetsRelative = json.data.morphTargetsRelative;\n\n\t\tif ( morphTargetsRelative ) {\n\n\t\t\tgeometry.morphTargetsRelative = true;\n\n\t\t}\n\n\t\tconst groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n\n\t\tif ( groups !== undefined ) {\n\n\t\t\tfor ( let i = 0, n = groups.length; i !== n; ++ i ) {\n\n\t\t\t\tconst group = groups[ i ];\n\n\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst boundingSphere = json.data.boundingSphere;\n\n\t\tif ( boundingSphere !== undefined ) {\n\n\t\t\tconst center = new Vector3();\n\n\t\t\tif ( boundingSphere.center !== undefined ) {\n\n\t\t\t\tcenter.fromArray( boundingSphere.center );\n\n\t\t\t}\n\n\t\t\tgeometry.boundingSphere = new Sphere( center, boundingSphere.radius );\n\n\t\t}\n\n\t\tif ( json.name ) geometry.name = json.name;\n\t\tif ( json.userData ) geometry.userData = json.userData;\n\n\t\treturn geometry;\n\n\t}\n\n}\n\nexport { BufferGeometryLoader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}