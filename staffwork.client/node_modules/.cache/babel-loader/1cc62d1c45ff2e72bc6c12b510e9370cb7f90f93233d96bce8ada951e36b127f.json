{"ast":null,"code":"import { FloatType } from '../../constants.js';\nimport { DataArrayTexture } from '../../textures/DataArrayTexture.js';\nimport { Vector4 } from '../../math/Vector4.js';\nimport { Vector2 } from '../../math/Vector2.js';\nfunction numericalSort(a, b) {\n  return a[0] - b[0];\n}\nfunction absNumericalSort(a, b) {\n  return Math.abs(b[1]) - Math.abs(a[1]);\n}\nfunction WebGLMorphtargets(gl, capabilities, textures) {\n  const influencesList = {};\n  const morphInfluences = new Float32Array(8);\n  const morphTextures = new WeakMap();\n  const morph = new Vector4();\n  const workInfluences = [];\n  for (let i = 0; i < 8; i++) {\n    workInfluences[i] = [i, 0];\n  }\n  function update(object, geometry, material, program) {\n    const objectInfluences = object.morphTargetInfluences;\n    if (capabilities.isWebGL2 === true) {\n      // instead of using attributes, the WebGL 2 code path encodes morph targets\n      // into an array of data textures. Each layer represents a single morph target.\n\n      const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n      const morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;\n      let entry = morphTextures.get(geometry);\n      if (entry === undefined || entry.count !== morphTargetsCount) {\n        if (entry !== undefined) entry.texture.dispose();\n        const hasMorphPosition = geometry.morphAttributes.position !== undefined;\n        const hasMorphNormals = geometry.morphAttributes.normal !== undefined;\n        const hasMorphColors = geometry.morphAttributes.color !== undefined;\n        const morphTargets = geometry.morphAttributes.position || [];\n        const morphNormals = geometry.morphAttributes.normal || [];\n        const morphColors = geometry.morphAttributes.color || [];\n        let vertexDataCount = 0;\n        if (hasMorphPosition === true) vertexDataCount = 1;\n        if (hasMorphNormals === true) vertexDataCount = 2;\n        if (hasMorphColors === true) vertexDataCount = 3;\n        let width = geometry.attributes.position.count * vertexDataCount;\n        let height = 1;\n        if (width > capabilities.maxTextureSize) {\n          height = Math.ceil(width / capabilities.maxTextureSize);\n          width = capabilities.maxTextureSize;\n        }\n        const buffer = new Float32Array(width * height * 4 * morphTargetsCount);\n        const texture = new DataArrayTexture(buffer, width, height, morphTargetsCount);\n        texture.type = FloatType;\n        texture.needsUpdate = true;\n\n        // fill buffer\n\n        const vertexDataStride = vertexDataCount * 4;\n        for (let i = 0; i < morphTargetsCount; i++) {\n          const morphTarget = morphTargets[i];\n          const morphNormal = morphNormals[i];\n          const morphColor = morphColors[i];\n          const offset = width * height * 4 * i;\n          for (let j = 0; j < morphTarget.count; j++) {\n            const stride = j * vertexDataStride;\n            if (hasMorphPosition === true) {\n              morph.fromBufferAttribute(morphTarget, j);\n              buffer[offset + stride + 0] = morph.x;\n              buffer[offset + stride + 1] = morph.y;\n              buffer[offset + stride + 2] = morph.z;\n              buffer[offset + stride + 3] = 0;\n            }\n            if (hasMorphNormals === true) {\n              morph.fromBufferAttribute(morphNormal, j);\n              buffer[offset + stride + 4] = morph.x;\n              buffer[offset + stride + 5] = morph.y;\n              buffer[offset + stride + 6] = morph.z;\n              buffer[offset + stride + 7] = 0;\n            }\n            if (hasMorphColors === true) {\n              morph.fromBufferAttribute(morphColor, j);\n              buffer[offset + stride + 8] = morph.x;\n              buffer[offset + stride + 9] = morph.y;\n              buffer[offset + stride + 10] = morph.z;\n              buffer[offset + stride + 11] = morphColor.itemSize === 4 ? morph.w : 1;\n            }\n          }\n        }\n        entry = {\n          count: morphTargetsCount,\n          texture: texture,\n          size: new Vector2(width, height)\n        };\n        morphTextures.set(geometry, entry);\n        function disposeTexture() {\n          texture.dispose();\n          morphTextures.delete(geometry);\n          geometry.removeEventListener('dispose', disposeTexture);\n        }\n        geometry.addEventListener('dispose', disposeTexture);\n      }\n\n      //\n\n      let morphInfluencesSum = 0;\n      for (let i = 0; i < objectInfluences.length; i++) {\n        morphInfluencesSum += objectInfluences[i];\n      }\n      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n      program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);\n      program.getUniforms().setValue(gl, 'morphTargetInfluences', objectInfluences);\n      program.getUniforms().setValue(gl, 'morphTargetsTexture', entry.texture, textures);\n      program.getUniforms().setValue(gl, 'morphTargetsTextureSize', entry.size);\n    } else {\n      // When object doesn't have morph target influences defined, we treat it as a 0-length array\n      // This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences\n\n      const length = objectInfluences === undefined ? 0 : objectInfluences.length;\n      let influences = influencesList[geometry.id];\n      if (influences === undefined || influences.length !== length) {\n        // initialise list\n\n        influences = [];\n        for (let i = 0; i < length; i++) {\n          influences[i] = [i, 0];\n        }\n        influencesList[geometry.id] = influences;\n      }\n\n      // Collect influences\n\n      for (let i = 0; i < length; i++) {\n        const influence = influences[i];\n        influence[0] = i;\n        influence[1] = objectInfluences[i];\n      }\n      influences.sort(absNumericalSort);\n      for (let i = 0; i < 8; i++) {\n        if (i < length && influences[i][1]) {\n          workInfluences[i][0] = influences[i][0];\n          workInfluences[i][1] = influences[i][1];\n        } else {\n          workInfluences[i][0] = Number.MAX_SAFE_INTEGER;\n          workInfluences[i][1] = 0;\n        }\n      }\n      workInfluences.sort(numericalSort);\n      const morphTargets = geometry.morphAttributes.position;\n      const morphNormals = geometry.morphAttributes.normal;\n      let morphInfluencesSum = 0;\n      for (let i = 0; i < 8; i++) {\n        const influence = workInfluences[i];\n        const index = influence[0];\n        const value = influence[1];\n        if (index !== Number.MAX_SAFE_INTEGER && value) {\n          if (morphTargets && geometry.getAttribute('morphTarget' + i) !== morphTargets[index]) {\n            geometry.setAttribute('morphTarget' + i, morphTargets[index]);\n          }\n          if (morphNormals && geometry.getAttribute('morphNormal' + i) !== morphNormals[index]) {\n            geometry.setAttribute('morphNormal' + i, morphNormals[index]);\n          }\n          morphInfluences[i] = value;\n          morphInfluencesSum += value;\n        } else {\n          if (morphTargets && geometry.hasAttribute('morphTarget' + i) === true) {\n            geometry.deleteAttribute('morphTarget' + i);\n          }\n          if (morphNormals && geometry.hasAttribute('morphNormal' + i) === true) {\n            geometry.deleteAttribute('morphNormal' + i);\n          }\n          morphInfluences[i] = 0;\n        }\n      }\n\n      // GLSL shader uses formula baseinfluence * base + sum(target * influence)\n      // This allows us to switch between absolute morphs and relative morphs without changing shader code\n      // When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)\n      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n      program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);\n      program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);\n    }\n  }\n  return {\n    update: update\n  };\n}\nexport { WebGLMorphtargets };","map":{"version":3,"names":["FloatType","DataArrayTexture","Vector4","Vector2","numericalSort","a","b","absNumericalSort","Math","abs","WebGLMorphtargets","gl","capabilities","textures","influencesList","morphInfluences","Float32Array","morphTextures","WeakMap","morph","workInfluences","i","update","object","geometry","material","program","objectInfluences","morphTargetInfluences","isWebGL2","morphAttribute","morphAttributes","position","normal","color","morphTargetsCount","undefined","length","entry","get","count","texture","dispose","hasMorphPosition","hasMorphNormals","hasMorphColors","morphTargets","morphNormals","morphColors","vertexDataCount","width","attributes","height","maxTextureSize","ceil","buffer","type","needsUpdate","vertexDataStride","morphTarget","morphNormal","morphColor","offset","j","stride","fromBufferAttribute","x","y","z","itemSize","w","size","set","disposeTexture","delete","removeEventListener","addEventListener","morphInfluencesSum","morphBaseInfluence","morphTargetsRelative","getUniforms","setValue","influences","id","influence","sort","Number","MAX_SAFE_INTEGER","index","value","getAttribute","setAttribute","hasAttribute","deleteAttribute"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/renderers/webgl/WebGLMorphtargets.js"],"sourcesContent":["import { FloatType } from '../../constants.js';\nimport { DataArrayTexture } from '../../textures/DataArrayTexture.js';\nimport { Vector4 } from '../../math/Vector4.js';\nimport { Vector2 } from '../../math/Vector2.js';\n\nfunction numericalSort( a, b ) {\n\n\treturn a[ 0 ] - b[ 0 ];\n\n}\n\nfunction absNumericalSort( a, b ) {\n\n\treturn Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );\n\n}\n\nfunction WebGLMorphtargets( gl, capabilities, textures ) {\n\n\tconst influencesList = {};\n\tconst morphInfluences = new Float32Array( 8 );\n\tconst morphTextures = new WeakMap();\n\tconst morph = new Vector4();\n\n\tconst workInfluences = [];\n\n\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\tworkInfluences[ i ] = [ i, 0 ];\n\n\t}\n\n\tfunction update( object, geometry, material, program ) {\n\n\t\tconst objectInfluences = object.morphTargetInfluences;\n\n\t\tif ( capabilities.isWebGL2 === true ) {\n\n\t\t\t// instead of using attributes, the WebGL 2 code path encodes morph targets\n\t\t\t// into an array of data textures. Each layer represents a single morph target.\n\n\t\t\tconst morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n\t\t\tconst morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;\n\n\t\t\tlet entry = morphTextures.get( geometry );\n\n\t\t\tif ( entry === undefined || entry.count !== morphTargetsCount ) {\n\n\t\t\t\tif ( entry !== undefined ) entry.texture.dispose();\n\n\t\t\t\tconst hasMorphPosition = geometry.morphAttributes.position !== undefined;\n\t\t\t\tconst hasMorphNormals = geometry.morphAttributes.normal !== undefined;\n\t\t\t\tconst hasMorphColors = geometry.morphAttributes.color !== undefined;\n\n\t\t\t\tconst morphTargets = geometry.morphAttributes.position || [];\n\t\t\t\tconst morphNormals = geometry.morphAttributes.normal || [];\n\t\t\t\tconst morphColors = geometry.morphAttributes.color || [];\n\n\t\t\t\tlet vertexDataCount = 0;\n\n\t\t\t\tif ( hasMorphPosition === true ) vertexDataCount = 1;\n\t\t\t\tif ( hasMorphNormals === true ) vertexDataCount = 2;\n\t\t\t\tif ( hasMorphColors === true ) vertexDataCount = 3;\n\n\t\t\t\tlet width = geometry.attributes.position.count * vertexDataCount;\n\t\t\t\tlet height = 1;\n\n\t\t\t\tif ( width > capabilities.maxTextureSize ) {\n\n\t\t\t\t\theight = Math.ceil( width / capabilities.maxTextureSize );\n\t\t\t\t\twidth = capabilities.maxTextureSize;\n\n\t\t\t\t}\n\n\t\t\t\tconst buffer = new Float32Array( width * height * 4 * morphTargetsCount );\n\n\t\t\t\tconst texture = new DataArrayTexture( buffer, width, height, morphTargetsCount );\n\t\t\t\ttexture.type = FloatType;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t// fill buffer\n\n\t\t\t\tconst vertexDataStride = vertexDataCount * 4;\n\n\t\t\t\tfor ( let i = 0; i < morphTargetsCount; i ++ ) {\n\n\t\t\t\t\tconst morphTarget = morphTargets[ i ];\n\t\t\t\t\tconst morphNormal = morphNormals[ i ];\n\t\t\t\t\tconst morphColor = morphColors[ i ];\n\n\t\t\t\t\tconst offset = width * height * 4 * i;\n\n\t\t\t\t\tfor ( let j = 0; j < morphTarget.count; j ++ ) {\n\n\t\t\t\t\t\tconst stride = j * vertexDataStride;\n\n\t\t\t\t\t\tif ( hasMorphPosition === true ) {\n\n\t\t\t\t\t\t\tmorph.fromBufferAttribute( morphTarget, j );\n\n\t\t\t\t\t\t\tbuffer[ offset + stride + 0 ] = morph.x;\n\t\t\t\t\t\t\tbuffer[ offset + stride + 1 ] = morph.y;\n\t\t\t\t\t\t\tbuffer[ offset + stride + 2 ] = morph.z;\n\t\t\t\t\t\t\tbuffer[ offset + stride + 3 ] = 0;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hasMorphNormals === true ) {\n\n\t\t\t\t\t\t\tmorph.fromBufferAttribute( morphNormal, j );\n\n\t\t\t\t\t\t\tbuffer[ offset + stride + 4 ] = morph.x;\n\t\t\t\t\t\t\tbuffer[ offset + stride + 5 ] = morph.y;\n\t\t\t\t\t\t\tbuffer[ offset + stride + 6 ] = morph.z;\n\t\t\t\t\t\t\tbuffer[ offset + stride + 7 ] = 0;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hasMorphColors === true ) {\n\n\t\t\t\t\t\t\tmorph.fromBufferAttribute( morphColor, j );\n\n\t\t\t\t\t\t\tbuffer[ offset + stride + 8 ] = morph.x;\n\t\t\t\t\t\t\tbuffer[ offset + stride + 9 ] = morph.y;\n\t\t\t\t\t\t\tbuffer[ offset + stride + 10 ] = morph.z;\n\t\t\t\t\t\t\tbuffer[ offset + stride + 11 ] = ( morphColor.itemSize === 4 ) ? morph.w : 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tentry = {\n\t\t\t\t\tcount: morphTargetsCount,\n\t\t\t\t\ttexture: texture,\n\t\t\t\t\tsize: new Vector2( width, height )\n\t\t\t\t};\n\n\t\t\t\tmorphTextures.set( geometry, entry );\n\n\t\t\t\tfunction disposeTexture() {\n\n\t\t\t\t\ttexture.dispose();\n\n\t\t\t\t\tmorphTextures.delete( geometry );\n\n\t\t\t\t\tgeometry.removeEventListener( 'dispose', disposeTexture );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.addEventListener( 'dispose', disposeTexture );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tlet morphInfluencesSum = 0;\n\n\t\t\tfor ( let i = 0; i < objectInfluences.length; i ++ ) {\n\n\t\t\t\tmorphInfluencesSum += objectInfluences[ i ];\n\n\t\t\t}\n\n\t\t\tconst morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n\n\t\t\tprogram.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );\n\t\t\tprogram.getUniforms().setValue( gl, 'morphTargetInfluences', objectInfluences );\n\n\t\t\tprogram.getUniforms().setValue( gl, 'morphTargetsTexture', entry.texture, textures );\n\t\t\tprogram.getUniforms().setValue( gl, 'morphTargetsTextureSize', entry.size );\n\n\n\t\t} else {\n\n\t\t\t// When object doesn't have morph target influences defined, we treat it as a 0-length array\n\t\t\t// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences\n\n\t\t\tconst length = objectInfluences === undefined ? 0 : objectInfluences.length;\n\n\t\t\tlet influences = influencesList[ geometry.id ];\n\n\t\t\tif ( influences === undefined || influences.length !== length ) {\n\n\t\t\t\t// initialise list\n\n\t\t\t\tinfluences = [];\n\n\t\t\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\t\t\tinfluences[ i ] = [ i, 0 ];\n\n\t\t\t\t}\n\n\t\t\t\tinfluencesList[ geometry.id ] = influences;\n\n\t\t\t}\n\n\t\t\t// Collect influences\n\n\t\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\t\tconst influence = influences[ i ];\n\n\t\t\t\tinfluence[ 0 ] = i;\n\t\t\t\tinfluence[ 1 ] = objectInfluences[ i ];\n\n\t\t\t}\n\n\t\t\tinfluences.sort( absNumericalSort );\n\n\t\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\t\tif ( i < length && influences[ i ][ 1 ] ) {\n\n\t\t\t\t\tworkInfluences[ i ][ 0 ] = influences[ i ][ 0 ];\n\t\t\t\t\tworkInfluences[ i ][ 1 ] = influences[ i ][ 1 ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tworkInfluences[ i ][ 0 ] = Number.MAX_SAFE_INTEGER;\n\t\t\t\t\tworkInfluences[ i ][ 1 ] = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tworkInfluences.sort( numericalSort );\n\n\t\t\tconst morphTargets = geometry.morphAttributes.position;\n\t\t\tconst morphNormals = geometry.morphAttributes.normal;\n\n\t\t\tlet morphInfluencesSum = 0;\n\n\t\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\t\tconst influence = workInfluences[ i ];\n\t\t\t\tconst index = influence[ 0 ];\n\t\t\t\tconst value = influence[ 1 ];\n\n\t\t\t\tif ( index !== Number.MAX_SAFE_INTEGER && value ) {\n\n\t\t\t\t\tif ( morphTargets && geometry.getAttribute( 'morphTarget' + i ) !== morphTargets[ index ] ) {\n\n\t\t\t\t\t\tgeometry.setAttribute( 'morphTarget' + i, morphTargets[ index ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( morphNormals && geometry.getAttribute( 'morphNormal' + i ) !== morphNormals[ index ] ) {\n\n\t\t\t\t\t\tgeometry.setAttribute( 'morphNormal' + i, morphNormals[ index ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmorphInfluences[ i ] = value;\n\t\t\t\t\tmorphInfluencesSum += value;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( morphTargets && geometry.hasAttribute( 'morphTarget' + i ) === true ) {\n\n\t\t\t\t\t\tgeometry.deleteAttribute( 'morphTarget' + i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( morphNormals && geometry.hasAttribute( 'morphNormal' + i ) === true ) {\n\n\t\t\t\t\t\tgeometry.deleteAttribute( 'morphNormal' + i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmorphInfluences[ i ] = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// GLSL shader uses formula baseinfluence * base + sum(target * influence)\n\t\t\t// This allows us to switch between absolute morphs and relative morphs without changing shader code\n\t\t\t// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)\n\t\t\tconst morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n\n\t\t\tprogram.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );\n\t\t\tprogram.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );\n\n\t\t}\n\n\t}\n\n\treturn {\n\n\t\tupdate: update\n\n\t};\n\n}\n\n\nexport { WebGLMorphtargets };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}