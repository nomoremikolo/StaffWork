{"ast":null,"code":"import { Vector3 } from './Vector3.js';\nconst _vector = /*@__PURE__*/new Vector3();\nconst _segCenter = /*@__PURE__*/new Vector3();\nconst _segDir = /*@__PURE__*/new Vector3();\nconst _diff = /*@__PURE__*/new Vector3();\nconst _edge1 = /*@__PURE__*/new Vector3();\nconst _edge2 = /*@__PURE__*/new Vector3();\nconst _normal = /*@__PURE__*/new Vector3();\nclass Ray {\n  constructor() {\n    let origin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\n    let direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3(0, 0, -1);\n    this.origin = origin;\n    this.direction = direction;\n  }\n  set(origin, direction) {\n    this.origin.copy(origin);\n    this.direction.copy(direction);\n    return this;\n  }\n  copy(ray) {\n    this.origin.copy(ray.origin);\n    this.direction.copy(ray.direction);\n    return this;\n  }\n  at(t, target) {\n    return target.copy(this.direction).multiplyScalar(t).add(this.origin);\n  }\n  lookAt(v) {\n    this.direction.copy(v).sub(this.origin).normalize();\n    return this;\n  }\n  recast(t) {\n    this.origin.copy(this.at(t, _vector));\n    return this;\n  }\n  closestPointToPoint(point, target) {\n    target.subVectors(point, this.origin);\n    const directionDistance = target.dot(this.direction);\n    if (directionDistance < 0) {\n      return target.copy(this.origin);\n    }\n    return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);\n  }\n  distanceToPoint(point) {\n    return Math.sqrt(this.distanceSqToPoint(point));\n  }\n  distanceSqToPoint(point) {\n    const directionDistance = _vector.subVectors(point, this.origin).dot(this.direction);\n\n    // point behind the ray\n\n    if (directionDistance < 0) {\n      return this.origin.distanceToSquared(point);\n    }\n    _vector.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);\n    return _vector.distanceToSquared(point);\n  }\n  distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {\n    // from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h\n    // It returns the min distance between the ray and the segment\n    // defined by v0 and v1\n    // It can also set two optional targets :\n    // - The closest point on the ray\n    // - The closest point on the segment\n\n    _segCenter.copy(v0).add(v1).multiplyScalar(0.5);\n    _segDir.copy(v1).sub(v0).normalize();\n    _diff.copy(this.origin).sub(_segCenter);\n    const segExtent = v0.distanceTo(v1) * 0.5;\n    const a01 = -this.direction.dot(_segDir);\n    const b0 = _diff.dot(this.direction);\n    const b1 = -_diff.dot(_segDir);\n    const c = _diff.lengthSq();\n    const det = Math.abs(1 - a01 * a01);\n    let s0, s1, sqrDist, extDet;\n    if (det > 0) {\n      // The ray and segment are not parallel.\n\n      s0 = a01 * b1 - b0;\n      s1 = a01 * b0 - b1;\n      extDet = segExtent * det;\n      if (s0 >= 0) {\n        if (s1 >= -extDet) {\n          if (s1 <= extDet) {\n            // region 0\n            // Minimum at interior points of ray and segment.\n\n            const invDet = 1 / det;\n            s0 *= invDet;\n            s1 *= invDet;\n            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;\n          } else {\n            // region 1\n\n            s1 = segExtent;\n            s0 = Math.max(0, -(a01 * s1 + b0));\n            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n          }\n        } else {\n          // region 5\n\n          s1 = -segExtent;\n          s0 = Math.max(0, -(a01 * s1 + b0));\n          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n        }\n      } else {\n        if (s1 <= -extDet) {\n          // region 4\n\n          s0 = Math.max(0, -(-a01 * segExtent + b0));\n          s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\n          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n        } else if (s1 <= extDet) {\n          // region 3\n\n          s0 = 0;\n          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);\n          sqrDist = s1 * (s1 + 2 * b1) + c;\n        } else {\n          // region 2\n\n          s0 = Math.max(0, -(a01 * segExtent + b0));\n          s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\n          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n        }\n      }\n    } else {\n      // Ray and segment are parallel.\n\n      s1 = a01 > 0 ? -segExtent : segExtent;\n      s0 = Math.max(0, -(a01 * s1 + b0));\n      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n    }\n    if (optionalPointOnRay) {\n      optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);\n    }\n    if (optionalPointOnSegment) {\n      optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);\n    }\n    return sqrDist;\n  }\n  intersectSphere(sphere, target) {\n    _vector.subVectors(sphere.center, this.origin);\n    const tca = _vector.dot(this.direction);\n    const d2 = _vector.dot(_vector) - tca * tca;\n    const radius2 = sphere.radius * sphere.radius;\n    if (d2 > radius2) return null;\n    const thc = Math.sqrt(radius2 - d2);\n\n    // t0 = first intersect point - entrance on front of sphere\n    const t0 = tca - thc;\n\n    // t1 = second intersect point - exit point on back of sphere\n    const t1 = tca + thc;\n\n    // test to see if both t0 and t1 are behind the ray - if so, return null\n    if (t0 < 0 && t1 < 0) return null;\n\n    // test to see if t0 is behind the ray:\n    // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n    // in order to always return an intersect point that is in front of the ray.\n    if (t0 < 0) return this.at(t1, target);\n\n    // else t0 is in front of the ray, so return the first collision point scaled by t0\n    return this.at(t0, target);\n  }\n  intersectsSphere(sphere) {\n    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;\n  }\n  distanceToPlane(plane) {\n    const denominator = plane.normal.dot(this.direction);\n    if (denominator === 0) {\n      // line is coplanar, return origin\n      if (plane.distanceToPoint(this.origin) === 0) {\n        return 0;\n      }\n\n      // Null is preferable to undefined since undefined means.... it is undefined\n\n      return null;\n    }\n    const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;\n\n    // Return if the ray never intersects the plane\n\n    return t >= 0 ? t : null;\n  }\n  intersectPlane(plane, target) {\n    const t = this.distanceToPlane(plane);\n    if (t === null) {\n      return null;\n    }\n    return this.at(t, target);\n  }\n  intersectsPlane(plane) {\n    // check if the ray lies on the plane first\n\n    const distToPoint = plane.distanceToPoint(this.origin);\n    if (distToPoint === 0) {\n      return true;\n    }\n    const denominator = plane.normal.dot(this.direction);\n    if (denominator * distToPoint < 0) {\n      return true;\n    }\n\n    // ray origin is behind the plane (and is pointing behind it)\n\n    return false;\n  }\n  intersectBox(box, target) {\n    let tmin, tmax, tymin, tymax, tzmin, tzmax;\n    const invdirx = 1 / this.direction.x,\n      invdiry = 1 / this.direction.y,\n      invdirz = 1 / this.direction.z;\n    const origin = this.origin;\n    if (invdirx >= 0) {\n      tmin = (box.min.x - origin.x) * invdirx;\n      tmax = (box.max.x - origin.x) * invdirx;\n    } else {\n      tmin = (box.max.x - origin.x) * invdirx;\n      tmax = (box.min.x - origin.x) * invdirx;\n    }\n    if (invdiry >= 0) {\n      tymin = (box.min.y - origin.y) * invdiry;\n      tymax = (box.max.y - origin.y) * invdiry;\n    } else {\n      tymin = (box.max.y - origin.y) * invdiry;\n      tymax = (box.min.y - origin.y) * invdiry;\n    }\n    if (tmin > tymax || tymin > tmax) return null;\n    if (tymin > tmin || isNaN(tmin)) tmin = tymin;\n    if (tymax < tmax || isNaN(tmax)) tmax = tymax;\n    if (invdirz >= 0) {\n      tzmin = (box.min.z - origin.z) * invdirz;\n      tzmax = (box.max.z - origin.z) * invdirz;\n    } else {\n      tzmin = (box.max.z - origin.z) * invdirz;\n      tzmax = (box.min.z - origin.z) * invdirz;\n    }\n    if (tmin > tzmax || tzmin > tmax) return null;\n    if (tzmin > tmin || tmin !== tmin) tmin = tzmin;\n    if (tzmax < tmax || tmax !== tmax) tmax = tzmax;\n\n    //return point closest to the ray (positive side)\n\n    if (tmax < 0) return null;\n    return this.at(tmin >= 0 ? tmin : tmax, target);\n  }\n  intersectsBox(box) {\n    return this.intersectBox(box, _vector) !== null;\n  }\n  intersectTriangle(a, b, c, backfaceCulling, target) {\n    // Compute the offset origin, edges, and normal.\n\n    // from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\n    _edge1.subVectors(b, a);\n    _edge2.subVectors(c, a);\n    _normal.crossVectors(_edge1, _edge2);\n\n    // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n    // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n    //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n    //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n    //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n    let DdN = this.direction.dot(_normal);\n    let sign;\n    if (DdN > 0) {\n      if (backfaceCulling) return null;\n      sign = 1;\n    } else if (DdN < 0) {\n      sign = -1;\n      DdN = -DdN;\n    } else {\n      return null;\n    }\n    _diff.subVectors(this.origin, a);\n    const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));\n\n    // b1 < 0, no intersection\n    if (DdQxE2 < 0) {\n      return null;\n    }\n    const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));\n\n    // b2 < 0, no intersection\n    if (DdE1xQ < 0) {\n      return null;\n    }\n\n    // b1+b2 > 1, no intersection\n    if (DdQxE2 + DdE1xQ > DdN) {\n      return null;\n    }\n\n    // Line intersects triangle, check if ray does.\n    const QdN = -sign * _diff.dot(_normal);\n\n    // t < 0, no intersection\n    if (QdN < 0) {\n      return null;\n    }\n\n    // Ray intersects triangle.\n    return this.at(QdN / DdN, target);\n  }\n  applyMatrix4(matrix4) {\n    this.origin.applyMatrix4(matrix4);\n    this.direction.transformDirection(matrix4);\n    return this;\n  }\n  equals(ray) {\n    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n}\nexport { Ray };","map":{"version":3,"names":["Vector3","_vector","_segCenter","_segDir","_diff","_edge1","_edge2","_normal","Ray","constructor","origin","direction","set","copy","ray","at","t","target","multiplyScalar","add","lookAt","v","sub","normalize","recast","closestPointToPoint","point","subVectors","directionDistance","dot","distanceToPoint","Math","sqrt","distanceSqToPoint","distanceToSquared","distanceSqToSegment","v0","v1","optionalPointOnRay","optionalPointOnSegment","segExtent","distanceTo","a01","b0","b1","c","lengthSq","det","abs","s0","s1","sqrDist","extDet","invDet","max","min","intersectSphere","sphere","center","tca","d2","radius2","radius","thc","t0","t1","intersectsSphere","distanceToPlane","plane","denominator","normal","constant","intersectPlane","intersectsPlane","distToPoint","intersectBox","box","tmin","tmax","tymin","tymax","tzmin","tzmax","invdirx","x","invdiry","y","invdirz","z","isNaN","intersectsBox","intersectTriangle","a","b","backfaceCulling","crossVectors","DdN","sign","DdQxE2","DdE1xQ","cross","QdN","applyMatrix4","matrix4","transformDirection","equals","clone"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/math/Ray.js"],"sourcesContent":["import { Vector3 } from './Vector3.js';\n\nconst _vector = /*@__PURE__*/ new Vector3();\nconst _segCenter = /*@__PURE__*/ new Vector3();\nconst _segDir = /*@__PURE__*/ new Vector3();\nconst _diff = /*@__PURE__*/ new Vector3();\n\nconst _edge1 = /*@__PURE__*/ new Vector3();\nconst _edge2 = /*@__PURE__*/ new Vector3();\nconst _normal = /*@__PURE__*/ new Vector3();\n\nclass Ray {\n\n\tconstructor( origin = new Vector3(), direction = new Vector3( 0, 0, - 1 ) ) {\n\n\t\tthis.origin = origin;\n\t\tthis.direction = direction;\n\n\t}\n\n\tset( origin, direction ) {\n\n\t\tthis.origin.copy( origin );\n\t\tthis.direction.copy( direction );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( ray ) {\n\n\t\tthis.origin.copy( ray.origin );\n\t\tthis.direction.copy( ray.direction );\n\n\t\treturn this;\n\n\t}\n\n\tat( t, target ) {\n\n\t\treturn target.copy( this.direction ).multiplyScalar( t ).add( this.origin );\n\n\t}\n\n\tlookAt( v ) {\n\n\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\n\n\t\treturn this;\n\n\t}\n\n\trecast( t ) {\n\n\t\tthis.origin.copy( this.at( t, _vector ) );\n\n\t\treturn this;\n\n\t}\n\n\tclosestPointToPoint( point, target ) {\n\n\t\ttarget.subVectors( point, this.origin );\n\n\t\tconst directionDistance = target.dot( this.direction );\n\n\t\tif ( directionDistance < 0 ) {\n\n\t\t\treturn target.copy( this.origin );\n\n\t\t}\n\n\t\treturn target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\n\n\t}\n\n\tdistanceSqToPoint( point ) {\n\n\t\tconst directionDistance = _vector.subVectors( point, this.origin ).dot( this.direction );\n\n\t\t// point behind the ray\n\n\t\tif ( directionDistance < 0 ) {\n\n\t\t\treturn this.origin.distanceToSquared( point );\n\n\t\t}\n\n\t\t_vector.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t\treturn _vector.distanceToSquared( point );\n\n\t}\n\n\tdistanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\n\t\t// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t// It returns the min distance between the ray and the segment\n\t\t// defined by v0 and v1\n\t\t// It can also set two optional targets :\n\t\t// - The closest point on the ray\n\t\t// - The closest point on the segment\n\n\t\t_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\n\t\t_segDir.copy( v1 ).sub( v0 ).normalize();\n\t\t_diff.copy( this.origin ).sub( _segCenter );\n\n\t\tconst segExtent = v0.distanceTo( v1 ) * 0.5;\n\t\tconst a01 = - this.direction.dot( _segDir );\n\t\tconst b0 = _diff.dot( this.direction );\n\t\tconst b1 = - _diff.dot( _segDir );\n\t\tconst c = _diff.lengthSq();\n\t\tconst det = Math.abs( 1 - a01 * a01 );\n\t\tlet s0, s1, sqrDist, extDet;\n\n\t\tif ( det > 0 ) {\n\n\t\t\t// The ray and segment are not parallel.\n\n\t\t\ts0 = a01 * b1 - b0;\n\t\t\ts1 = a01 * b0 - b1;\n\t\t\textDet = segExtent * det;\n\n\t\t\tif ( s0 >= 0 ) {\n\n\t\t\t\tif ( s1 >= - extDet ) {\n\n\t\t\t\t\tif ( s1 <= extDet ) {\n\n\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\n\t\t\t\t\t\tconst invDet = 1 / det;\n\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// region 1\n\n\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// region 5\n\n\t\t\t\t\ts1 = - segExtent;\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( s1 <= - extDet ) {\n\n\t\t\t\t\t// region 4\n\n\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t} else if ( s1 <= extDet ) {\n\n\t\t\t\t\t// region 3\n\n\t\t\t\t\ts0 = 0;\n\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// region 2\n\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// Ray and segment are parallel.\n\n\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\n\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t}\n\n\t\tif ( optionalPointOnRay ) {\n\n\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\n\n\t\t}\n\n\t\tif ( optionalPointOnSegment ) {\n\n\t\t\toptionalPointOnSegment.copy( _segDir ).multiplyScalar( s1 ).add( _segCenter );\n\n\t\t}\n\n\t\treturn sqrDist;\n\n\t}\n\n\tintersectSphere( sphere, target ) {\n\n\t\t_vector.subVectors( sphere.center, this.origin );\n\t\tconst tca = _vector.dot( this.direction );\n\t\tconst d2 = _vector.dot( _vector ) - tca * tca;\n\t\tconst radius2 = sphere.radius * sphere.radius;\n\n\t\tif ( d2 > radius2 ) return null;\n\n\t\tconst thc = Math.sqrt( radius2 - d2 );\n\n\t\t// t0 = first intersect point - entrance on front of sphere\n\t\tconst t0 = tca - thc;\n\n\t\t// t1 = second intersect point - exit point on back of sphere\n\t\tconst t1 = tca + thc;\n\n\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\n\t\tif ( t0 < 0 && t1 < 0 ) return null;\n\n\t\t// test to see if t0 is behind the ray:\n\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t// in order to always return an intersect point that is in front of the ray.\n\t\tif ( t0 < 0 ) return this.at( t1, target );\n\n\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\n\t\treturn this.at( t0, target );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t}\n\n\tdistanceToPlane( plane ) {\n\n\t\tconst denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator === 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\n\t\t// Return if the ray never intersects the plane\n\n\t\treturn t >= 0 ? t : null;\n\n\t}\n\n\tintersectPlane( plane, target ) {\n\n\t\tconst t = this.distanceToPlane( plane );\n\n\t\tif ( t === null ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn this.at( t, target );\n\n\t}\n\n\tintersectsPlane( plane ) {\n\n\t\t// check if the ray lies on the plane first\n\n\t\tconst distToPoint = plane.distanceToPoint( this.origin );\n\n\t\tif ( distToPoint === 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tconst denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator * distToPoint < 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\t// ray origin is behind the plane (and is pointing behind it)\n\n\t\treturn false;\n\n\t}\n\n\tintersectBox( box, target ) {\n\n\t\tlet tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\t\tconst invdirx = 1 / this.direction.x,\n\t\t\tinvdiry = 1 / this.direction.y,\n\t\t\tinvdirz = 1 / this.direction.z;\n\n\t\tconst origin = this.origin;\n\n\t\tif ( invdirx >= 0 ) {\n\n\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\n\n\t\t} else {\n\n\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\n\n\t\t}\n\n\t\tif ( invdiry >= 0 ) {\n\n\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\n\n\t\t} else {\n\n\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\n\n\t\t}\n\n\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\n\n\t\tif ( tymin > tmin || isNaN( tmin ) ) tmin = tymin;\n\n\t\tif ( tymax < tmax || isNaN( tmax ) ) tmax = tymax;\n\n\t\tif ( invdirz >= 0 ) {\n\n\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\n\n\t\t} else {\n\n\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\n\n\t\t}\n\n\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\n\n\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t\t//return point closest to the ray (positive side)\n\n\t\tif ( tmax < 0 ) return null;\n\n\t\treturn this.at( tmin >= 0 ? tmin : tmax, target );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn this.intersectBox( box, _vector ) !== null;\n\n\t}\n\n\tintersectTriangle( a, b, c, backfaceCulling, target ) {\n\n\t\t// Compute the offset origin, edges, and normal.\n\n\t\t// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\n\t\t_edge1.subVectors( b, a );\n\t\t_edge2.subVectors( c, a );\n\t\t_normal.crossVectors( _edge1, _edge2 );\n\n\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\tlet DdN = this.direction.dot( _normal );\n\t\tlet sign;\n\n\t\tif ( DdN > 0 ) {\n\n\t\t\tif ( backfaceCulling ) return null;\n\t\t\tsign = 1;\n\n\t\t} else if ( DdN < 0 ) {\n\n\t\t\tsign = - 1;\n\t\t\tDdN = - DdN;\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t_diff.subVectors( this.origin, a );\n\t\tconst DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );\n\n\t\t// b1 < 0, no intersection\n\t\tif ( DdQxE2 < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );\n\n\t\t// b2 < 0, no intersection\n\t\tif ( DdE1xQ < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// b1+b2 > 1, no intersection\n\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// Line intersects triangle, check if ray does.\n\t\tconst QdN = - sign * _diff.dot( _normal );\n\n\t\t// t < 0, no intersection\n\t\tif ( QdN < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// Ray intersects triangle.\n\t\treturn this.at( QdN / DdN, target );\n\n\t}\n\n\tapplyMatrix4( matrix4 ) {\n\n\t\tthis.origin.applyMatrix4( matrix4 );\n\t\tthis.direction.transformDirection( matrix4 );\n\n\t\treturn this;\n\n\t}\n\n\tequals( ray ) {\n\n\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nexport { Ray };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}