{"ast":null,"code":"import { Matrix3 } from './Matrix3.js';\nimport { Vector3 } from './Vector3.js';\nconst _vector1 = /*@__PURE__*/new Vector3();\nconst _vector2 = /*@__PURE__*/new Vector3();\nconst _normalMatrix = /*@__PURE__*/new Matrix3();\nclass Plane {\n  constructor() {\n    let normal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3(1, 0, 0);\n    let constant = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this.isPlane = true;\n\n    // normal is assumed to be normalized\n\n    this.normal = normal;\n    this.constant = constant;\n  }\n  set(normal, constant) {\n    this.normal.copy(normal);\n    this.constant = constant;\n    return this;\n  }\n  setComponents(x, y, z, w) {\n    this.normal.set(x, y, z);\n    this.constant = w;\n    return this;\n  }\n  setFromNormalAndCoplanarPoint(normal, point) {\n    this.normal.copy(normal);\n    this.constant = -point.dot(this.normal);\n    return this;\n  }\n  setFromCoplanarPoints(a, b, c) {\n    const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();\n\n    // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n    this.setFromNormalAndCoplanarPoint(normal, a);\n    return this;\n  }\n  copy(plane) {\n    this.normal.copy(plane.normal);\n    this.constant = plane.constant;\n    return this;\n  }\n  normalize() {\n    // Note: will lead to a divide by zero if the plane is invalid.\n\n    const inverseNormalLength = 1.0 / this.normal.length();\n    this.normal.multiplyScalar(inverseNormalLength);\n    this.constant *= inverseNormalLength;\n    return this;\n  }\n  negate() {\n    this.constant *= -1;\n    this.normal.negate();\n    return this;\n  }\n  distanceToPoint(point) {\n    return this.normal.dot(point) + this.constant;\n  }\n  distanceToSphere(sphere) {\n    return this.distanceToPoint(sphere.center) - sphere.radius;\n  }\n  projectPoint(point, target) {\n    return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);\n  }\n  intersectLine(line, target) {\n    const direction = line.delta(_vector1);\n    const denominator = this.normal.dot(direction);\n    if (denominator === 0) {\n      // line is coplanar, return origin\n      if (this.distanceToPoint(line.start) === 0) {\n        return target.copy(line.start);\n      }\n\n      // Unsure if this is the correct method to handle this case.\n      return null;\n    }\n    const t = -(line.start.dot(this.normal) + this.constant) / denominator;\n    if (t < 0 || t > 1) {\n      return null;\n    }\n    return target.copy(direction).multiplyScalar(t).add(line.start);\n  }\n  intersectsLine(line) {\n    // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n    const startSign = this.distanceToPoint(line.start);\n    const endSign = this.distanceToPoint(line.end);\n    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;\n  }\n  intersectsBox(box) {\n    return box.intersectsPlane(this);\n  }\n  intersectsSphere(sphere) {\n    return sphere.intersectsPlane(this);\n  }\n  coplanarPoint(target) {\n    return target.copy(this.normal).multiplyScalar(-this.constant);\n  }\n  applyMatrix4(matrix, optionalNormalMatrix) {\n    const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);\n    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);\n    const normal = this.normal.applyMatrix3(normalMatrix).normalize();\n    this.constant = -referencePoint.dot(normal);\n    return this;\n  }\n  translate(offset) {\n    this.constant -= offset.dot(this.normal);\n    return this;\n  }\n  equals(plane) {\n    return plane.normal.equals(this.normal) && plane.constant === this.constant;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n}\nexport { Plane };","map":{"version":3,"names":["Matrix3","Vector3","_vector1","_vector2","_normalMatrix","Plane","constructor","normal","constant","isPlane","set","copy","setComponents","x","y","z","w","setFromNormalAndCoplanarPoint","point","dot","setFromCoplanarPoints","a","b","c","subVectors","cross","normalize","plane","inverseNormalLength","length","multiplyScalar","negate","distanceToPoint","distanceToSphere","sphere","center","radius","projectPoint","target","add","intersectLine","line","direction","delta","denominator","start","t","intersectsLine","startSign","endSign","end","intersectsBox","box","intersectsPlane","intersectsSphere","coplanarPoint","applyMatrix4","matrix","optionalNormalMatrix","normalMatrix","getNormalMatrix","referencePoint","applyMatrix3","translate","offset","equals","clone"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/math/Plane.js"],"sourcesContent":["import { Matrix3 } from './Matrix3.js';\nimport { Vector3 } from './Vector3.js';\n\nconst _vector1 = /*@__PURE__*/ new Vector3();\nconst _vector2 = /*@__PURE__*/ new Vector3();\nconst _normalMatrix = /*@__PURE__*/ new Matrix3();\n\nclass Plane {\n\n\tconstructor( normal = new Vector3( 1, 0, 0 ), constant = 0 ) {\n\n\t\tthis.isPlane = true;\n\n\t\t// normal is assumed to be normalized\n\n\t\tthis.normal = normal;\n\t\tthis.constant = constant;\n\n\t}\n\n\tset( normal, constant ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = constant;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponents( x, y, z, w ) {\n\n\t\tthis.normal.set( x, y, z );\n\t\tthis.constant = w;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromNormalAndCoplanarPoint( normal, point ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = - point.dot( this.normal );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCoplanarPoints( a, b, c ) {\n\n\t\tconst normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();\n\n\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( plane ) {\n\n\t\tthis.normal.copy( plane.normal );\n\t\tthis.constant = plane.constant;\n\n\t\treturn this;\n\n\t}\n\n\tnormalize() {\n\n\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\n\t\tconst inverseNormalLength = 1.0 / this.normal.length();\n\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\tthis.constant *= inverseNormalLength;\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.constant *= - 1;\n\t\tthis.normal.negate();\n\n\t\treturn this;\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn this.normal.dot( point ) + this.constant;\n\n\t}\n\n\tdistanceToSphere( sphere ) {\n\n\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\n\t}\n\n\tprojectPoint( point, target ) {\n\n\t\treturn target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );\n\n\t}\n\n\tintersectLine( line, target ) {\n\n\t\tconst direction = line.delta( _vector1 );\n\n\t\tconst denominator = this.normal.dot( direction );\n\n\t\tif ( denominator === 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\n\n\t\t\t\treturn target.copy( line.start );\n\n\t\t\t}\n\n\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\n\t\tif ( t < 0 || t > 1 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn target.copy( direction ).multiplyScalar( t ).add( line.start );\n\n\t}\n\n\tintersectsLine( line ) {\n\n\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n\t\tconst startSign = this.distanceToPoint( line.start );\n\t\tconst endSign = this.distanceToPoint( line.end );\n\n\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn box.intersectsPlane( this );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn sphere.intersectsPlane( this );\n\n\t}\n\n\tcoplanarPoint( target ) {\n\n\t\treturn target.copy( this.normal ).multiplyScalar( - this.constant );\n\n\t}\n\n\tapplyMatrix4( matrix, optionalNormalMatrix ) {\n\n\t\tconst normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );\n\n\t\tconst referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );\n\n\t\tconst normal = this.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\tthis.constant = - referencePoint.dot( normal );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.constant -= offset.dot( this.normal );\n\n\t\treturn this;\n\n\t}\n\n\tequals( plane ) {\n\n\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nexport { Plane };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}