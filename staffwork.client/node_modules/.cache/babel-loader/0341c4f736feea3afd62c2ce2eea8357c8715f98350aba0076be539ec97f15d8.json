{"ast":null,"code":"function WebGLBindingStates(gl, extensions, attributes, capabilities) {\n  const maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);\n  const extension = capabilities.isWebGL2 ? null : extensions.get('OES_vertex_array_object');\n  const vaoAvailable = capabilities.isWebGL2 || extension !== null;\n  const bindingStates = {};\n  const defaultState = createBindingState(null);\n  let currentState = defaultState;\n  let forceUpdate = false;\n  function setup(object, material, program, geometry, index) {\n    let updateBuffers = false;\n    if (vaoAvailable) {\n      const state = getBindingState(geometry, program, material);\n      if (currentState !== state) {\n        currentState = state;\n        bindVertexArrayObject(currentState.object);\n      }\n      updateBuffers = needsUpdate(object, geometry, program, index);\n      if (updateBuffers) saveCache(object, geometry, program, index);\n    } else {\n      const wireframe = material.wireframe === true;\n      if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {\n        currentState.geometry = geometry.id;\n        currentState.program = program.id;\n        currentState.wireframe = wireframe;\n        updateBuffers = true;\n      }\n    }\n    if (index !== null) {\n      attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);\n    }\n    if (updateBuffers || forceUpdate) {\n      forceUpdate = false;\n      setupVertexAttributes(object, material, program, geometry);\n      if (index !== null) {\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);\n      }\n    }\n  }\n  function createVertexArrayObject() {\n    if (capabilities.isWebGL2) return gl.createVertexArray();\n    return extension.createVertexArrayOES();\n  }\n  function bindVertexArrayObject(vao) {\n    if (capabilities.isWebGL2) return gl.bindVertexArray(vao);\n    return extension.bindVertexArrayOES(vao);\n  }\n  function deleteVertexArrayObject(vao) {\n    if (capabilities.isWebGL2) return gl.deleteVertexArray(vao);\n    return extension.deleteVertexArrayOES(vao);\n  }\n  function getBindingState(geometry, program, material) {\n    const wireframe = material.wireframe === true;\n    let programMap = bindingStates[geometry.id];\n    if (programMap === undefined) {\n      programMap = {};\n      bindingStates[geometry.id] = programMap;\n    }\n    let stateMap = programMap[program.id];\n    if (stateMap === undefined) {\n      stateMap = {};\n      programMap[program.id] = stateMap;\n    }\n    let state = stateMap[wireframe];\n    if (state === undefined) {\n      state = createBindingState(createVertexArrayObject());\n      stateMap[wireframe] = state;\n    }\n    return state;\n  }\n  function createBindingState(vao) {\n    const newAttributes = [];\n    const enabledAttributes = [];\n    const attributeDivisors = [];\n    for (let i = 0; i < maxVertexAttributes; i++) {\n      newAttributes[i] = 0;\n      enabledAttributes[i] = 0;\n      attributeDivisors[i] = 0;\n    }\n    return {\n      // for backward compatibility on non-VAO support browser\n      geometry: null,\n      program: null,\n      wireframe: false,\n      newAttributes: newAttributes,\n      enabledAttributes: enabledAttributes,\n      attributeDivisors: attributeDivisors,\n      object: vao,\n      attributes: {},\n      index: null\n    };\n  }\n  function needsUpdate(object, geometry, program, index) {\n    const cachedAttributes = currentState.attributes;\n    const geometryAttributes = geometry.attributes;\n    let attributesNum = 0;\n    const programAttributes = program.getAttributes();\n    for (const name in programAttributes) {\n      const programAttribute = programAttributes[name];\n      if (programAttribute.location >= 0) {\n        const cachedAttribute = cachedAttributes[name];\n        let geometryAttribute = geometryAttributes[name];\n        if (geometryAttribute === undefined) {\n          if (name === 'instanceMatrix' && object.instanceMatrix) geometryAttribute = object.instanceMatrix;\n          if (name === 'instanceColor' && object.instanceColor) geometryAttribute = object.instanceColor;\n        }\n        if (cachedAttribute === undefined) return true;\n        if (cachedAttribute.attribute !== geometryAttribute) return true;\n        if (geometryAttribute && cachedAttribute.data !== geometryAttribute.data) return true;\n        attributesNum++;\n      }\n    }\n    if (currentState.attributesNum !== attributesNum) return true;\n    if (currentState.index !== index) return true;\n    return false;\n  }\n  function saveCache(object, geometry, program, index) {\n    const cache = {};\n    const attributes = geometry.attributes;\n    let attributesNum = 0;\n    const programAttributes = program.getAttributes();\n    for (const name in programAttributes) {\n      const programAttribute = programAttributes[name];\n      if (programAttribute.location >= 0) {\n        let attribute = attributes[name];\n        if (attribute === undefined) {\n          if (name === 'instanceMatrix' && object.instanceMatrix) attribute = object.instanceMatrix;\n          if (name === 'instanceColor' && object.instanceColor) attribute = object.instanceColor;\n        }\n        const data = {};\n        data.attribute = attribute;\n        if (attribute && attribute.data) {\n          data.data = attribute.data;\n        }\n        cache[name] = data;\n        attributesNum++;\n      }\n    }\n    currentState.attributes = cache;\n    currentState.attributesNum = attributesNum;\n    currentState.index = index;\n  }\n  function initAttributes() {\n    const newAttributes = currentState.newAttributes;\n    for (let i = 0, il = newAttributes.length; i < il; i++) {\n      newAttributes[i] = 0;\n    }\n  }\n  function enableAttribute(attribute) {\n    enableAttributeAndDivisor(attribute, 0);\n  }\n  function enableAttributeAndDivisor(attribute, meshPerAttribute) {\n    const newAttributes = currentState.newAttributes;\n    const enabledAttributes = currentState.enabledAttributes;\n    const attributeDivisors = currentState.attributeDivisors;\n    newAttributes[attribute] = 1;\n    if (enabledAttributes[attribute] === 0) {\n      gl.enableVertexAttribArray(attribute);\n      enabledAttributes[attribute] = 1;\n    }\n    if (attributeDivisors[attribute] !== meshPerAttribute) {\n      const extension = capabilities.isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');\n      extension[capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);\n      attributeDivisors[attribute] = meshPerAttribute;\n    }\n  }\n  function disableUnusedAttributes() {\n    const newAttributes = currentState.newAttributes;\n    const enabledAttributes = currentState.enabledAttributes;\n    for (let i = 0, il = enabledAttributes.length; i < il; i++) {\n      if (enabledAttributes[i] !== newAttributes[i]) {\n        gl.disableVertexAttribArray(i);\n        enabledAttributes[i] = 0;\n      }\n    }\n  }\n  function vertexAttribPointer(index, size, type, normalized, stride, offset) {\n    if (capabilities.isWebGL2 === true && (type === gl.INT || type === gl.UNSIGNED_INT)) {\n      gl.vertexAttribIPointer(index, size, type, stride, offset);\n    } else {\n      gl.vertexAttribPointer(index, size, type, normalized, stride, offset);\n    }\n  }\n  function setupVertexAttributes(object, material, program, geometry) {\n    if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {\n      if (extensions.get('ANGLE_instanced_arrays') === null) return;\n    }\n    initAttributes();\n    const geometryAttributes = geometry.attributes;\n    const programAttributes = program.getAttributes();\n    const materialDefaultAttributeValues = material.defaultAttributeValues;\n    for (const name in programAttributes) {\n      const programAttribute = programAttributes[name];\n      if (programAttribute.location >= 0) {\n        let geometryAttribute = geometryAttributes[name];\n        if (geometryAttribute === undefined) {\n          if (name === 'instanceMatrix' && object.instanceMatrix) geometryAttribute = object.instanceMatrix;\n          if (name === 'instanceColor' && object.instanceColor) geometryAttribute = object.instanceColor;\n        }\n        if (geometryAttribute !== undefined) {\n          const normalized = geometryAttribute.normalized;\n          const size = geometryAttribute.itemSize;\n          const attribute = attributes.get(geometryAttribute);\n\n          // TODO Attribute may not be available on context restore\n\n          if (attribute === undefined) continue;\n          const buffer = attribute.buffer;\n          const type = attribute.type;\n          const bytesPerElement = attribute.bytesPerElement;\n          if (geometryAttribute.isInterleavedBufferAttribute) {\n            const data = geometryAttribute.data;\n            const stride = data.stride;\n            const offset = geometryAttribute.offset;\n            if (data.isInstancedInterleavedBuffer) {\n              for (let i = 0; i < programAttribute.locationSize; i++) {\n                enableAttributeAndDivisor(programAttribute.location + i, data.meshPerAttribute);\n              }\n              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined) {\n                geometry._maxInstanceCount = data.meshPerAttribute * data.count;\n              }\n            } else {\n              for (let i = 0; i < programAttribute.locationSize; i++) {\n                enableAttribute(programAttribute.location + i);\n              }\n            }\n            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n            for (let i = 0; i < programAttribute.locationSize; i++) {\n              vertexAttribPointer(programAttribute.location + i, size / programAttribute.locationSize, type, normalized, stride * bytesPerElement, (offset + size / programAttribute.locationSize * i) * bytesPerElement);\n            }\n          } else {\n            if (geometryAttribute.isInstancedBufferAttribute) {\n              for (let i = 0; i < programAttribute.locationSize; i++) {\n                enableAttributeAndDivisor(programAttribute.location + i, geometryAttribute.meshPerAttribute);\n              }\n              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined) {\n                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n              }\n            } else {\n              for (let i = 0; i < programAttribute.locationSize; i++) {\n                enableAttribute(programAttribute.location + i);\n              }\n            }\n            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n            for (let i = 0; i < programAttribute.locationSize; i++) {\n              vertexAttribPointer(programAttribute.location + i, size / programAttribute.locationSize, type, normalized, size * bytesPerElement, size / programAttribute.locationSize * i * bytesPerElement);\n            }\n          }\n        } else if (materialDefaultAttributeValues !== undefined) {\n          const value = materialDefaultAttributeValues[name];\n          if (value !== undefined) {\n            switch (value.length) {\n              case 2:\n                gl.vertexAttrib2fv(programAttribute.location, value);\n                break;\n              case 3:\n                gl.vertexAttrib3fv(programAttribute.location, value);\n                break;\n              case 4:\n                gl.vertexAttrib4fv(programAttribute.location, value);\n                break;\n              default:\n                gl.vertexAttrib1fv(programAttribute.location, value);\n            }\n          }\n        }\n      }\n    }\n    disableUnusedAttributes();\n  }\n  function dispose() {\n    reset();\n    for (const geometryId in bindingStates) {\n      const programMap = bindingStates[geometryId];\n      for (const programId in programMap) {\n        const stateMap = programMap[programId];\n        for (const wireframe in stateMap) {\n          deleteVertexArrayObject(stateMap[wireframe].object);\n          delete stateMap[wireframe];\n        }\n        delete programMap[programId];\n      }\n      delete bindingStates[geometryId];\n    }\n  }\n  function releaseStatesOfGeometry(geometry) {\n    if (bindingStates[geometry.id] === undefined) return;\n    const programMap = bindingStates[geometry.id];\n    for (const programId in programMap) {\n      const stateMap = programMap[programId];\n      for (const wireframe in stateMap) {\n        deleteVertexArrayObject(stateMap[wireframe].object);\n        delete stateMap[wireframe];\n      }\n      delete programMap[programId];\n    }\n    delete bindingStates[geometry.id];\n  }\n  function releaseStatesOfProgram(program) {\n    for (const geometryId in bindingStates) {\n      const programMap = bindingStates[geometryId];\n      if (programMap[program.id] === undefined) continue;\n      const stateMap = programMap[program.id];\n      for (const wireframe in stateMap) {\n        deleteVertexArrayObject(stateMap[wireframe].object);\n        delete stateMap[wireframe];\n      }\n      delete programMap[program.id];\n    }\n  }\n  function reset() {\n    resetDefaultState();\n    forceUpdate = true;\n    if (currentState === defaultState) return;\n    currentState = defaultState;\n    bindVertexArrayObject(currentState.object);\n  }\n\n  // for backward-compatibility\n\n  function resetDefaultState() {\n    defaultState.geometry = null;\n    defaultState.program = null;\n    defaultState.wireframe = false;\n  }\n  return {\n    setup: setup,\n    reset: reset,\n    resetDefaultState: resetDefaultState,\n    dispose: dispose,\n    releaseStatesOfGeometry: releaseStatesOfGeometry,\n    releaseStatesOfProgram: releaseStatesOfProgram,\n    initAttributes: initAttributes,\n    enableAttribute: enableAttribute,\n    disableUnusedAttributes: disableUnusedAttributes\n  };\n}\nexport { WebGLBindingStates };","map":{"version":3,"names":["WebGLBindingStates","gl","extensions","attributes","capabilities","maxVertexAttributes","getParameter","MAX_VERTEX_ATTRIBS","extension","isWebGL2","get","vaoAvailable","bindingStates","defaultState","createBindingState","currentState","forceUpdate","setup","object","material","program","geometry","index","updateBuffers","state","getBindingState","bindVertexArrayObject","needsUpdate","saveCache","wireframe","id","update","ELEMENT_ARRAY_BUFFER","setupVertexAttributes","bindBuffer","buffer","createVertexArrayObject","createVertexArray","createVertexArrayOES","vao","bindVertexArray","bindVertexArrayOES","deleteVertexArrayObject","deleteVertexArray","deleteVertexArrayOES","programMap","undefined","stateMap","newAttributes","enabledAttributes","attributeDivisors","i","cachedAttributes","geometryAttributes","attributesNum","programAttributes","getAttributes","name","programAttribute","location","cachedAttribute","geometryAttribute","instanceMatrix","instanceColor","attribute","data","cache","initAttributes","il","length","enableAttribute","enableAttributeAndDivisor","meshPerAttribute","enableVertexAttribArray","disableUnusedAttributes","disableVertexAttribArray","vertexAttribPointer","size","type","normalized","stride","offset","INT","UNSIGNED_INT","vertexAttribIPointer","isInstancedMesh","isInstancedBufferGeometry","materialDefaultAttributeValues","defaultAttributeValues","itemSize","bytesPerElement","isInterleavedBufferAttribute","isInstancedInterleavedBuffer","locationSize","_maxInstanceCount","count","ARRAY_BUFFER","isInstancedBufferAttribute","value","vertexAttrib2fv","vertexAttrib3fv","vertexAttrib4fv","vertexAttrib1fv","dispose","reset","geometryId","programId","releaseStatesOfGeometry","releaseStatesOfProgram","resetDefaultState"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/renderers/webgl/WebGLBindingStates.js"],"sourcesContent":["function WebGLBindingStates( gl, extensions, attributes, capabilities ) {\n\n\tconst maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\n\tconst extension = capabilities.isWebGL2 ? null : extensions.get( 'OES_vertex_array_object' );\n\tconst vaoAvailable = capabilities.isWebGL2 || extension !== null;\n\n\tconst bindingStates = {};\n\n\tconst defaultState = createBindingState( null );\n\tlet currentState = defaultState;\n\tlet forceUpdate = false;\n\n\tfunction setup( object, material, program, geometry, index ) {\n\n\t\tlet updateBuffers = false;\n\n\t\tif ( vaoAvailable ) {\n\n\t\t\tconst state = getBindingState( geometry, program, material );\n\n\t\t\tif ( currentState !== state ) {\n\n\t\t\t\tcurrentState = state;\n\t\t\t\tbindVertexArrayObject( currentState.object );\n\n\t\t\t}\n\n\t\t\tupdateBuffers = needsUpdate( object, geometry, program, index );\n\n\t\t\tif ( updateBuffers ) saveCache( object, geometry, program, index );\n\n\t\t} else {\n\n\t\t\tconst wireframe = ( material.wireframe === true );\n\n\t\t\tif ( currentState.geometry !== geometry.id ||\n\t\t\t\tcurrentState.program !== program.id ||\n\t\t\t\tcurrentState.wireframe !== wireframe ) {\n\n\t\t\t\tcurrentState.geometry = geometry.id;\n\t\t\t\tcurrentState.program = program.id;\n\t\t\t\tcurrentState.wireframe = wireframe;\n\n\t\t\t\tupdateBuffers = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( index !== null ) {\n\n\t\t\tattributes.update( index, gl.ELEMENT_ARRAY_BUFFER );\n\n\t\t}\n\n\t\tif ( updateBuffers || forceUpdate ) {\n\n\t\t\tforceUpdate = false;\n\n\t\t\tsetupVertexAttributes( object, material, program, geometry );\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, attributes.get( index ).buffer );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction createVertexArrayObject() {\n\n\t\tif ( capabilities.isWebGL2 ) return gl.createVertexArray();\n\n\t\treturn extension.createVertexArrayOES();\n\n\t}\n\n\tfunction bindVertexArrayObject( vao ) {\n\n\t\tif ( capabilities.isWebGL2 ) return gl.bindVertexArray( vao );\n\n\t\treturn extension.bindVertexArrayOES( vao );\n\n\t}\n\n\tfunction deleteVertexArrayObject( vao ) {\n\n\t\tif ( capabilities.isWebGL2 ) return gl.deleteVertexArray( vao );\n\n\t\treturn extension.deleteVertexArrayOES( vao );\n\n\t}\n\n\tfunction getBindingState( geometry, program, material ) {\n\n\t\tconst wireframe = ( material.wireframe === true );\n\n\t\tlet programMap = bindingStates[ geometry.id ];\n\n\t\tif ( programMap === undefined ) {\n\n\t\t\tprogramMap = {};\n\t\t\tbindingStates[ geometry.id ] = programMap;\n\n\t\t}\n\n\t\tlet stateMap = programMap[ program.id ];\n\n\t\tif ( stateMap === undefined ) {\n\n\t\t\tstateMap = {};\n\t\t\tprogramMap[ program.id ] = stateMap;\n\n\t\t}\n\n\t\tlet state = stateMap[ wireframe ];\n\n\t\tif ( state === undefined ) {\n\n\t\t\tstate = createBindingState( createVertexArrayObject() );\n\t\t\tstateMap[ wireframe ] = state;\n\n\t\t}\n\n\t\treturn state;\n\n\t}\n\n\tfunction createBindingState( vao ) {\n\n\t\tconst newAttributes = [];\n\t\tconst enabledAttributes = [];\n\t\tconst attributeDivisors = [];\n\n\t\tfor ( let i = 0; i < maxVertexAttributes; i ++ ) {\n\n\t\t\tnewAttributes[ i ] = 0;\n\t\t\tenabledAttributes[ i ] = 0;\n\t\t\tattributeDivisors[ i ] = 0;\n\n\t\t}\n\n\t\treturn {\n\n\t\t\t// for backward compatibility on non-VAO support browser\n\t\t\tgeometry: null,\n\t\t\tprogram: null,\n\t\t\twireframe: false,\n\n\t\t\tnewAttributes: newAttributes,\n\t\t\tenabledAttributes: enabledAttributes,\n\t\t\tattributeDivisors: attributeDivisors,\n\t\t\tobject: vao,\n\t\t\tattributes: {},\n\t\t\tindex: null\n\n\t\t};\n\n\t}\n\n\tfunction needsUpdate( object, geometry, program, index ) {\n\n\t\tconst cachedAttributes = currentState.attributes;\n\t\tconst geometryAttributes = geometry.attributes;\n\n\t\tlet attributesNum = 0;\n\n\t\tconst programAttributes = program.getAttributes();\n\n\t\tfor ( const name in programAttributes ) {\n\n\t\t\tconst programAttribute = programAttributes[ name ];\n\n\t\t\tif ( programAttribute.location >= 0 ) {\n\n\t\t\t\tconst cachedAttribute = cachedAttributes[ name ];\n\t\t\t\tlet geometryAttribute = geometryAttributes[ name ];\n\n\t\t\t\tif ( geometryAttribute === undefined ) {\n\n\t\t\t\t\tif ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;\n\t\t\t\t\tif ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;\n\n\t\t\t\t}\n\n\t\t\t\tif ( cachedAttribute === undefined ) return true;\n\n\t\t\t\tif ( cachedAttribute.attribute !== geometryAttribute ) return true;\n\n\t\t\t\tif ( geometryAttribute && cachedAttribute.data !== geometryAttribute.data ) return true;\n\n\t\t\t\tattributesNum ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( currentState.attributesNum !== attributesNum ) return true;\n\n\t\tif ( currentState.index !== index ) return true;\n\n\t\treturn false;\n\n\t}\n\n\tfunction saveCache( object, geometry, program, index ) {\n\n\t\tconst cache = {};\n\t\tconst attributes = geometry.attributes;\n\t\tlet attributesNum = 0;\n\n\t\tconst programAttributes = program.getAttributes();\n\n\t\tfor ( const name in programAttributes ) {\n\n\t\t\tconst programAttribute = programAttributes[ name ];\n\n\t\t\tif ( programAttribute.location >= 0 ) {\n\n\t\t\t\tlet attribute = attributes[ name ];\n\n\t\t\t\tif ( attribute === undefined ) {\n\n\t\t\t\t\tif ( name === 'instanceMatrix' && object.instanceMatrix ) attribute = object.instanceMatrix;\n\t\t\t\t\tif ( name === 'instanceColor' && object.instanceColor ) attribute = object.instanceColor;\n\n\t\t\t\t}\n\n\t\t\t\tconst data = {};\n\t\t\t\tdata.attribute = attribute;\n\n\t\t\t\tif ( attribute && attribute.data ) {\n\n\t\t\t\t\tdata.data = attribute.data;\n\n\t\t\t\t}\n\n\t\t\t\tcache[ name ] = data;\n\n\t\t\t\tattributesNum ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tcurrentState.attributes = cache;\n\t\tcurrentState.attributesNum = attributesNum;\n\n\t\tcurrentState.index = index;\n\n\t}\n\n\tfunction initAttributes() {\n\n\t\tconst newAttributes = currentState.newAttributes;\n\n\t\tfor ( let i = 0, il = newAttributes.length; i < il; i ++ ) {\n\n\t\t\tnewAttributes[ i ] = 0;\n\n\t\t}\n\n\t}\n\n\tfunction enableAttribute( attribute ) {\n\n\t\tenableAttributeAndDivisor( attribute, 0 );\n\n\t}\n\n\tfunction enableAttributeAndDivisor( attribute, meshPerAttribute ) {\n\n\t\tconst newAttributes = currentState.newAttributes;\n\t\tconst enabledAttributes = currentState.enabledAttributes;\n\t\tconst attributeDivisors = currentState.attributeDivisors;\n\n\t\tnewAttributes[ attribute ] = 1;\n\n\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\n\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\tenabledAttributes[ attribute ] = 1;\n\n\t\t}\n\n\t\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\n\n\t\t\tconst extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\textension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );\n\t\t\tattributeDivisors[ attribute ] = meshPerAttribute;\n\n\t\t}\n\n\t}\n\n\tfunction disableUnusedAttributes() {\n\n\t\tconst newAttributes = currentState.newAttributes;\n\t\tconst enabledAttributes = currentState.enabledAttributes;\n\n\t\tfor ( let i = 0, il = enabledAttributes.length; i < il; i ++ ) {\n\n\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\n\n\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\tenabledAttributes[ i ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction vertexAttribPointer( index, size, type, normalized, stride, offset ) {\n\n\t\tif ( capabilities.isWebGL2 === true && ( type === gl.INT || type === gl.UNSIGNED_INT ) ) {\n\n\t\t\tgl.vertexAttribIPointer( index, size, type, stride, offset );\n\n\t\t} else {\n\n\t\t\tgl.vertexAttribPointer( index, size, type, normalized, stride, offset );\n\n\t\t}\n\n\t}\n\n\tfunction setupVertexAttributes( object, material, program, geometry ) {\n\n\t\tif ( capabilities.isWebGL2 === false && ( object.isInstancedMesh || geometry.isInstancedBufferGeometry ) ) {\n\n\t\t\tif ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) return;\n\n\t\t}\n\n\t\tinitAttributes();\n\n\t\tconst geometryAttributes = geometry.attributes;\n\n\t\tconst programAttributes = program.getAttributes();\n\n\t\tconst materialDefaultAttributeValues = material.defaultAttributeValues;\n\n\t\tfor ( const name in programAttributes ) {\n\n\t\t\tconst programAttribute = programAttributes[ name ];\n\n\t\t\tif ( programAttribute.location >= 0 ) {\n\n\t\t\t\tlet geometryAttribute = geometryAttributes[ name ];\n\n\t\t\t\tif ( geometryAttribute === undefined ) {\n\n\t\t\t\t\tif ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;\n\t\t\t\t\tif ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;\n\n\t\t\t\t}\n\n\t\t\t\tif ( geometryAttribute !== undefined ) {\n\n\t\t\t\t\tconst normalized = geometryAttribute.normalized;\n\t\t\t\t\tconst size = geometryAttribute.itemSize;\n\n\t\t\t\t\tconst attribute = attributes.get( geometryAttribute );\n\n\t\t\t\t\t// TODO Attribute may not be available on context restore\n\n\t\t\t\t\tif ( attribute === undefined ) continue;\n\n\t\t\t\t\tconst buffer = attribute.buffer;\n\t\t\t\t\tconst type = attribute.type;\n\t\t\t\t\tconst bytesPerElement = attribute.bytesPerElement;\n\n\t\t\t\t\tif ( geometryAttribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\t\tconst data = geometryAttribute.data;\n\t\t\t\t\t\tconst stride = data.stride;\n\t\t\t\t\t\tconst offset = geometryAttribute.offset;\n\n\t\t\t\t\t\tif ( data.isInstancedInterleavedBuffer ) {\n\n\t\t\t\t\t\t\tfor ( let i = 0; i < programAttribute.locationSize; i ++ ) {\n\n\t\t\t\t\t\t\t\tenableAttributeAndDivisor( programAttribute.location + i, data.meshPerAttribute );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {\n\n\t\t\t\t\t\t\t\tgeometry._maxInstanceCount = data.meshPerAttribute * data.count;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( let i = 0; i < programAttribute.locationSize; i ++ ) {\n\n\t\t\t\t\t\t\t\tenableAttribute( programAttribute.location + i );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, buffer );\n\n\t\t\t\t\t\tfor ( let i = 0; i < programAttribute.locationSize; i ++ ) {\n\n\t\t\t\t\t\t\tvertexAttribPointer(\n\t\t\t\t\t\t\t\tprogramAttribute.location + i,\n\t\t\t\t\t\t\t\tsize / programAttribute.locationSize,\n\t\t\t\t\t\t\t\ttype,\n\t\t\t\t\t\t\t\tnormalized,\n\t\t\t\t\t\t\t\tstride * bytesPerElement,\n\t\t\t\t\t\t\t\t( offset + ( size / programAttribute.locationSize ) * i ) * bytesPerElement\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( geometryAttribute.isInstancedBufferAttribute ) {\n\n\t\t\t\t\t\t\tfor ( let i = 0; i < programAttribute.locationSize; i ++ ) {\n\n\t\t\t\t\t\t\t\tenableAttributeAndDivisor( programAttribute.location + i, geometryAttribute.meshPerAttribute );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {\n\n\t\t\t\t\t\t\t\tgeometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( let i = 0; i < programAttribute.locationSize; i ++ ) {\n\n\t\t\t\t\t\t\t\tenableAttribute( programAttribute.location + i );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, buffer );\n\n\t\t\t\t\t\tfor ( let i = 0; i < programAttribute.locationSize; i ++ ) {\n\n\t\t\t\t\t\t\tvertexAttribPointer(\n\t\t\t\t\t\t\t\tprogramAttribute.location + i,\n\t\t\t\t\t\t\t\tsize / programAttribute.locationSize,\n\t\t\t\t\t\t\t\ttype,\n\t\t\t\t\t\t\t\tnormalized,\n\t\t\t\t\t\t\t\tsize * bytesPerElement,\n\t\t\t\t\t\t\t\t( size / programAttribute.locationSize ) * i * bytesPerElement\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( materialDefaultAttributeValues !== undefined ) {\n\n\t\t\t\t\tconst value = materialDefaultAttributeValues[ name ];\n\n\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\tswitch ( value.length ) {\n\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\tgl.vertexAttrib2fv( programAttribute.location, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\tgl.vertexAttrib3fv( programAttribute.location, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\tgl.vertexAttrib4fv( programAttribute.location, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tgl.vertexAttrib1fv( programAttribute.location, value );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tdisableUnusedAttributes();\n\n\t}\n\n\tfunction dispose() {\n\n\t\treset();\n\n\t\tfor ( const geometryId in bindingStates ) {\n\n\t\t\tconst programMap = bindingStates[ geometryId ];\n\n\t\t\tfor ( const programId in programMap ) {\n\n\t\t\t\tconst stateMap = programMap[ programId ];\n\n\t\t\t\tfor ( const wireframe in stateMap ) {\n\n\t\t\t\t\tdeleteVertexArrayObject( stateMap[ wireframe ].object );\n\n\t\t\t\t\tdelete stateMap[ wireframe ];\n\n\t\t\t\t}\n\n\t\t\t\tdelete programMap[ programId ];\n\n\t\t\t}\n\n\t\t\tdelete bindingStates[ geometryId ];\n\n\t\t}\n\n\t}\n\n\tfunction releaseStatesOfGeometry( geometry ) {\n\n\t\tif ( bindingStates[ geometry.id ] === undefined ) return;\n\n\t\tconst programMap = bindingStates[ geometry.id ];\n\n\t\tfor ( const programId in programMap ) {\n\n\t\t\tconst stateMap = programMap[ programId ];\n\n\t\t\tfor ( const wireframe in stateMap ) {\n\n\t\t\t\tdeleteVertexArrayObject( stateMap[ wireframe ].object );\n\n\t\t\t\tdelete stateMap[ wireframe ];\n\n\t\t\t}\n\n\t\t\tdelete programMap[ programId ];\n\n\t\t}\n\n\t\tdelete bindingStates[ geometry.id ];\n\n\t}\n\n\tfunction releaseStatesOfProgram( program ) {\n\n\t\tfor ( const geometryId in bindingStates ) {\n\n\t\t\tconst programMap = bindingStates[ geometryId ];\n\n\t\t\tif ( programMap[ program.id ] === undefined ) continue;\n\n\t\t\tconst stateMap = programMap[ program.id ];\n\n\t\t\tfor ( const wireframe in stateMap ) {\n\n\t\t\t\tdeleteVertexArrayObject( stateMap[ wireframe ].object );\n\n\t\t\t\tdelete stateMap[ wireframe ];\n\n\t\t\t}\n\n\t\t\tdelete programMap[ program.id ];\n\n\t\t}\n\n\t}\n\n\tfunction reset() {\n\n\t\tresetDefaultState();\n\t\tforceUpdate = true;\n\n\t\tif ( currentState === defaultState ) return;\n\n\t\tcurrentState = defaultState;\n\t\tbindVertexArrayObject( currentState.object );\n\n\t}\n\n\t// for backward-compatibility\n\n\tfunction resetDefaultState() {\n\n\t\tdefaultState.geometry = null;\n\t\tdefaultState.program = null;\n\t\tdefaultState.wireframe = false;\n\n\t}\n\n\treturn {\n\n\t\tsetup: setup,\n\t\treset: reset,\n\t\tresetDefaultState: resetDefaultState,\n\t\tdispose: dispose,\n\t\treleaseStatesOfGeometry: releaseStatesOfGeometry,\n\t\treleaseStatesOfProgram: releaseStatesOfProgram,\n\n\t\tinitAttributes: initAttributes,\n\t\tenableAttribute: enableAttribute,\n\t\tdisableUnusedAttributes: disableUnusedAttributes\n\n\t};\n\n}\n\n\nexport { WebGLBindingStates };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}