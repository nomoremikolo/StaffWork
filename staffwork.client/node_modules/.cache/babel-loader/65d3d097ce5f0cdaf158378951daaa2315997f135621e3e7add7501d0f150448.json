{"ast":null,"code":"import { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport * as MathUtils from '../math/MathUtils.js';\nclass LatheGeometry extends BufferGeometry {\n  constructor() {\n    let points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [new Vector2(0, -0.5), new Vector2(0.5, 0), new Vector2(0, 0.5)];\n    let segments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 12;\n    let phiStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let phiLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Math.PI * 2;\n    super();\n    this.type = 'LatheGeometry';\n    this.parameters = {\n      points: points,\n      segments: segments,\n      phiStart: phiStart,\n      phiLength: phiLength\n    };\n    segments = Math.floor(segments);\n\n    // clamp phiLength so it's in range of [ 0, 2PI ]\n\n    phiLength = MathUtils.clamp(phiLength, 0, Math.PI * 2);\n\n    // buffers\n\n    const indices = [];\n    const vertices = [];\n    const uvs = [];\n    const initNormals = [];\n    const normals = [];\n\n    // helper variables\n\n    const inverseSegments = 1.0 / segments;\n    const vertex = new Vector3();\n    const uv = new Vector2();\n    const normal = new Vector3();\n    const curNormal = new Vector3();\n    const prevNormal = new Vector3();\n    let dx = 0;\n    let dy = 0;\n\n    // pre-compute normals for initial \"meridian\"\n\n    for (let j = 0; j <= points.length - 1; j++) {\n      switch (j) {\n        case 0:\n          // special handling for 1st vertex on path\n\n          dx = points[j + 1].x - points[j].x;\n          dy = points[j + 1].y - points[j].y;\n          normal.x = dy * 1.0;\n          normal.y = -dx;\n          normal.z = dy * 0.0;\n          prevNormal.copy(normal);\n          normal.normalize();\n          initNormals.push(normal.x, normal.y, normal.z);\n          break;\n        case points.length - 1:\n          // special handling for last Vertex on path\n\n          initNormals.push(prevNormal.x, prevNormal.y, prevNormal.z);\n          break;\n        default:\n          // default handling for all vertices in between\n\n          dx = points[j + 1].x - points[j].x;\n          dy = points[j + 1].y - points[j].y;\n          normal.x = dy * 1.0;\n          normal.y = -dx;\n          normal.z = dy * 0.0;\n          curNormal.copy(normal);\n          normal.x += prevNormal.x;\n          normal.y += prevNormal.y;\n          normal.z += prevNormal.z;\n          normal.normalize();\n          initNormals.push(normal.x, normal.y, normal.z);\n          prevNormal.copy(curNormal);\n      }\n    }\n\n    // generate vertices, uvs and normals\n\n    for (let i = 0; i <= segments; i++) {\n      const phi = phiStart + i * inverseSegments * phiLength;\n      const sin = Math.sin(phi);\n      const cos = Math.cos(phi);\n      for (let j = 0; j <= points.length - 1; j++) {\n        // vertex\n\n        vertex.x = points[j].x * sin;\n        vertex.y = points[j].y;\n        vertex.z = points[j].x * cos;\n        vertices.push(vertex.x, vertex.y, vertex.z);\n\n        // uv\n\n        uv.x = i / segments;\n        uv.y = j / (points.length - 1);\n        uvs.push(uv.x, uv.y);\n\n        // normal\n\n        const x = initNormals[3 * j + 0] * sin;\n        const y = initNormals[3 * j + 1];\n        const z = initNormals[3 * j + 0] * cos;\n        normals.push(x, y, z);\n      }\n    }\n\n    // indices\n\n    for (let i = 0; i < segments; i++) {\n      for (let j = 0; j < points.length - 1; j++) {\n        const base = j + i * points.length;\n        const a = base;\n        const b = base + points.length;\n        const c = base + points.length + 1;\n        const d = base + 1;\n\n        // faces\n\n        indices.push(a, b, d);\n        indices.push(c, d, b);\n      }\n    }\n\n    // build geometry\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n  }\n  static fromJSON(data) {\n    return new LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);\n  }\n}\nexport { LatheGeometry };","map":{"version":3,"names":["Float32BufferAttribute","BufferGeometry","Vector3","Vector2","MathUtils","LatheGeometry","constructor","points","segments","phiStart","phiLength","Math","PI","type","parameters","floor","clamp","indices","vertices","uvs","initNormals","normals","inverseSegments","vertex","uv","normal","curNormal","prevNormal","dx","dy","j","length","x","y","z","copy","normalize","push","i","phi","sin","cos","base","a","b","c","d","setIndex","setAttribute","fromJSON","data"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/geometries/LatheGeometry.js"],"sourcesContent":["import { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport * as MathUtils from '../math/MathUtils.js';\n\nclass LatheGeometry extends BufferGeometry {\n\n\tconstructor( points = [ new Vector2( 0, - 0.5 ), new Vector2( 0.5, 0 ), new Vector2( 0, 0.5 ) ], segments = 12, phiStart = 0, phiLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'LatheGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpoints: points,\n\t\t\tsegments: segments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength\n\t\t};\n\n\t\tsegments = Math.floor( segments );\n\n\t\t// clamp phiLength so it's in range of [ 0, 2PI ]\n\n\t\tphiLength = MathUtils.clamp( phiLength, 0, Math.PI * 2 );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst uvs = [];\n\t\tconst initNormals = [];\n\t\tconst normals = [];\n\n\t\t// helper variables\n\n\t\tconst inverseSegments = 1.0 / segments;\n\t\tconst vertex = new Vector3();\n\t\tconst uv = new Vector2();\n\t\tconst normal = new Vector3();\n\t\tconst curNormal = new Vector3();\n\t\tconst prevNormal = new Vector3();\n\t\tlet dx = 0;\n\t\tlet dy = 0;\n\n\t\t// pre-compute normals for initial \"meridian\"\n\n\t\tfor ( let j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n\t\t\tswitch ( j ) {\n\n\t\t\t\tcase 0:\t\t\t\t// special handling for 1st vertex on path\n\n\t\t\t\t\tdx = points[ j + 1 ].x - points[ j ].x;\n\t\t\t\t\tdy = points[ j + 1 ].y - points[ j ].y;\n\n\t\t\t\t\tnormal.x = dy * 1.0;\n\t\t\t\t\tnormal.y = - dx;\n\t\t\t\t\tnormal.z = dy * 0.0;\n\n\t\t\t\t\tprevNormal.copy( normal );\n\n\t\t\t\t\tnormal.normalize();\n\n\t\t\t\t\tinitNormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ( points.length - 1 ):\t// special handling for last Vertex on path\n\n\t\t\t\t\tinitNormals.push( prevNormal.x, prevNormal.y, prevNormal.z );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\t\t\t// default handling for all vertices in between\n\n\t\t\t\t\tdx = points[ j + 1 ].x - points[ j ].x;\n\t\t\t\t\tdy = points[ j + 1 ].y - points[ j ].y;\n\n\t\t\t\t\tnormal.x = dy * 1.0;\n\t\t\t\t\tnormal.y = - dx;\n\t\t\t\t\tnormal.z = dy * 0.0;\n\n\t\t\t\t\tcurNormal.copy( normal );\n\n\t\t\t\t\tnormal.x += prevNormal.x;\n\t\t\t\t\tnormal.y += prevNormal.y;\n\t\t\t\t\tnormal.z += prevNormal.z;\n\n\t\t\t\t\tnormal.normalize();\n\n\t\t\t\t\tinitNormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t\tprevNormal.copy( curNormal );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate vertices, uvs and normals\n\n\t\tfor ( let i = 0; i <= segments; i ++ ) {\n\n\t\t\tconst phi = phiStart + i * inverseSegments * phiLength;\n\n\t\t\tconst sin = Math.sin( phi );\n\t\t\tconst cos = Math.cos( phi );\n\n\t\t\tfor ( let j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = points[ j ].x * sin;\n\t\t\t\tvertex.y = points[ j ].y;\n\t\t\t\tvertex.z = points[ j ].x * cos;\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuv.x = i / segments;\n\t\t\t\tuv.y = j / ( points.length - 1 );\n\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\t// normal\n\n\t\t\t\tconst x = initNormals[ 3 * j + 0 ] * sin;\n\t\t\t\tconst y = initNormals[ 3 * j + 1 ];\n\t\t\t\tconst z = initNormals[ 3 * j + 0 ] * cos;\n\n\t\t\t\tnormals.push( x, y, z );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let i = 0; i < segments; i ++ ) {\n\n\t\t\tfor ( let j = 0; j < ( points.length - 1 ); j ++ ) {\n\n\t\t\t\tconst base = j + i * points.length;\n\n\t\t\t\tconst a = base;\n\t\t\t\tconst b = base + points.length;\n\t\t\t\tconst c = base + points.length + 1;\n\t\t\t\tconst d = base + 1;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( c, d, b );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new LatheGeometry( data.points, data.segments, data.phiStart, data.phiLength );\n\n\t}\n\n}\n\n\nexport { LatheGeometry };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}