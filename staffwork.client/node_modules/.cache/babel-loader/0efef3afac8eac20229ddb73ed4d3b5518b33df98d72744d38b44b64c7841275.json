{"ast":null,"code":"import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\nclass BoxGeometry extends BufferGeometry {\n  constructor() {\n    let width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    let height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    let widthSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    let heightSegments = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n    let depthSegments = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;\n    super();\n    this.type = 'BoxGeometry';\n    this.parameters = {\n      width: width,\n      height: height,\n      depth: depth,\n      widthSegments: widthSegments,\n      heightSegments: heightSegments,\n      depthSegments: depthSegments\n    };\n    const scope = this;\n\n    // segments\n\n    widthSegments = Math.floor(widthSegments);\n    heightSegments = Math.floor(heightSegments);\n    depthSegments = Math.floor(depthSegments);\n\n    // buffers\n\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n\n    // helper variables\n\n    let numberOfVertices = 0;\n    let groupStart = 0;\n\n    // build each side of the box geometry\n\n    buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px\n    buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx\n    buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py\n    buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny\n    buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz\n    buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz\n\n    // build geometry\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n    function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {\n      const segmentWidth = width / gridX;\n      const segmentHeight = height / gridY;\n      const widthHalf = width / 2;\n      const heightHalf = height / 2;\n      const depthHalf = depth / 2;\n      const gridX1 = gridX + 1;\n      const gridY1 = gridY + 1;\n      let vertexCounter = 0;\n      let groupCount = 0;\n      const vector = new Vector3();\n\n      // generate vertices, normals and uvs\n\n      for (let iy = 0; iy < gridY1; iy++) {\n        const y = iy * segmentHeight - heightHalf;\n        for (let ix = 0; ix < gridX1; ix++) {\n          const x = ix * segmentWidth - widthHalf;\n\n          // set values to correct vector component\n\n          vector[u] = x * udir;\n          vector[v] = y * vdir;\n          vector[w] = depthHalf;\n\n          // now apply vector to vertex buffer\n\n          vertices.push(vector.x, vector.y, vector.z);\n\n          // set values to correct vector component\n\n          vector[u] = 0;\n          vector[v] = 0;\n          vector[w] = depth > 0 ? 1 : -1;\n\n          // now apply vector to normal buffer\n\n          normals.push(vector.x, vector.y, vector.z);\n\n          // uvs\n\n          uvs.push(ix / gridX);\n          uvs.push(1 - iy / gridY);\n\n          // counters\n\n          vertexCounter += 1;\n        }\n      }\n\n      // indices\n\n      // 1. you need three indices to draw a single face\n      // 2. a single segment consists of two faces\n      // 3. so we need to generate six (2*3) indices per segment\n\n      for (let iy = 0; iy < gridY; iy++) {\n        for (let ix = 0; ix < gridX; ix++) {\n          const a = numberOfVertices + ix + gridX1 * iy;\n          const b = numberOfVertices + ix + gridX1 * (iy + 1);\n          const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);\n          const d = numberOfVertices + (ix + 1) + gridX1 * iy;\n\n          // faces\n\n          indices.push(a, b, d);\n          indices.push(b, c, d);\n\n          // increase counter\n\n          groupCount += 6;\n        }\n      }\n\n      // add a group to the geometry. this will ensure multi material support\n\n      scope.addGroup(groupStart, groupCount, materialIndex);\n\n      // calculate new start value for groups\n\n      groupStart += groupCount;\n\n      // update total number of vertices\n\n      numberOfVertices += vertexCounter;\n    }\n  }\n  static fromJSON(data) {\n    return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);\n  }\n}\nexport { BoxGeometry };","map":{"version":3,"names":["BufferGeometry","Float32BufferAttribute","Vector3","BoxGeometry","constructor","width","height","depth","widthSegments","heightSegments","depthSegments","type","parameters","scope","Math","floor","indices","vertices","normals","uvs","numberOfVertices","groupStart","buildPlane","setIndex","setAttribute","u","v","w","udir","vdir","gridX","gridY","materialIndex","segmentWidth","segmentHeight","widthHalf","heightHalf","depthHalf","gridX1","gridY1","vertexCounter","groupCount","vector","iy","y","ix","x","push","z","a","b","c","d","addGroup","fromJSON","data"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/geometries/BoxGeometry.js"],"sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nclass BoxGeometry extends BufferGeometry {\n\n\tconstructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'BoxGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tdepth: depth,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tdepthSegments: depthSegments\n\t\t};\n\n\t\tconst scope = this;\n\n\t\t// segments\n\n\t\twidthSegments = Math.floor( widthSegments );\n\t\theightSegments = Math.floor( heightSegments );\n\t\tdepthSegments = Math.floor( depthSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tlet numberOfVertices = 0;\n\t\tlet groupStart = 0;\n\n\t\t// build each side of the box geometry\n\n\t\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px\n\t\tbuildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx\n\t\tbuildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py\n\t\tbuildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny\n\t\tbuildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz\n\t\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\tfunction buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\n\n\t\t\tconst segmentWidth = width / gridX;\n\t\t\tconst segmentHeight = height / gridY;\n\n\t\t\tconst widthHalf = width / 2;\n\t\t\tconst heightHalf = height / 2;\n\t\t\tconst depthHalf = depth / 2;\n\n\t\t\tconst gridX1 = gridX + 1;\n\t\t\tconst gridY1 = gridY + 1;\n\n\t\t\tlet vertexCounter = 0;\n\t\t\tlet groupCount = 0;\n\n\t\t\tconst vector = new Vector3();\n\n\t\t\t// generate vertices, normals and uvs\n\n\t\t\tfor ( let iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\t\tconst y = iy * segmentHeight - heightHalf;\n\n\t\t\t\tfor ( let ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\t\tconst x = ix * segmentWidth - widthHalf;\n\n\t\t\t\t\t// set values to correct vector component\n\n\t\t\t\t\tvector[ u ] = x * udir;\n\t\t\t\t\tvector[ v ] = y * vdir;\n\t\t\t\t\tvector[ w ] = depthHalf;\n\n\t\t\t\t\t// now apply vector to vertex buffer\n\n\t\t\t\t\tvertices.push( vector.x, vector.y, vector.z );\n\n\t\t\t\t\t// set values to correct vector component\n\n\t\t\t\t\tvector[ u ] = 0;\n\t\t\t\t\tvector[ v ] = 0;\n\t\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\n\n\t\t\t\t\t// now apply vector to normal buffer\n\n\t\t\t\t\tnormals.push( vector.x, vector.y, vector.z );\n\n\t\t\t\t\t// uvs\n\n\t\t\t\t\tuvs.push( ix / gridX );\n\t\t\t\t\tuvs.push( 1 - ( iy / gridY ) );\n\n\t\t\t\t\t// counters\n\n\t\t\t\t\tvertexCounter += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// indices\n\n\t\t\t// 1. you need three indices to draw a single face\n\t\t\t// 2. a single segment consists of two faces\n\t\t\t// 3. so we need to generate six (2*3) indices per segment\n\n\t\t\tfor ( let iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\t\tfor ( let ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\t\tconst a = numberOfVertices + ix + gridX1 * iy;\n\t\t\t\t\tconst b = numberOfVertices + ix + gridX1 * ( iy + 1 );\n\t\t\t\t\tconst c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\t\tconst d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t\t// increase counter\n\n\t\t\t\t\tgroupCount += 6;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\t\tscope.addGroup( groupStart, groupCount, materialIndex );\n\n\t\t\t// calculate new start value for groups\n\n\t\t\tgroupStart += groupCount;\n\n\t\t\t// update total number of vertices\n\n\t\t\tnumberOfVertices += vertexCounter;\n\n\t\t}\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new BoxGeometry( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments );\n\n\t}\n\n}\n\nexport { BoxGeometry };\n"],"mappings":"AAAA,SAASA,cAAc,QAAQ,2BAA2B;AAC1D,SAASC,sBAAsB,QAAQ,4BAA4B;AACnE,SAASC,OAAO,QAAQ,oBAAoB;AAE5C,MAAMC,WAAW,SAASH,cAAc,CAAC;EAExCI,WAAW,GAA+F;IAAA,IAA7FC,KAAK,uEAAG,CAAC;IAAA,IAAEC,MAAM,uEAAG,CAAC;IAAA,IAAEC,KAAK,uEAAG,CAAC;IAAA,IAAEC,aAAa,uEAAG,CAAC;IAAA,IAAEC,cAAc,uEAAG,CAAC;IAAA,IAAEC,aAAa,uEAAG,CAAC;IAEtG,KAAK,EAAE;IAEP,IAAI,CAACC,IAAI,GAAG,aAAa;IAEzB,IAAI,CAACC,UAAU,GAAG;MACjBP,KAAK,EAAEA,KAAK;MACZC,MAAM,EAAEA,MAAM;MACdC,KAAK,EAAEA,KAAK;MACZC,aAAa,EAAEA,aAAa;MAC5BC,cAAc,EAAEA,cAAc;MAC9BC,aAAa,EAAEA;IAChB,CAAC;IAED,MAAMG,KAAK,GAAG,IAAI;;IAElB;;IAEAL,aAAa,GAAGM,IAAI,CAACC,KAAK,CAAEP,aAAa,CAAE;IAC3CC,cAAc,GAAGK,IAAI,CAACC,KAAK,CAAEN,cAAc,CAAE;IAC7CC,aAAa,GAAGI,IAAI,CAACC,KAAK,CAAEL,aAAa,CAAE;;IAE3C;;IAEA,MAAMM,OAAO,GAAG,EAAE;IAClB,MAAMC,QAAQ,GAAG,EAAE;IACnB,MAAMC,OAAO,GAAG,EAAE;IAClB,MAAMC,GAAG,GAAG,EAAE;;IAEd;;IAEA,IAAIC,gBAAgB,GAAG,CAAC;IACxB,IAAIC,UAAU,GAAG,CAAC;;IAElB;;IAEAC,UAAU,CAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAE,CAAC,EAAE,CAAE,CAAC,EAAEf,KAAK,EAAED,MAAM,EAAED,KAAK,EAAEK,aAAa,EAAED,cAAc,EAAE,CAAC,CAAE,CAAC,CAAC;IAC/Fa,UAAU,CAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,EAAE,CAAE,CAAC,EAAEf,KAAK,EAAED,MAAM,EAAE,CAAED,KAAK,EAAEK,aAAa,EAAED,cAAc,EAAE,CAAC,CAAE,CAAC,CAAC;IAC/Fa,UAAU,CAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAEjB,KAAK,EAAEE,KAAK,EAAED,MAAM,EAAEE,aAAa,EAAEE,aAAa,EAAE,CAAC,CAAE,CAAC,CAAC;IAC1FY,UAAU,CAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,EAAE,CAAE,CAAC,EAAEjB,KAAK,EAAEE,KAAK,EAAE,CAAED,MAAM,EAAEE,aAAa,EAAEE,aAAa,EAAE,CAAC,CAAE,CAAC,CAAC;IAC9FY,UAAU,CAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,EAAE,CAAE,CAAC,EAAEjB,KAAK,EAAEC,MAAM,EAAEC,KAAK,EAAEC,aAAa,EAAEC,cAAc,EAAE,CAAC,CAAE,CAAC,CAAC;IAC7Fa,UAAU,CAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAE,CAAC,EAAE,CAAE,CAAC,EAAEjB,KAAK,EAAEC,MAAM,EAAE,CAAEC,KAAK,EAAEC,aAAa,EAAEC,cAAc,EAAE,CAAC,CAAE,CAAC,CAAC;;IAEjG;;IAEA,IAAI,CAACc,QAAQ,CAAEP,OAAO,CAAE;IACxB,IAAI,CAACQ,YAAY,CAAE,UAAU,EAAE,IAAIvB,sBAAsB,CAAEgB,QAAQ,EAAE,CAAC,CAAE,CAAE;IAC1E,IAAI,CAACO,YAAY,CAAE,QAAQ,EAAE,IAAIvB,sBAAsB,CAAEiB,OAAO,EAAE,CAAC,CAAE,CAAE;IACvE,IAAI,CAACM,YAAY,CAAE,IAAI,EAAE,IAAIvB,sBAAsB,CAAEkB,GAAG,EAAE,CAAC,CAAE,CAAE;IAE/D,SAASG,UAAU,CAAEG,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,IAAI,EAAEC,IAAI,EAAExB,KAAK,EAAEC,MAAM,EAAEC,KAAK,EAAEuB,KAAK,EAAEC,KAAK,EAAEC,aAAa,EAAG;MAE7F,MAAMC,YAAY,GAAG5B,KAAK,GAAGyB,KAAK;MAClC,MAAMI,aAAa,GAAG5B,MAAM,GAAGyB,KAAK;MAEpC,MAAMI,SAAS,GAAG9B,KAAK,GAAG,CAAC;MAC3B,MAAM+B,UAAU,GAAG9B,MAAM,GAAG,CAAC;MAC7B,MAAM+B,SAAS,GAAG9B,KAAK,GAAG,CAAC;MAE3B,MAAM+B,MAAM,GAAGR,KAAK,GAAG,CAAC;MACxB,MAAMS,MAAM,GAAGR,KAAK,GAAG,CAAC;MAExB,IAAIS,aAAa,GAAG,CAAC;MACrB,IAAIC,UAAU,GAAG,CAAC;MAElB,MAAMC,MAAM,GAAG,IAAIxC,OAAO,EAAE;;MAE5B;;MAEA,KAAM,IAAIyC,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGJ,MAAM,EAAEI,EAAE,EAAG,EAAG;QAEtC,MAAMC,CAAC,GAAGD,EAAE,GAAGT,aAAa,GAAGE,UAAU;QAEzC,KAAM,IAAIS,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGP,MAAM,EAAEO,EAAE,EAAG,EAAG;UAEtC,MAAMC,CAAC,GAAGD,EAAE,GAAGZ,YAAY,GAAGE,SAAS;;UAEvC;;UAEAO,MAAM,CAAEjB,CAAC,CAAE,GAAGqB,CAAC,GAAGlB,IAAI;UACtBc,MAAM,CAAEhB,CAAC,CAAE,GAAGkB,CAAC,GAAGf,IAAI;UACtBa,MAAM,CAAEf,CAAC,CAAE,GAAGU,SAAS;;UAEvB;;UAEApB,QAAQ,CAAC8B,IAAI,CAAEL,MAAM,CAACI,CAAC,EAAEJ,MAAM,CAACE,CAAC,EAAEF,MAAM,CAACM,CAAC,CAAE;;UAE7C;;UAEAN,MAAM,CAAEjB,CAAC,CAAE,GAAG,CAAC;UACfiB,MAAM,CAAEhB,CAAC,CAAE,GAAG,CAAC;UACfgB,MAAM,CAAEf,CAAC,CAAE,GAAGpB,KAAK,GAAG,CAAC,GAAG,CAAC,GAAG,CAAE,CAAC;;UAEjC;;UAEAW,OAAO,CAAC6B,IAAI,CAAEL,MAAM,CAACI,CAAC,EAAEJ,MAAM,CAACE,CAAC,EAAEF,MAAM,CAACM,CAAC,CAAE;;UAE5C;;UAEA7B,GAAG,CAAC4B,IAAI,CAAEF,EAAE,GAAGf,KAAK,CAAE;UACtBX,GAAG,CAAC4B,IAAI,CAAE,CAAC,GAAKJ,EAAE,GAAGZ,KAAO,CAAE;;UAE9B;;UAEAS,aAAa,IAAI,CAAC;QAEnB;MAED;;MAEA;;MAEA;MACA;MACA;;MAEA,KAAM,IAAIG,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGZ,KAAK,EAAEY,EAAE,EAAG,EAAG;QAErC,KAAM,IAAIE,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGf,KAAK,EAAEe,EAAE,EAAG,EAAG;UAErC,MAAMI,CAAC,GAAG7B,gBAAgB,GAAGyB,EAAE,GAAGP,MAAM,GAAGK,EAAE;UAC7C,MAAMO,CAAC,GAAG9B,gBAAgB,GAAGyB,EAAE,GAAGP,MAAM,IAAKK,EAAE,GAAG,CAAC,CAAE;UACrD,MAAMQ,CAAC,GAAG/B,gBAAgB,IAAKyB,EAAE,GAAG,CAAC,CAAE,GAAGP,MAAM,IAAKK,EAAE,GAAG,CAAC,CAAE;UAC7D,MAAMS,CAAC,GAAGhC,gBAAgB,IAAKyB,EAAE,GAAG,CAAC,CAAE,GAAGP,MAAM,GAAGK,EAAE;;UAErD;;UAEA3B,OAAO,CAAC+B,IAAI,CAAEE,CAAC,EAAEC,CAAC,EAAEE,CAAC,CAAE;UACvBpC,OAAO,CAAC+B,IAAI,CAAEG,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAE;;UAEvB;;UAEAX,UAAU,IAAI,CAAC;QAEhB;MAED;;MAEA;;MAEA5B,KAAK,CAACwC,QAAQ,CAAEhC,UAAU,EAAEoB,UAAU,EAAET,aAAa,CAAE;;MAEvD;;MAEAX,UAAU,IAAIoB,UAAU;;MAExB;;MAEArB,gBAAgB,IAAIoB,aAAa;IAElC;EAED;EAEA,OAAOc,QAAQ,CAAEC,IAAI,EAAG;IAEvB,OAAO,IAAIpD,WAAW,CAAEoD,IAAI,CAAClD,KAAK,EAAEkD,IAAI,CAACjD,MAAM,EAAEiD,IAAI,CAAChD,KAAK,EAAEgD,IAAI,CAAC/C,aAAa,EAAE+C,IAAI,CAAC9C,cAAc,EAAE8C,IAAI,CAAC7C,aAAa,CAAE;EAE3H;AAED;AAEA,SAASP,WAAW"},"metadata":{},"sourceType":"module","externalDependencies":[]}