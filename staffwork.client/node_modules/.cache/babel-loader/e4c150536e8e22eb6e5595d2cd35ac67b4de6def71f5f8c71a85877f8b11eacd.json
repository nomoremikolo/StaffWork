{"ast":null,"code":"import { BackSide, FrontSide, CubeUVReflectionMapping } from '../../constants.js';\nimport { BoxGeometry } from '../../geometries/BoxGeometry.js';\nimport { PlaneGeometry } from '../../geometries/PlaneGeometry.js';\nimport { ShaderMaterial } from '../../materials/ShaderMaterial.js';\nimport { Color } from '../../math/Color.js';\nimport { Mesh } from '../../objects/Mesh.js';\nimport { ShaderLib } from '../shaders/ShaderLib.js';\nimport { cloneUniforms, getUnlitUniformColorSpace } from '../shaders/UniformsUtils.js';\nconst _rgb = {\n  r: 0,\n  b: 0,\n  g: 0\n};\nfunction WebGLBackground(renderer, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha) {\n  const clearColor = new Color(0x000000);\n  let clearAlpha = alpha === true ? 0 : 1;\n  let planeMesh;\n  let boxMesh;\n  let currentBackground = null;\n  let currentBackgroundVersion = 0;\n  let currentTonemapping = null;\n  function render(renderList, scene) {\n    let forceClear = false;\n    let background = scene.isScene === true ? scene.background : null;\n    if (background && background.isTexture) {\n      const usePMREM = scene.backgroundBlurriness > 0; // use PMREM if the user wants to blur the background\n      background = (usePMREM ? cubeuvmaps : cubemaps).get(background);\n    }\n\n    // Ignore background in AR\n    // TODO: Reconsider this.\n\n    const xr = renderer.xr;\n    const session = xr.getSession && xr.getSession();\n    if (session && session.environmentBlendMode === 'additive') {\n      background = null;\n    }\n    if (background === null) {\n      setClear(clearColor, clearAlpha);\n    } else if (background && background.isColor) {\n      setClear(background, 1);\n      forceClear = true;\n    }\n    if (renderer.autoClear || forceClear) {\n      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);\n    }\n    if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {\n      if (boxMesh === undefined) {\n        boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({\n          name: 'BackgroundCubeMaterial',\n          uniforms: cloneUniforms(ShaderLib.backgroundCube.uniforms),\n          vertexShader: ShaderLib.backgroundCube.vertexShader,\n          fragmentShader: ShaderLib.backgroundCube.fragmentShader,\n          side: BackSide,\n          depthTest: false,\n          depthWrite: false,\n          fog: false\n        }));\n        boxMesh.geometry.deleteAttribute('normal');\n        boxMesh.geometry.deleteAttribute('uv');\n        boxMesh.onBeforeRender = function (renderer, scene, camera) {\n          this.matrixWorld.copyPosition(camera.matrixWorld);\n        };\n\n        // add \"envMap\" material property so the renderer can evaluate it like for built-in materials\n        Object.defineProperty(boxMesh.material, 'envMap', {\n          get: function () {\n            return this.uniforms.envMap.value;\n          }\n        });\n        objects.update(boxMesh);\n      }\n      boxMesh.material.uniforms.envMap.value = background;\n      boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;\n      boxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;\n      boxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;\n      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {\n        boxMesh.material.needsUpdate = true;\n        currentBackground = background;\n        currentBackgroundVersion = background.version;\n        currentTonemapping = renderer.toneMapping;\n      }\n      boxMesh.layers.enableAll();\n\n      // push to the pre-sorted opaque render list\n      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);\n    } else if (background && background.isTexture) {\n      if (planeMesh === undefined) {\n        planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({\n          name: 'BackgroundMaterial',\n          uniforms: cloneUniforms(ShaderLib.background.uniforms),\n          vertexShader: ShaderLib.background.vertexShader,\n          fragmentShader: ShaderLib.background.fragmentShader,\n          side: FrontSide,\n          depthTest: false,\n          depthWrite: false,\n          fog: false\n        }));\n        planeMesh.geometry.deleteAttribute('normal');\n\n        // add \"map\" material property so the renderer can evaluate it like for built-in materials\n        Object.defineProperty(planeMesh.material, 'map', {\n          get: function () {\n            return this.uniforms.t2D.value;\n          }\n        });\n        objects.update(planeMesh);\n      }\n      planeMesh.material.uniforms.t2D.value = background;\n      planeMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;\n      if (background.matrixAutoUpdate === true) {\n        background.updateMatrix();\n      }\n      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);\n      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {\n        planeMesh.material.needsUpdate = true;\n        currentBackground = background;\n        currentBackgroundVersion = background.version;\n        currentTonemapping = renderer.toneMapping;\n      }\n      planeMesh.layers.enableAll();\n\n      // push to the pre-sorted opaque render list\n      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);\n    }\n  }\n  function setClear(color, alpha) {\n    color.getRGB(_rgb, getUnlitUniformColorSpace(renderer));\n    state.buffers.color.setClear(_rgb.r, _rgb.g, _rgb.b, alpha, premultipliedAlpha);\n  }\n  return {\n    getClearColor: function () {\n      return clearColor;\n    },\n    setClearColor: function (color) {\n      let alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      clearColor.set(color);\n      clearAlpha = alpha;\n      setClear(clearColor, clearAlpha);\n    },\n    getClearAlpha: function () {\n      return clearAlpha;\n    },\n    setClearAlpha: function (alpha) {\n      clearAlpha = alpha;\n      setClear(clearColor, clearAlpha);\n    },\n    render: render\n  };\n}\nexport { WebGLBackground };","map":{"version":3,"names":["BackSide","FrontSide","CubeUVReflectionMapping","BoxGeometry","PlaneGeometry","ShaderMaterial","Color","Mesh","ShaderLib","cloneUniforms","getUnlitUniformColorSpace","_rgb","r","b","g","WebGLBackground","renderer","cubemaps","cubeuvmaps","state","objects","alpha","premultipliedAlpha","clearColor","clearAlpha","planeMesh","boxMesh","currentBackground","currentBackgroundVersion","currentTonemapping","render","renderList","scene","forceClear","background","isScene","isTexture","usePMREM","backgroundBlurriness","get","xr","session","getSession","environmentBlendMode","setClear","isColor","autoClear","clear","autoClearColor","autoClearDepth","autoClearStencil","isCubeTexture","mapping","undefined","name","uniforms","backgroundCube","vertexShader","fragmentShader","side","depthTest","depthWrite","fog","geometry","deleteAttribute","onBeforeRender","camera","matrixWorld","copyPosition","Object","defineProperty","material","envMap","value","update","flipEnvMap","isRenderTargetTexture","backgroundIntensity","version","toneMapping","needsUpdate","layers","enableAll","unshift","t2D","matrixAutoUpdate","updateMatrix","uvTransform","copy","matrix","color","getRGB","buffers","getClearColor","setClearColor","set","getClearAlpha","setClearAlpha"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/renderers/webgl/WebGLBackground.js"],"sourcesContent":["import { BackSide, FrontSide, CubeUVReflectionMapping } from '../../constants.js';\nimport { BoxGeometry } from '../../geometries/BoxGeometry.js';\nimport { PlaneGeometry } from '../../geometries/PlaneGeometry.js';\nimport { ShaderMaterial } from '../../materials/ShaderMaterial.js';\nimport { Color } from '../../math/Color.js';\nimport { Mesh } from '../../objects/Mesh.js';\nimport { ShaderLib } from '../shaders/ShaderLib.js';\nimport { cloneUniforms, getUnlitUniformColorSpace } from '../shaders/UniformsUtils.js';\n\nconst _rgb = { r: 0, b: 0, g: 0 };\n\nfunction WebGLBackground( renderer, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha ) {\n\n\tconst clearColor = new Color( 0x000000 );\n\tlet clearAlpha = alpha === true ? 0 : 1;\n\n\tlet planeMesh;\n\tlet boxMesh;\n\n\tlet currentBackground = null;\n\tlet currentBackgroundVersion = 0;\n\tlet currentTonemapping = null;\n\n\tfunction render( renderList, scene ) {\n\n\t\tlet forceClear = false;\n\t\tlet background = scene.isScene === true ? scene.background : null;\n\n\t\tif ( background && background.isTexture ) {\n\n\t\t\tconst usePMREM = scene.backgroundBlurriness > 0; // use PMREM if the user wants to blur the background\n\t\t\tbackground = ( usePMREM ? cubeuvmaps : cubemaps ).get( background );\n\n\t\t}\n\n\t\t// Ignore background in AR\n\t\t// TODO: Reconsider this.\n\n\t\tconst xr = renderer.xr;\n\t\tconst session = xr.getSession && xr.getSession();\n\n\t\tif ( session && session.environmentBlendMode === 'additive' ) {\n\n\t\t\tbackground = null;\n\n\t\t}\n\n\t\tif ( background === null ) {\n\n\t\t\tsetClear( clearColor, clearAlpha );\n\n\t\t} else if ( background && background.isColor ) {\n\n\t\t\tsetClear( background, 1 );\n\t\t\tforceClear = true;\n\n\t\t}\n\n\t\tif ( renderer.autoClear || forceClear ) {\n\n\t\t\trenderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\n\n\t\t}\n\n\t\tif ( background && ( background.isCubeTexture || background.mapping === CubeUVReflectionMapping ) ) {\n\n\t\t\tif ( boxMesh === undefined ) {\n\n\t\t\t\tboxMesh = new Mesh(\n\t\t\t\t\tnew BoxGeometry( 1, 1, 1 ),\n\t\t\t\t\tnew ShaderMaterial( {\n\t\t\t\t\t\tname: 'BackgroundCubeMaterial',\n\t\t\t\t\t\tuniforms: cloneUniforms( ShaderLib.backgroundCube.uniforms ),\n\t\t\t\t\t\tvertexShader: ShaderLib.backgroundCube.vertexShader,\n\t\t\t\t\t\tfragmentShader: ShaderLib.backgroundCube.fragmentShader,\n\t\t\t\t\t\tside: BackSide,\n\t\t\t\t\t\tdepthTest: false,\n\t\t\t\t\t\tdepthWrite: false,\n\t\t\t\t\t\tfog: false\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tboxMesh.geometry.deleteAttribute( 'normal' );\n\t\t\t\tboxMesh.geometry.deleteAttribute( 'uv' );\n\n\t\t\t\tboxMesh.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\t\t\tthis.matrixWorld.copyPosition( camera.matrixWorld );\n\n\t\t\t\t};\n\n\t\t\t\t// add \"envMap\" material property so the renderer can evaluate it like for built-in materials\n\t\t\t\tObject.defineProperty( boxMesh.material, 'envMap', {\n\n\t\t\t\t\tget: function () {\n\n\t\t\t\t\t\treturn this.uniforms.envMap.value;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tobjects.update( boxMesh );\n\n\t\t\t}\n\n\t\t\tboxMesh.material.uniforms.envMap.value = background;\n\t\t\tboxMesh.material.uniforms.flipEnvMap.value = ( background.isCubeTexture && background.isRenderTargetTexture === false ) ? - 1 : 1;\n\t\t\tboxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;\n\t\t\tboxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;\n\n\t\t\tif ( currentBackground !== background ||\n\t\t\t\tcurrentBackgroundVersion !== background.version ||\n\t\t\t\tcurrentTonemapping !== renderer.toneMapping ) {\n\n\t\t\t\tboxMesh.material.needsUpdate = true;\n\n\t\t\t\tcurrentBackground = background;\n\t\t\t\tcurrentBackgroundVersion = background.version;\n\t\t\t\tcurrentTonemapping = renderer.toneMapping;\n\n\t\t\t}\n\n\t\t\tboxMesh.layers.enableAll();\n\n\t\t\t// push to the pre-sorted opaque render list\n\t\t\trenderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );\n\n\t\t} else if ( background && background.isTexture ) {\n\n\t\t\tif ( planeMesh === undefined ) {\n\n\t\t\t\tplaneMesh = new Mesh(\n\t\t\t\t\tnew PlaneGeometry( 2, 2 ),\n\t\t\t\t\tnew ShaderMaterial( {\n\t\t\t\t\t\tname: 'BackgroundMaterial',\n\t\t\t\t\t\tuniforms: cloneUniforms( ShaderLib.background.uniforms ),\n\t\t\t\t\t\tvertexShader: ShaderLib.background.vertexShader,\n\t\t\t\t\t\tfragmentShader: ShaderLib.background.fragmentShader,\n\t\t\t\t\t\tside: FrontSide,\n\t\t\t\t\t\tdepthTest: false,\n\t\t\t\t\t\tdepthWrite: false,\n\t\t\t\t\t\tfog: false\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tplaneMesh.geometry.deleteAttribute( 'normal' );\n\n\t\t\t\t// add \"map\" material property so the renderer can evaluate it like for built-in materials\n\t\t\t\tObject.defineProperty( planeMesh.material, 'map', {\n\n\t\t\t\t\tget: function () {\n\n\t\t\t\t\t\treturn this.uniforms.t2D.value;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tobjects.update( planeMesh );\n\n\t\t\t}\n\n\t\t\tplaneMesh.material.uniforms.t2D.value = background;\n\t\t\tplaneMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;\n\n\t\t\tif ( background.matrixAutoUpdate === true ) {\n\n\t\t\t\tbackground.updateMatrix();\n\n\t\t\t}\n\n\t\t\tplaneMesh.material.uniforms.uvTransform.value.copy( background.matrix );\n\n\t\t\tif ( currentBackground !== background ||\n\t\t\t\tcurrentBackgroundVersion !== background.version ||\n\t\t\t\tcurrentTonemapping !== renderer.toneMapping ) {\n\n\t\t\t\tplaneMesh.material.needsUpdate = true;\n\n\t\t\t\tcurrentBackground = background;\n\t\t\t\tcurrentBackgroundVersion = background.version;\n\t\t\t\tcurrentTonemapping = renderer.toneMapping;\n\n\t\t\t}\n\n\t\t\tplaneMesh.layers.enableAll();\n\n\t\t\t// push to the pre-sorted opaque render list\n\t\t\trenderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );\n\n\t\t}\n\n\t}\n\n\tfunction setClear( color, alpha ) {\n\n\t\tcolor.getRGB( _rgb, getUnlitUniformColorSpace( renderer ) );\n\n\t\tstate.buffers.color.setClear( _rgb.r, _rgb.g, _rgb.b, alpha, premultipliedAlpha );\n\n\t}\n\n\treturn {\n\n\t\tgetClearColor: function () {\n\n\t\t\treturn clearColor;\n\n\t\t},\n\t\tsetClearColor: function ( color, alpha = 1 ) {\n\n\t\t\tclearColor.set( color );\n\t\t\tclearAlpha = alpha;\n\t\t\tsetClear( clearColor, clearAlpha );\n\n\t\t},\n\t\tgetClearAlpha: function () {\n\n\t\t\treturn clearAlpha;\n\n\t\t},\n\t\tsetClearAlpha: function ( alpha ) {\n\n\t\t\tclearAlpha = alpha;\n\t\t\tsetClear( clearColor, clearAlpha );\n\n\t\t},\n\t\trender: render\n\n\t};\n\n}\n\n\nexport { WebGLBackground };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}