{"ast":null,"code":"import Node from '../core/Node.js';\nimport { NodeUpdateType } from '../core/constants.js';\nclass ComputeNode extends Node {\n  constructor(computeNode, count) {\n    let workgroupSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [64];\n    super('void');\n    this.isComputeNode = true;\n    this.computeNode = computeNode;\n    this.count = count;\n    this.workgroupSize = workgroupSize;\n    this.dispatchCount = 0;\n    this.updateType = NodeUpdateType.OBJECT;\n    this.updateDispatchCount();\n  }\n  updateDispatchCount() {\n    const {\n      count,\n      workgroupSize\n    } = this;\n    let size = workgroupSize[0];\n    for (let i = 1; i < workgroupSize.length; i++) size *= workgroupSize[i];\n    this.dispatchCount = Math.ceil(count / size);\n  }\n  onInit() {}\n  update(_ref) {\n    let {\n      renderer\n    } = _ref;\n    renderer.compute(this);\n  }\n  generate(builder) {\n    const {\n      shaderStage\n    } = builder;\n    if (shaderStage === 'compute') {\n      const snippet = this.computeNode.build(builder, 'void');\n      if (snippet !== '') {\n        builder.addFlowCode(snippet);\n      }\n    }\n  }\n}\nexport default ComputeNode;","map":{"version":3,"names":["Node","NodeUpdateType","ComputeNode","constructor","computeNode","count","workgroupSize","isComputeNode","dispatchCount","updateType","OBJECT","updateDispatchCount","size","i","length","Math","ceil","onInit","update","renderer","compute","generate","builder","shaderStage","snippet","build","addFlowCode"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/examples/jsm/nodes/gpgpu/ComputeNode.js"],"sourcesContent":["import Node from '../core/Node.js';\nimport { NodeUpdateType } from '../core/constants.js';\n\nclass ComputeNode extends Node {\n\n\tconstructor( computeNode, count, workgroupSize = [ 64 ] ) {\n\n\t\tsuper( 'void' );\n\n\t\tthis.isComputeNode = true;\n\n\t\tthis.computeNode = computeNode;\n\n\t\tthis.count = count;\n\t\tthis.workgroupSize = workgroupSize;\n\t\tthis.dispatchCount = 0;\n\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t\tthis.updateDispatchCount();\n\n\t}\n\n\tupdateDispatchCount() {\n\n\t\tconst { count, workgroupSize } = this;\n\n\t\tlet size = workgroupSize[ 0 ];\n\n\t\tfor ( let i = 1; i < workgroupSize.length; i ++ )\n\t\t\tsize *= workgroupSize[ i ];\n\n\t\tthis.dispatchCount = Math.ceil( count / size );\n\n\t}\n\n\tonInit() { }\n\n\tupdate( { renderer } ) {\n\n\t\trenderer.compute( this );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { shaderStage } = builder;\n\n\t\tif ( shaderStage === 'compute' ) {\n\n\t\t\tconst snippet = this.computeNode.build( builder, 'void' );\n\n\t\t\tif ( snippet !== '' ) {\n\n\t\t\t\tbuilder.addFlowCode( snippet );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nexport default ComputeNode;\n"],"mappings":"AAAA,OAAOA,IAAI,MAAM,iBAAiB;AAClC,SAASC,cAAc,QAAQ,sBAAsB;AAErD,MAAMC,WAAW,SAASF,IAAI,CAAC;EAE9BG,WAAW,CAAEC,WAAW,EAAEC,KAAK,EAA2B;IAAA,IAAzBC,aAAa,uEAAG,CAAE,EAAE,CAAE;IAEtD,KAAK,CAAE,MAAM,CAAE;IAEf,IAAI,CAACC,aAAa,GAAG,IAAI;IAEzB,IAAI,CAACH,WAAW,GAAGA,WAAW;IAE9B,IAAI,CAACC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACE,aAAa,GAAG,CAAC;IAEtB,IAAI,CAACC,UAAU,GAAGR,cAAc,CAACS,MAAM;IAEvC,IAAI,CAACC,mBAAmB,EAAE;EAE3B;EAEAA,mBAAmB,GAAG;IAErB,MAAM;MAAEN,KAAK;MAAEC;IAAc,CAAC,GAAG,IAAI;IAErC,IAAIM,IAAI,GAAGN,aAAa,CAAE,CAAC,CAAE;IAE7B,KAAM,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,aAAa,CAACQ,MAAM,EAAED,CAAC,EAAG,EAC9CD,IAAI,IAAIN,aAAa,CAAEO,CAAC,CAAE;IAE3B,IAAI,CAACL,aAAa,GAAGO,IAAI,CAACC,IAAI,CAAEX,KAAK,GAAGO,IAAI,CAAE;EAE/C;EAEAK,MAAM,GAAG,CAAE;EAEXC,MAAM,OAAiB;IAAA,IAAf;MAAEC;IAAS,CAAC;IAEnBA,QAAQ,CAACC,OAAO,CAAE,IAAI,CAAE;EAEzB;EAEAC,QAAQ,CAAEC,OAAO,EAAG;IAEnB,MAAM;MAAEC;IAAY,CAAC,GAAGD,OAAO;IAE/B,IAAKC,WAAW,KAAK,SAAS,EAAG;MAEhC,MAAMC,OAAO,GAAG,IAAI,CAACpB,WAAW,CAACqB,KAAK,CAAEH,OAAO,EAAE,MAAM,CAAE;MAEzD,IAAKE,OAAO,KAAK,EAAE,EAAG;QAErBF,OAAO,CAACI,WAAW,CAAEF,OAAO,CAAE;MAE/B;IAED;EAED;AAED;AAEA,eAAetB,WAAW"},"metadata":{},"sourceType":"module","externalDependencies":[]}