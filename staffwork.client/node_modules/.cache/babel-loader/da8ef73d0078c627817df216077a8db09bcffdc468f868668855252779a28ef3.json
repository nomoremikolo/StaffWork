{"ast":null,"code":"import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\nclass CircleGeometry extends BufferGeometry {\n  constructor() {\n    let radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    let segments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;\n    let thetaStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let thetaLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Math.PI * 2;\n    super();\n    this.type = 'CircleGeometry';\n    this.parameters = {\n      radius: radius,\n      segments: segments,\n      thetaStart: thetaStart,\n      thetaLength: thetaLength\n    };\n    segments = Math.max(3, segments);\n\n    // buffers\n\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n\n    // helper variables\n\n    const vertex = new Vector3();\n    const uv = new Vector2();\n\n    // center point\n\n    vertices.push(0, 0, 0);\n    normals.push(0, 0, 1);\n    uvs.push(0.5, 0.5);\n    for (let s = 0, i = 3; s <= segments; s++, i += 3) {\n      const segment = thetaStart + s / segments * thetaLength;\n\n      // vertex\n\n      vertex.x = radius * Math.cos(segment);\n      vertex.y = radius * Math.sin(segment);\n      vertices.push(vertex.x, vertex.y, vertex.z);\n\n      // normal\n\n      normals.push(0, 0, 1);\n\n      // uvs\n\n      uv.x = (vertices[i] / radius + 1) / 2;\n      uv.y = (vertices[i + 1] / radius + 1) / 2;\n      uvs.push(uv.x, uv.y);\n    }\n\n    // indices\n\n    for (let i = 1; i <= segments; i++) {\n      indices.push(i, i + 1, 0);\n    }\n\n    // build geometry\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n  }\n  static fromJSON(data) {\n    return new CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);\n  }\n}\nexport { CircleGeometry };","map":{"version":3,"names":["BufferGeometry","Float32BufferAttribute","Vector3","Vector2","CircleGeometry","constructor","radius","segments","thetaStart","thetaLength","Math","PI","type","parameters","max","indices","vertices","normals","uvs","vertex","uv","push","s","i","segment","x","cos","y","sin","z","setIndex","setAttribute","fromJSON","data"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/geometries/CircleGeometry.js"],"sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\n\nclass CircleGeometry extends BufferGeometry {\n\n\tconstructor( radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'CircleGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tsegments: segments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tsegments = Math.max( 3, segments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tconst vertex = new Vector3();\n\t\tconst uv = new Vector2();\n\n\t\t// center point\n\n\t\tvertices.push( 0, 0, 0 );\n\t\tnormals.push( 0, 0, 1 );\n\t\tuvs.push( 0.5, 0.5 );\n\n\t\tfor ( let s = 0, i = 3; s <= segments; s ++, i += 3 ) {\n\n\t\t\tconst segment = thetaStart + s / segments * thetaLength;\n\n\t\t\t// vertex\n\n\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\tvertex.y = radius * Math.sin( segment );\n\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal\n\n\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\t// uvs\n\n\t\t\tuv.x = ( vertices[ i ] / radius + 1 ) / 2;\n\t\t\tuv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;\n\n\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let i = 1; i <= segments; i ++ ) {\n\n\t\t\tindices.push( i, i + 1, 0 );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new CircleGeometry( data.radius, data.segments, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\n\nexport { CircleGeometry };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}