{"ast":null,"code":"import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport * as Curves from '../extras/curves/Curves.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Vector3 } from '../math/Vector3.js';\nclass TubeGeometry extends BufferGeometry {\n  constructor() {\n    let path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Curves['QuadraticBezierCurve3'](new Vector3(-1, -1, 0), new Vector3(-1, 1, 0), new Vector3(1, 1, 0));\n    let tubularSegments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 64;\n    let radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    let radialSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 8;\n    let closed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    super();\n    this.type = 'TubeGeometry';\n    this.parameters = {\n      path: path,\n      tubularSegments: tubularSegments,\n      radius: radius,\n      radialSegments: radialSegments,\n      closed: closed\n    };\n    const frames = path.computeFrenetFrames(tubularSegments, closed);\n\n    // expose internals\n\n    this.tangents = frames.tangents;\n    this.normals = frames.normals;\n    this.binormals = frames.binormals;\n\n    // helper variables\n\n    const vertex = new Vector3();\n    const normal = new Vector3();\n    const uv = new Vector2();\n    let P = new Vector3();\n\n    // buffer\n\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n    const indices = [];\n\n    // create buffer data\n\n    generateBufferData();\n\n    // build geometry\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\n    // functions\n\n    function generateBufferData() {\n      for (let i = 0; i < tubularSegments; i++) {\n        generateSegment(i);\n      }\n\n      // if the geometry is not closed, generate the last row of vertices and normals\n      // at the regular position on the given path\n      //\n      // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\n\n      generateSegment(closed === false ? tubularSegments : 0);\n\n      // uvs are generated in a separate function.\n      // this makes it easy compute correct values for closed geometries\n\n      generateUVs();\n\n      // finally create faces\n\n      generateIndices();\n    }\n    function generateSegment(i) {\n      // we use getPointAt to sample evenly distributed points from the given path\n\n      P = path.getPointAt(i / tubularSegments, P);\n\n      // retrieve corresponding normal and binormal\n\n      const N = frames.normals[i];\n      const B = frames.binormals[i];\n\n      // generate normals and vertices for the current segment\n\n      for (let j = 0; j <= radialSegments; j++) {\n        const v = j / radialSegments * Math.PI * 2;\n        const sin = Math.sin(v);\n        const cos = -Math.cos(v);\n\n        // normal\n\n        normal.x = cos * N.x + sin * B.x;\n        normal.y = cos * N.y + sin * B.y;\n        normal.z = cos * N.z + sin * B.z;\n        normal.normalize();\n        normals.push(normal.x, normal.y, normal.z);\n\n        // vertex\n\n        vertex.x = P.x + radius * normal.x;\n        vertex.y = P.y + radius * normal.y;\n        vertex.z = P.z + radius * normal.z;\n        vertices.push(vertex.x, vertex.y, vertex.z);\n      }\n    }\n    function generateIndices() {\n      for (let j = 1; j <= tubularSegments; j++) {\n        for (let i = 1; i <= radialSegments; i++) {\n          const a = (radialSegments + 1) * (j - 1) + (i - 1);\n          const b = (radialSegments + 1) * j + (i - 1);\n          const c = (radialSegments + 1) * j + i;\n          const d = (radialSegments + 1) * (j - 1) + i;\n\n          // faces\n\n          indices.push(a, b, d);\n          indices.push(b, c, d);\n        }\n      }\n    }\n    function generateUVs() {\n      for (let i = 0; i <= tubularSegments; i++) {\n        for (let j = 0; j <= radialSegments; j++) {\n          uv.x = i / tubularSegments;\n          uv.y = j / radialSegments;\n          uvs.push(uv.x, uv.y);\n        }\n      }\n    }\n  }\n  toJSON() {\n    const data = super.toJSON();\n    data.path = this.parameters.path.toJSON();\n    return data;\n  }\n  static fromJSON(data) {\n    // This only works for built-in curves (e.g. CatmullRomCurve3).\n    // User defined curves or instances of CurvePath will not be deserialized.\n    return new TubeGeometry(new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);\n  }\n}\nexport { TubeGeometry };","map":{"version":3,"names":["BufferGeometry","Float32BufferAttribute","Curves","Vector2","Vector3","TubeGeometry","constructor","path","tubularSegments","radius","radialSegments","closed","type","parameters","frames","computeFrenetFrames","tangents","normals","binormals","vertex","normal","uv","P","vertices","uvs","indices","generateBufferData","setIndex","setAttribute","i","generateSegment","generateUVs","generateIndices","getPointAt","N","B","j","v","Math","PI","sin","cos","x","y","z","normalize","push","a","b","c","d","toJSON","data","fromJSON"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/geometries/TubeGeometry.js"],"sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport * as Curves from '../extras/curves/Curves.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nclass TubeGeometry extends BufferGeometry {\n\n\tconstructor( path = new Curves[ 'QuadraticBezierCurve3' ]( new Vector3( - 1, - 1, 0 ), new Vector3( - 1, 1, 0 ), new Vector3( 1, 1, 0 ) ), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'TubeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpath: path,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradius: radius,\n\t\t\tradialSegments: radialSegments,\n\t\t\tclosed: closed\n\t\t};\n\n\t\tconst frames = path.computeFrenetFrames( tubularSegments, closed );\n\n\t\t// expose internals\n\n\t\tthis.tangents = frames.tangents;\n\t\tthis.normals = frames.normals;\n\t\tthis.binormals = frames.binormals;\n\n\t\t// helper variables\n\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\t\tconst uv = new Vector2();\n\t\tlet P = new Vector3();\n\n\t\t// buffer\n\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\t\tconst indices = [];\n\n\t\t// create buffer data\n\n\t\tgenerateBufferData();\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\t// functions\n\n\t\tfunction generateBufferData() {\n\n\t\t\tfor ( let i = 0; i < tubularSegments; i ++ ) {\n\n\t\t\t\tgenerateSegment( i );\n\n\t\t\t}\n\n\t\t\t// if the geometry is not closed, generate the last row of vertices and normals\n\t\t\t// at the regular position on the given path\n\t\t\t//\n\t\t\t// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\n\n\t\t\tgenerateSegment( ( closed === false ) ? tubularSegments : 0 );\n\n\t\t\t// uvs are generated in a separate function.\n\t\t\t// this makes it easy compute correct values for closed geometries\n\n\t\t\tgenerateUVs();\n\n\t\t\t// finally create faces\n\n\t\t\tgenerateIndices();\n\n\t\t}\n\n\t\tfunction generateSegment( i ) {\n\n\t\t\t// we use getPointAt to sample evenly distributed points from the given path\n\n\t\t\tP = path.getPointAt( i / tubularSegments, P );\n\n\t\t\t// retrieve corresponding normal and binormal\n\n\t\t\tconst N = frames.normals[ i ];\n\t\t\tconst B = frames.binormals[ i ];\n\n\t\t\t// generate normals and vertices for the current segment\n\n\t\t\tfor ( let j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\t\tconst v = j / radialSegments * Math.PI * 2;\n\n\t\t\t\tconst sin = Math.sin( v );\n\t\t\t\tconst cos = - Math.cos( v );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormal.x = ( cos * N.x + sin * B.x );\n\t\t\t\tnormal.y = ( cos * N.y + sin * B.y );\n\t\t\t\tnormal.z = ( cos * N.z + sin * B.z );\n\t\t\t\tnormal.normalize();\n\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = P.x + radius * normal.x;\n\t\t\t\tvertex.y = P.y + radius * normal.y;\n\t\t\t\tvertex.z = P.z + radius * normal.z;\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateIndices() {\n\n\t\t\tfor ( let j = 1; j <= tubularSegments; j ++ ) {\n\n\t\t\t\tfor ( let i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t\t\tconst a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\t\tconst b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\t\tconst c = ( radialSegments + 1 ) * j + i;\n\t\t\t\t\tconst d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateUVs() {\n\n\t\t\tfor ( let i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\t\tfor ( let j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\t\t\tuv.x = i / tubularSegments;\n\t\t\t\t\tuv.y = j / radialSegments;\n\n\t\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.path = this.parameters.path.toJSON();\n\n\t\treturn data;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\t// This only works for built-in curves (e.g. CatmullRomCurve3).\n\t\t// User defined curves or instances of CurvePath will not be deserialized.\n\t\treturn new TubeGeometry(\n\t\t\tnew Curves[ data.path.type ]().fromJSON( data.path ),\n\t\t\tdata.tubularSegments,\n\t\t\tdata.radius,\n\t\t\tdata.radialSegments,\n\t\t\tdata.closed\n\t\t);\n\n\t}\n\n}\n\n\nexport { TubeGeometry };\n"],"mappings":"AAAA,SAASA,cAAc,QAAQ,2BAA2B;AAC1D,SAASC,sBAAsB,QAAQ,4BAA4B;AACnE,OAAO,KAAKC,MAAM,MAAM,4BAA4B;AACpD,SAASC,OAAO,QAAQ,oBAAoB;AAC5C,SAASC,OAAO,QAAQ,oBAAoB;AAE5C,MAAMC,YAAY,SAASL,cAAc,CAAC;EAEzCM,WAAW,GAAuM;IAAA,IAArMC,IAAI,uEAAG,IAAIL,MAAM,CAAE,uBAAuB,CAAE,CAAE,IAAIE,OAAO,CAAE,CAAE,CAAC,EAAE,CAAE,CAAC,EAAE,CAAC,CAAE,EAAE,IAAIA,OAAO,CAAE,CAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAE,EAAE,IAAIA,OAAO,CAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAE,CAAE;IAAA,IAAEI,eAAe,uEAAG,EAAE;IAAA,IAAEC,MAAM,uEAAG,CAAC;IAAA,IAAEC,cAAc,uEAAG,CAAC;IAAA,IAAEC,MAAM,uEAAG,KAAK;IAE9M,KAAK,EAAE;IAEP,IAAI,CAACC,IAAI,GAAG,cAAc;IAE1B,IAAI,CAACC,UAAU,GAAG;MACjBN,IAAI,EAAEA,IAAI;MACVC,eAAe,EAAEA,eAAe;MAChCC,MAAM,EAAEA,MAAM;MACdC,cAAc,EAAEA,cAAc;MAC9BC,MAAM,EAAEA;IACT,CAAC;IAED,MAAMG,MAAM,GAAGP,IAAI,CAACQ,mBAAmB,CAAEP,eAAe,EAAEG,MAAM,CAAE;;IAElE;;IAEA,IAAI,CAACK,QAAQ,GAAGF,MAAM,CAACE,QAAQ;IAC/B,IAAI,CAACC,OAAO,GAAGH,MAAM,CAACG,OAAO;IAC7B,IAAI,CAACC,SAAS,GAAGJ,MAAM,CAACI,SAAS;;IAEjC;;IAEA,MAAMC,MAAM,GAAG,IAAIf,OAAO,EAAE;IAC5B,MAAMgB,MAAM,GAAG,IAAIhB,OAAO,EAAE;IAC5B,MAAMiB,EAAE,GAAG,IAAIlB,OAAO,EAAE;IACxB,IAAImB,CAAC,GAAG,IAAIlB,OAAO,EAAE;;IAErB;;IAEA,MAAMmB,QAAQ,GAAG,EAAE;IACnB,MAAMN,OAAO,GAAG,EAAE;IAClB,MAAMO,GAAG,GAAG,EAAE;IACd,MAAMC,OAAO,GAAG,EAAE;;IAElB;;IAEAC,kBAAkB,EAAE;;IAEpB;;IAEA,IAAI,CAACC,QAAQ,CAAEF,OAAO,CAAE;IACxB,IAAI,CAACG,YAAY,CAAE,UAAU,EAAE,IAAI3B,sBAAsB,CAAEsB,QAAQ,EAAE,CAAC,CAAE,CAAE;IAC1E,IAAI,CAACK,YAAY,CAAE,QAAQ,EAAE,IAAI3B,sBAAsB,CAAEgB,OAAO,EAAE,CAAC,CAAE,CAAE;IACvE,IAAI,CAACW,YAAY,CAAE,IAAI,EAAE,IAAI3B,sBAAsB,CAAEuB,GAAG,EAAE,CAAC,CAAE,CAAE;;IAE/D;;IAEA,SAASE,kBAAkB,GAAG;MAE7B,KAAM,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGrB,eAAe,EAAEqB,CAAC,EAAG,EAAG;QAE5CC,eAAe,CAAED,CAAC,CAAE;MAErB;;MAEA;MACA;MACA;MACA;;MAEAC,eAAe,CAAInB,MAAM,KAAK,KAAK,GAAKH,eAAe,GAAG,CAAC,CAAE;;MAE7D;MACA;;MAEAuB,WAAW,EAAE;;MAEb;;MAEAC,eAAe,EAAE;IAElB;IAEA,SAASF,eAAe,CAAED,CAAC,EAAG;MAE7B;;MAEAP,CAAC,GAAGf,IAAI,CAAC0B,UAAU,CAAEJ,CAAC,GAAGrB,eAAe,EAAEc,CAAC,CAAE;;MAE7C;;MAEA,MAAMY,CAAC,GAAGpB,MAAM,CAACG,OAAO,CAAEY,CAAC,CAAE;MAC7B,MAAMM,CAAC,GAAGrB,MAAM,CAACI,SAAS,CAAEW,CAAC,CAAE;;MAE/B;;MAEA,KAAM,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI1B,cAAc,EAAE0B,CAAC,EAAG,EAAG;QAE5C,MAAMC,CAAC,GAAGD,CAAC,GAAG1B,cAAc,GAAG4B,IAAI,CAACC,EAAE,GAAG,CAAC;QAE1C,MAAMC,GAAG,GAAGF,IAAI,CAACE,GAAG,CAAEH,CAAC,CAAE;QACzB,MAAMI,GAAG,GAAG,CAAEH,IAAI,CAACG,GAAG,CAAEJ,CAAC,CAAE;;QAE3B;;QAEAjB,MAAM,CAACsB,CAAC,GAAKD,GAAG,GAAGP,CAAC,CAACQ,CAAC,GAAGF,GAAG,GAAGL,CAAC,CAACO,CAAG;QACpCtB,MAAM,CAACuB,CAAC,GAAKF,GAAG,GAAGP,CAAC,CAACS,CAAC,GAAGH,GAAG,GAAGL,CAAC,CAACQ,CAAG;QACpCvB,MAAM,CAACwB,CAAC,GAAKH,GAAG,GAAGP,CAAC,CAACU,CAAC,GAAGJ,GAAG,GAAGL,CAAC,CAACS,CAAG;QACpCxB,MAAM,CAACyB,SAAS,EAAE;QAElB5B,OAAO,CAAC6B,IAAI,CAAE1B,MAAM,CAACsB,CAAC,EAAEtB,MAAM,CAACuB,CAAC,EAAEvB,MAAM,CAACwB,CAAC,CAAE;;QAE5C;;QAEAzB,MAAM,CAACuB,CAAC,GAAGpB,CAAC,CAACoB,CAAC,GAAGjC,MAAM,GAAGW,MAAM,CAACsB,CAAC;QAClCvB,MAAM,CAACwB,CAAC,GAAGrB,CAAC,CAACqB,CAAC,GAAGlC,MAAM,GAAGW,MAAM,CAACuB,CAAC;QAClCxB,MAAM,CAACyB,CAAC,GAAGtB,CAAC,CAACsB,CAAC,GAAGnC,MAAM,GAAGW,MAAM,CAACwB,CAAC;QAElCrB,QAAQ,CAACuB,IAAI,CAAE3B,MAAM,CAACuB,CAAC,EAAEvB,MAAM,CAACwB,CAAC,EAAExB,MAAM,CAACyB,CAAC,CAAE;MAE9C;IAED;IAEA,SAASZ,eAAe,GAAG;MAE1B,KAAM,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI5B,eAAe,EAAE4B,CAAC,EAAG,EAAG;QAE7C,KAAM,IAAIP,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAInB,cAAc,EAAEmB,CAAC,EAAG,EAAG;UAE5C,MAAMkB,CAAC,GAAG,CAAErC,cAAc,GAAG,CAAC,KAAO0B,CAAC,GAAG,CAAC,CAAE,IAAKP,CAAC,GAAG,CAAC,CAAE;UACxD,MAAMmB,CAAC,GAAG,CAAEtC,cAAc,GAAG,CAAC,IAAK0B,CAAC,IAAKP,CAAC,GAAG,CAAC,CAAE;UAChD,MAAMoB,CAAC,GAAG,CAAEvC,cAAc,GAAG,CAAC,IAAK0B,CAAC,GAAGP,CAAC;UACxC,MAAMqB,CAAC,GAAG,CAAExC,cAAc,GAAG,CAAC,KAAO0B,CAAC,GAAG,CAAC,CAAE,GAAGP,CAAC;;UAEhD;;UAEAJ,OAAO,CAACqB,IAAI,CAAEC,CAAC,EAAEC,CAAC,EAAEE,CAAC,CAAE;UACvBzB,OAAO,CAACqB,IAAI,CAAEE,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAE;QAExB;MAED;IAED;IAEA,SAASnB,WAAW,GAAG;MAEtB,KAAM,IAAIF,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIrB,eAAe,EAAEqB,CAAC,EAAG,EAAG;QAE7C,KAAM,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI1B,cAAc,EAAE0B,CAAC,EAAG,EAAG;UAE5Cf,EAAE,CAACqB,CAAC,GAAGb,CAAC,GAAGrB,eAAe;UAC1Ba,EAAE,CAACsB,CAAC,GAAGP,CAAC,GAAG1B,cAAc;UAEzBc,GAAG,CAACsB,IAAI,CAAEzB,EAAE,CAACqB,CAAC,EAAErB,EAAE,CAACsB,CAAC,CAAE;QAEvB;MAED;IAED;EAED;EAEAQ,MAAM,GAAG;IAER,MAAMC,IAAI,GAAG,KAAK,CAACD,MAAM,EAAE;IAE3BC,IAAI,CAAC7C,IAAI,GAAG,IAAI,CAACM,UAAU,CAACN,IAAI,CAAC4C,MAAM,EAAE;IAEzC,OAAOC,IAAI;EAEZ;EAEA,OAAOC,QAAQ,CAAED,IAAI,EAAG;IAEvB;IACA;IACA,OAAO,IAAI/C,YAAY,CACtB,IAAIH,MAAM,CAAEkD,IAAI,CAAC7C,IAAI,CAACK,IAAI,CAAE,EAAE,CAACyC,QAAQ,CAAED,IAAI,CAAC7C,IAAI,CAAE,EACpD6C,IAAI,CAAC5C,eAAe,EACpB4C,IAAI,CAAC3C,MAAM,EACX2C,IAAI,CAAC1C,cAAc,EACnB0C,IAAI,CAACzC,MAAM,CACX;EAEF;AAED;AAGA,SAASN,YAAY"},"metadata":{},"sourceType":"module","externalDependencies":[]}