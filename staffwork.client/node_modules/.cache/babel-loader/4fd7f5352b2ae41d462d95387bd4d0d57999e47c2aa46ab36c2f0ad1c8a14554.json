{"ast":null,"code":"import { FrontSide, BackSide, DoubleSide, NearestFilter, PCFShadowMap, VSMShadowMap, RGBADepthPacking, NoBlending } from '../../constants.js';\nimport { WebGLRenderTarget } from '../WebGLRenderTarget.js';\nimport { MeshDepthMaterial } from '../../materials/MeshDepthMaterial.js';\nimport { MeshDistanceMaterial } from '../../materials/MeshDistanceMaterial.js';\nimport { ShaderMaterial } from '../../materials/ShaderMaterial.js';\nimport { BufferAttribute } from '../../core/BufferAttribute.js';\nimport { BufferGeometry } from '../../core/BufferGeometry.js';\nimport { Mesh } from '../../objects/Mesh.js';\nimport { Vector4 } from '../../math/Vector4.js';\nimport { Vector2 } from '../../math/Vector2.js';\nimport { Frustum } from '../../math/Frustum.js';\nimport * as vsm from '../shaders/ShaderLib/vsm.glsl.js';\nfunction WebGLShadowMap(_renderer, _objects, _capabilities) {\n  let _frustum = new Frustum();\n  const _shadowMapSize = new Vector2(),\n    _viewportSize = new Vector2(),\n    _viewport = new Vector4(),\n    _depthMaterial = new MeshDepthMaterial({\n      depthPacking: RGBADepthPacking\n    }),\n    _distanceMaterial = new MeshDistanceMaterial(),\n    _materialCache = {},\n    _maxTextureSize = _capabilities.maxTextureSize;\n  const shadowSide = {\n    0: BackSide,\n    1: FrontSide,\n    2: DoubleSide\n  };\n  const shadowMaterialVertical = new ShaderMaterial({\n    defines: {\n      VSM_SAMPLES: 8\n    },\n    uniforms: {\n      shadow_pass: {\n        value: null\n      },\n      resolution: {\n        value: new Vector2()\n      },\n      radius: {\n        value: 4.0\n      }\n    },\n    vertexShader: vsm.vertex,\n    fragmentShader: vsm.fragment\n  });\n  const shadowMaterialHorizontal = shadowMaterialVertical.clone();\n  shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;\n  const fullScreenTri = new BufferGeometry();\n  fullScreenTri.setAttribute('position', new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));\n  const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);\n  const scope = this;\n  this.enabled = false;\n  this.autoUpdate = true;\n  this.needsUpdate = false;\n  this.type = PCFShadowMap;\n  this.render = function (lights, scene, camera) {\n    if (scope.enabled === false) return;\n    if (scope.autoUpdate === false && scope.needsUpdate === false) return;\n    if (lights.length === 0) return;\n    const currentRenderTarget = _renderer.getRenderTarget();\n    const activeCubeFace = _renderer.getActiveCubeFace();\n    const activeMipmapLevel = _renderer.getActiveMipmapLevel();\n    const _state = _renderer.state;\n\n    // Set GL state for depth map.\n    _state.setBlending(NoBlending);\n    _state.buffers.color.setClear(1, 1, 1, 1);\n    _state.buffers.depth.setTest(true);\n    _state.setScissorTest(false);\n\n    // render depth map\n\n    for (let i = 0, il = lights.length; i < il; i++) {\n      const light = lights[i];\n      const shadow = light.shadow;\n      if (shadow === undefined) {\n        console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');\n        continue;\n      }\n      if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;\n      _shadowMapSize.copy(shadow.mapSize);\n      const shadowFrameExtents = shadow.getFrameExtents();\n      _shadowMapSize.multiply(shadowFrameExtents);\n      _viewportSize.copy(shadow.mapSize);\n      if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {\n        if (_shadowMapSize.x > _maxTextureSize) {\n          _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);\n          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;\n          shadow.mapSize.x = _viewportSize.x;\n        }\n        if (_shadowMapSize.y > _maxTextureSize) {\n          _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);\n          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;\n          shadow.mapSize.y = _viewportSize.y;\n        }\n      }\n      if (shadow.map === null) {\n        const pars = this.type !== VSMShadowMap ? {\n          minFilter: NearestFilter,\n          magFilter: NearestFilter\n        } : {};\n        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);\n        shadow.map.texture.name = light.name + '.shadowMap';\n        shadow.camera.updateProjectionMatrix();\n      }\n      _renderer.setRenderTarget(shadow.map);\n      _renderer.clear();\n      const viewportCount = shadow.getViewportCount();\n      for (let vp = 0; vp < viewportCount; vp++) {\n        const viewport = shadow.getViewport(vp);\n        _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);\n        _state.viewport(_viewport);\n        shadow.updateMatrices(light, vp);\n        _frustum = shadow.getFrustum();\n        renderObject(scene, camera, shadow.camera, light, this.type);\n      }\n\n      // do blur pass for VSM\n\n      if (shadow.isPointLightShadow !== true && this.type === VSMShadowMap) {\n        VSMPass(shadow, camera);\n      }\n      shadow.needsUpdate = false;\n    }\n    scope.needsUpdate = false;\n    _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);\n  };\n  function VSMPass(shadow, camera) {\n    const geometry = _objects.update(fullScreenMesh);\n    if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {\n      shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;\n      shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;\n      shadowMaterialVertical.needsUpdate = true;\n      shadowMaterialHorizontal.needsUpdate = true;\n    }\n    if (shadow.mapPass === null) {\n      shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y);\n    }\n\n    // vertical pass\n\n    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;\n    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;\n    shadowMaterialVertical.uniforms.radius.value = shadow.radius;\n    _renderer.setRenderTarget(shadow.mapPass);\n    _renderer.clear();\n    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);\n\n    // horizontal pass\n\n    shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;\n    shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;\n    shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;\n    _renderer.setRenderTarget(shadow.map);\n    _renderer.clear();\n    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);\n  }\n  function getDepthMaterial(object, material, light, shadowCameraNear, shadowCameraFar, type) {\n    let result = null;\n    const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;\n    if (customMaterial !== undefined) {\n      result = customMaterial;\n    } else {\n      result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;\n    }\n    if (_renderer.localClippingEnabled && material.clipShadows === true && Array.isArray(material.clippingPlanes) && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0 || material.map && material.alphaTest > 0) {\n      // in this case we need a unique material instance reflecting the\n      // appropriate state\n\n      const keyA = result.uuid,\n        keyB = material.uuid;\n      let materialsForVariant = _materialCache[keyA];\n      if (materialsForVariant === undefined) {\n        materialsForVariant = {};\n        _materialCache[keyA] = materialsForVariant;\n      }\n      let cachedMaterial = materialsForVariant[keyB];\n      if (cachedMaterial === undefined) {\n        cachedMaterial = result.clone();\n        materialsForVariant[keyB] = cachedMaterial;\n      }\n      result = cachedMaterial;\n    }\n    result.visible = material.visible;\n    result.wireframe = material.wireframe;\n    if (type === VSMShadowMap) {\n      result.side = material.shadowSide !== null ? material.shadowSide : material.side;\n    } else {\n      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];\n    }\n    result.alphaMap = material.alphaMap;\n    result.alphaTest = material.alphaTest;\n    result.map = material.map;\n    result.clipShadows = material.clipShadows;\n    result.clippingPlanes = material.clippingPlanes;\n    result.clipIntersection = material.clipIntersection;\n    result.displacementMap = material.displacementMap;\n    result.displacementScale = material.displacementScale;\n    result.displacementBias = material.displacementBias;\n    result.wireframeLinewidth = material.wireframeLinewidth;\n    result.linewidth = material.linewidth;\n    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {\n      result.referencePosition.setFromMatrixPosition(light.matrixWorld);\n      result.nearDistance = shadowCameraNear;\n      result.farDistance = shadowCameraFar;\n    }\n    return result;\n  }\n  function renderObject(object, camera, shadowCamera, light, type) {\n    if (object.visible === false) return;\n    const visible = object.layers.test(camera.layers);\n    if (visible && (object.isMesh || object.isLine || object.isPoints)) {\n      if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {\n        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);\n        const geometry = _objects.update(object);\n        const material = object.material;\n        if (Array.isArray(material)) {\n          const groups = geometry.groups;\n          for (let k = 0, kl = groups.length; k < kl; k++) {\n            const group = groups[k];\n            const groupMaterial = material[group.materialIndex];\n            if (groupMaterial && groupMaterial.visible) {\n              const depthMaterial = getDepthMaterial(object, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);\n              _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);\n            }\n          }\n        } else if (material.visible) {\n          const depthMaterial = getDepthMaterial(object, material, light, shadowCamera.near, shadowCamera.far, type);\n          _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);\n        }\n      }\n    }\n    const children = object.children;\n    for (let i = 0, l = children.length; i < l; i++) {\n      renderObject(children[i], camera, shadowCamera, light, type);\n    }\n  }\n}\nexport { WebGLShadowMap };","map":{"version":3,"names":["FrontSide","BackSide","DoubleSide","NearestFilter","PCFShadowMap","VSMShadowMap","RGBADepthPacking","NoBlending","WebGLRenderTarget","MeshDepthMaterial","MeshDistanceMaterial","ShaderMaterial","BufferAttribute","BufferGeometry","Mesh","Vector4","Vector2","Frustum","vsm","WebGLShadowMap","_renderer","_objects","_capabilities","_frustum","_shadowMapSize","_viewportSize","_viewport","_depthMaterial","depthPacking","_distanceMaterial","_materialCache","_maxTextureSize","maxTextureSize","shadowSide","shadowMaterialVertical","defines","VSM_SAMPLES","uniforms","shadow_pass","value","resolution","radius","vertexShader","vertex","fragmentShader","fragment","shadowMaterialHorizontal","clone","HORIZONTAL_PASS","fullScreenTri","setAttribute","Float32Array","fullScreenMesh","scope","enabled","autoUpdate","needsUpdate","type","render","lights","scene","camera","length","currentRenderTarget","getRenderTarget","activeCubeFace","getActiveCubeFace","activeMipmapLevel","getActiveMipmapLevel","_state","state","setBlending","buffers","color","setClear","depth","setTest","setScissorTest","i","il","light","shadow","undefined","console","warn","copy","mapSize","shadowFrameExtents","getFrameExtents","multiply","x","y","Math","floor","map","pars","minFilter","magFilter","texture","name","updateProjectionMatrix","setRenderTarget","clear","viewportCount","getViewportCount","vp","viewport","getViewport","set","z","w","updateMatrices","getFrustum","renderObject","isPointLightShadow","VSMPass","geometry","update","blurSamples","mapPass","renderBufferDirect","getDepthMaterial","object","material","shadowCameraNear","shadowCameraFar","result","customMaterial","isPointLight","customDistanceMaterial","customDepthMaterial","localClippingEnabled","clipShadows","Array","isArray","clippingPlanes","displacementMap","displacementScale","alphaMap","alphaTest","keyA","uuid","keyB","materialsForVariant","cachedMaterial","visible","wireframe","side","clipIntersection","displacementBias","wireframeLinewidth","linewidth","isMeshDistanceMaterial","referencePosition","setFromMatrixPosition","matrixWorld","nearDistance","farDistance","shadowCamera","layers","test","isMesh","isLine","isPoints","castShadow","receiveShadow","frustumCulled","intersectsObject","modelViewMatrix","multiplyMatrices","matrixWorldInverse","groups","k","kl","group","groupMaterial","materialIndex","depthMaterial","near","far","children","l"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/renderers/webgl/WebGLShadowMap.js"],"sourcesContent":["import { FrontSide, BackSide, DoubleSide, NearestFilter, PCFShadowMap, VSMShadowMap, RGBADepthPacking, NoBlending } from '../../constants.js';\nimport { WebGLRenderTarget } from '../WebGLRenderTarget.js';\nimport { MeshDepthMaterial } from '../../materials/MeshDepthMaterial.js';\nimport { MeshDistanceMaterial } from '../../materials/MeshDistanceMaterial.js';\nimport { ShaderMaterial } from '../../materials/ShaderMaterial.js';\nimport { BufferAttribute } from '../../core/BufferAttribute.js';\nimport { BufferGeometry } from '../../core/BufferGeometry.js';\nimport { Mesh } from '../../objects/Mesh.js';\nimport { Vector4 } from '../../math/Vector4.js';\nimport { Vector2 } from '../../math/Vector2.js';\nimport { Frustum } from '../../math/Frustum.js';\n\nimport * as vsm from '../shaders/ShaderLib/vsm.glsl.js';\n\nfunction WebGLShadowMap( _renderer, _objects, _capabilities ) {\n\n\tlet _frustum = new Frustum();\n\n\tconst _shadowMapSize = new Vector2(),\n\t\t_viewportSize = new Vector2(),\n\n\t\t_viewport = new Vector4(),\n\n\t\t_depthMaterial = new MeshDepthMaterial( { depthPacking: RGBADepthPacking } ),\n\t\t_distanceMaterial = new MeshDistanceMaterial(),\n\n\t\t_materialCache = {},\n\n\t\t_maxTextureSize = _capabilities.maxTextureSize;\n\n\tconst shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };\n\n\tconst shadowMaterialVertical = new ShaderMaterial( {\n\t\tdefines: {\n\t\t\tVSM_SAMPLES: 8\n\t\t},\n\t\tuniforms: {\n\t\t\tshadow_pass: { value: null },\n\t\t\tresolution: { value: new Vector2() },\n\t\t\tradius: { value: 4.0 }\n\t\t},\n\n\t\tvertexShader: vsm.vertex,\n\t\tfragmentShader: vsm.fragment\n\n\t} );\n\n\tconst shadowMaterialHorizontal = shadowMaterialVertical.clone();\n\tshadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;\n\n\tconst fullScreenTri = new BufferGeometry();\n\tfullScreenTri.setAttribute(\n\t\t'position',\n\t\tnew BufferAttribute(\n\t\t\tnew Float32Array( [ - 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5 ] ),\n\t\t\t3\n\t\t)\n\t);\n\n\tconst fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );\n\n\tconst scope = this;\n\n\tthis.enabled = false;\n\n\tthis.autoUpdate = true;\n\tthis.needsUpdate = false;\n\n\tthis.type = PCFShadowMap;\n\n\tthis.render = function ( lights, scene, camera ) {\n\n\t\tif ( scope.enabled === false ) return;\n\t\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\n\n\t\tif ( lights.length === 0 ) return;\n\n\t\tconst currentRenderTarget = _renderer.getRenderTarget();\n\t\tconst activeCubeFace = _renderer.getActiveCubeFace();\n\t\tconst activeMipmapLevel = _renderer.getActiveMipmapLevel();\n\n\t\tconst _state = _renderer.state;\n\n\t\t// Set GL state for depth map.\n\t\t_state.setBlending( NoBlending );\n\t\t_state.buffers.color.setClear( 1, 1, 1, 1 );\n\t\t_state.buffers.depth.setTest( true );\n\t\t_state.setScissorTest( false );\n\n\t\t// render depth map\n\n\t\tfor ( let i = 0, il = lights.length; i < il; i ++ ) {\n\n\t\t\tconst light = lights[ i ];\n\t\t\tconst shadow = light.shadow;\n\n\t\t\tif ( shadow === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( shadow.autoUpdate === false && shadow.needsUpdate === false ) continue;\n\n\t\t\t_shadowMapSize.copy( shadow.mapSize );\n\n\t\t\tconst shadowFrameExtents = shadow.getFrameExtents();\n\n\t\t\t_shadowMapSize.multiply( shadowFrameExtents );\n\n\t\t\t_viewportSize.copy( shadow.mapSize );\n\n\t\t\tif ( _shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize ) {\n\n\t\t\t\tif ( _shadowMapSize.x > _maxTextureSize ) {\n\n\t\t\t\t\t_viewportSize.x = Math.floor( _maxTextureSize / shadowFrameExtents.x );\n\t\t\t\t\t_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;\n\t\t\t\t\tshadow.mapSize.x = _viewportSize.x;\n\n\t\t\t\t}\n\n\t\t\t\tif ( _shadowMapSize.y > _maxTextureSize ) {\n\n\t\t\t\t\t_viewportSize.y = Math.floor( _maxTextureSize / shadowFrameExtents.y );\n\t\t\t\t\t_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;\n\t\t\t\t\tshadow.mapSize.y = _viewportSize.y;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( shadow.map === null ) {\n\n\t\t\t\tconst pars = ( this.type !== VSMShadowMap ) ? { minFilter: NearestFilter, magFilter: NearestFilter } : {};\n\n\t\t\t\tshadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\n\t\t\t\tshadow.map.texture.name = light.name + '.shadowMap';\n\n\t\t\t\tshadow.camera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\t_renderer.setRenderTarget( shadow.map );\n\t\t\t_renderer.clear();\n\n\t\t\tconst viewportCount = shadow.getViewportCount();\n\n\t\t\tfor ( let vp = 0; vp < viewportCount; vp ++ ) {\n\n\t\t\t\tconst viewport = shadow.getViewport( vp );\n\n\t\t\t\t_viewport.set(\n\t\t\t\t\t_viewportSize.x * viewport.x,\n\t\t\t\t\t_viewportSize.y * viewport.y,\n\t\t\t\t\t_viewportSize.x * viewport.z,\n\t\t\t\t\t_viewportSize.y * viewport.w\n\t\t\t\t);\n\n\t\t\t\t_state.viewport( _viewport );\n\n\t\t\t\tshadow.updateMatrices( light, vp );\n\n\t\t\t\t_frustum = shadow.getFrustum();\n\n\t\t\t\trenderObject( scene, camera, shadow.camera, light, this.type );\n\n\t\t\t}\n\n\t\t\t// do blur pass for VSM\n\n\t\t\tif ( shadow.isPointLightShadow !== true && this.type === VSMShadowMap ) {\n\n\t\t\t\tVSMPass( shadow, camera );\n\n\t\t\t}\n\n\t\t\tshadow.needsUpdate = false;\n\n\t\t}\n\n\t\tscope.needsUpdate = false;\n\n\t\t_renderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );\n\n\t};\n\n\tfunction VSMPass( shadow, camera ) {\n\n\t\tconst geometry = _objects.update( fullScreenMesh );\n\n\t\tif ( shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples ) {\n\n\t\t\tshadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;\n\t\t\tshadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;\n\n\t\t\tshadowMaterialVertical.needsUpdate = true;\n\t\t\tshadowMaterialHorizontal.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( shadow.mapPass === null ) {\n\n\t\t\tshadow.mapPass = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y );\n\n\t\t}\n\n\t\t// vertical pass\n\n\t\tshadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;\n\t\tshadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;\n\t\tshadowMaterialVertical.uniforms.radius.value = shadow.radius;\n\t\t_renderer.setRenderTarget( shadow.mapPass );\n\t\t_renderer.clear();\n\t\t_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );\n\n\t\t// horizontal pass\n\n\t\tshadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;\n\t\tshadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;\n\t\tshadowMaterialHorizontal.uniforms.radius.value = shadow.radius;\n\t\t_renderer.setRenderTarget( shadow.map );\n\t\t_renderer.clear();\n\t\t_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null );\n\n\t}\n\n\tfunction getDepthMaterial( object, material, light, shadowCameraNear, shadowCameraFar, type ) {\n\n\t\tlet result = null;\n\n\t\tconst customMaterial = ( light.isPointLight === true ) ? object.customDistanceMaterial : object.customDepthMaterial;\n\n\t\tif ( customMaterial !== undefined ) {\n\n\t\t\tresult = customMaterial;\n\n\t\t} else {\n\n\t\t\tresult = ( light.isPointLight === true ) ? _distanceMaterial : _depthMaterial;\n\n\t\t}\n\n\t\tif ( ( _renderer.localClippingEnabled && material.clipShadows === true && Array.isArray( material.clippingPlanes ) && material.clippingPlanes.length !== 0 ) ||\n\t\t\t( material.displacementMap && material.displacementScale !== 0 ) ||\n\t\t\t( material.alphaMap && material.alphaTest > 0 ) ||\n\t\t\t( material.map && material.alphaTest > 0 ) ) {\n\n\t\t\t// in this case we need a unique material instance reflecting the\n\t\t\t// appropriate state\n\n\t\t\tconst keyA = result.uuid, keyB = material.uuid;\n\n\t\t\tlet materialsForVariant = _materialCache[ keyA ];\n\n\t\t\tif ( materialsForVariant === undefined ) {\n\n\t\t\t\tmaterialsForVariant = {};\n\t\t\t\t_materialCache[ keyA ] = materialsForVariant;\n\n\t\t\t}\n\n\t\t\tlet cachedMaterial = materialsForVariant[ keyB ];\n\n\t\t\tif ( cachedMaterial === undefined ) {\n\n\t\t\t\tcachedMaterial = result.clone();\n\t\t\t\tmaterialsForVariant[ keyB ] = cachedMaterial;\n\n\t\t\t}\n\n\t\t\tresult = cachedMaterial;\n\n\t\t}\n\n\t\tresult.visible = material.visible;\n\t\tresult.wireframe = material.wireframe;\n\n\t\tif ( type === VSMShadowMap ) {\n\n\t\t\tresult.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;\n\n\t\t} else {\n\n\t\t\tresult.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];\n\n\t\t}\n\n\t\tresult.alphaMap = material.alphaMap;\n\t\tresult.alphaTest = material.alphaTest;\n\t\tresult.map = material.map;\n\n\t\tresult.clipShadows = material.clipShadows;\n\t\tresult.clippingPlanes = material.clippingPlanes;\n\t\tresult.clipIntersection = material.clipIntersection;\n\n\t\tresult.displacementMap = material.displacementMap;\n\t\tresult.displacementScale = material.displacementScale;\n\t\tresult.displacementBias = material.displacementBias;\n\n\t\tresult.wireframeLinewidth = material.wireframeLinewidth;\n\t\tresult.linewidth = material.linewidth;\n\n\t\tif ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {\n\n\t\t\tresult.referencePosition.setFromMatrixPosition( light.matrixWorld );\n\t\t\tresult.nearDistance = shadowCameraNear;\n\t\t\tresult.farDistance = shadowCameraFar;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tfunction renderObject( object, camera, shadowCamera, light, type ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tconst visible = object.layers.test( camera.layers );\n\n\t\tif ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {\n\n\t\t\tif ( ( object.castShadow || ( object.receiveShadow && type === VSMShadowMap ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {\n\n\t\t\t\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\n\t\t\t\tconst geometry = _objects.update( object );\n\t\t\t\tconst material = object.material;\n\n\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\tconst groups = geometry.groups;\n\n\t\t\t\t\tfor ( let k = 0, kl = groups.length; k < kl; k ++ ) {\n\n\t\t\t\t\t\tconst group = groups[ k ];\n\t\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\tif ( groupMaterial && groupMaterial.visible ) {\n\n\t\t\t\t\t\t\tconst depthMaterial = getDepthMaterial( object, groupMaterial, light, shadowCamera.near, shadowCamera.far, type );\n\n\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( material.visible ) {\n\n\t\t\t\t\tconst depthMaterial = getDepthMaterial( object, material, light, shadowCamera.near, shadowCamera.far, type );\n\n\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\trenderObject( children[ i ], camera, shadowCamera, light, type );\n\n\t\t}\n\n\t}\n\n}\n\n\nexport { WebGLShadowMap };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}