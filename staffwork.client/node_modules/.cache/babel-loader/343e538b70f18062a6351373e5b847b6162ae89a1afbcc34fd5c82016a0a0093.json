{"ast":null,"code":"import { BackSide, LinearFilter, LinearMipmapLinearFilter, NoBlending } from '../constants.js';\nimport { Mesh } from '../objects/Mesh.js';\nimport { BoxGeometry } from '../geometries/BoxGeometry.js';\nimport { ShaderMaterial } from '../materials/ShaderMaterial.js';\nimport { cloneUniforms } from './shaders/UniformsUtils.js';\nimport { WebGLRenderTarget } from './WebGLRenderTarget.js';\nimport { CubeCamera } from '../cameras/CubeCamera.js';\nimport { CubeTexture } from '../textures/CubeTexture.js';\nclass WebGLCubeRenderTarget extends WebGLRenderTarget {\n  constructor() {\n    let size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(size, size, options);\n    this.isWebGLCubeRenderTarget = true;\n    const image = {\n      width: size,\n      height: size,\n      depth: 1\n    };\n    const images = [image, image, image, image, image, image];\n    this.texture = new CubeTexture(images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);\n\n    // By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)\n    // in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,\n    // in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.\n\n    // three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped\n    // and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture\n    // as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).\n\n    this.texture.isRenderTargetTexture = true;\n    this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;\n    this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;\n  }\n  fromEquirectangularTexture(renderer, texture) {\n    this.texture.type = texture.type;\n    this.texture.encoding = texture.encoding;\n    this.texture.generateMipmaps = texture.generateMipmaps;\n    this.texture.minFilter = texture.minFilter;\n    this.texture.magFilter = texture.magFilter;\n    const shader = {\n      uniforms: {\n        tEquirect: {\n          value: null\n        }\n      },\n      vertexShader: /* glsl */`\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t`,\n      fragmentShader: /* glsl */`\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t`\n    };\n    const geometry = new BoxGeometry(5, 5, 5);\n    const material = new ShaderMaterial({\n      name: 'CubemapFromEquirect',\n      uniforms: cloneUniforms(shader.uniforms),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      side: BackSide,\n      blending: NoBlending\n    });\n    material.uniforms.tEquirect.value = texture;\n    const mesh = new Mesh(geometry, material);\n    const currentMinFilter = texture.minFilter;\n\n    // Avoid blurred poles\n    if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;\n    const camera = new CubeCamera(1, 10, this);\n    camera.update(renderer, mesh);\n    texture.minFilter = currentMinFilter;\n    mesh.geometry.dispose();\n    mesh.material.dispose();\n    return this;\n  }\n  clear(renderer, color, depth, stencil) {\n    const currentRenderTarget = renderer.getRenderTarget();\n    for (let i = 0; i < 6; i++) {\n      renderer.setRenderTarget(this, i);\n      renderer.clear(color, depth, stencil);\n    }\n    renderer.setRenderTarget(currentRenderTarget);\n  }\n}\nexport { WebGLCubeRenderTarget };","map":{"version":3,"names":["BackSide","LinearFilter","LinearMipmapLinearFilter","NoBlending","Mesh","BoxGeometry","ShaderMaterial","cloneUniforms","WebGLRenderTarget","CubeCamera","CubeTexture","WebGLCubeRenderTarget","constructor","size","options","isWebGLCubeRenderTarget","image","width","height","depth","images","texture","mapping","wrapS","wrapT","magFilter","minFilter","format","type","anisotropy","encoding","isRenderTargetTexture","generateMipmaps","undefined","fromEquirectangularTexture","renderer","shader","uniforms","tEquirect","value","vertexShader","fragmentShader","geometry","material","name","side","blending","mesh","currentMinFilter","camera","update","dispose","clear","color","stencil","currentRenderTarget","getRenderTarget","i","setRenderTarget"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/renderers/WebGLCubeRenderTarget.js"],"sourcesContent":["import { BackSide, LinearFilter, LinearMipmapLinearFilter, NoBlending } from '../constants.js';\nimport { Mesh } from '../objects/Mesh.js';\nimport { BoxGeometry } from '../geometries/BoxGeometry.js';\nimport { ShaderMaterial } from '../materials/ShaderMaterial.js';\nimport { cloneUniforms } from './shaders/UniformsUtils.js';\nimport { WebGLRenderTarget } from './WebGLRenderTarget.js';\nimport { CubeCamera } from '../cameras/CubeCamera.js';\nimport { CubeTexture } from '../textures/CubeTexture.js';\n\nclass WebGLCubeRenderTarget extends WebGLRenderTarget {\n\n\tconstructor( size = 1, options = {} ) {\n\n\t\tsuper( size, size, options );\n\n\t\tthis.isWebGLCubeRenderTarget = true;\n\n\t\tconst image = { width: size, height: size, depth: 1 };\n\t\tconst images = [ image, image, image, image, image, image ];\n\n\t\tthis.texture = new CubeTexture( images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );\n\n\t\t// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)\n\t\t// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,\n\t\t// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.\n\n\t\t// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped\n\t\t// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture\n\t\t// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).\n\n\t\tthis.texture.isRenderTargetTexture = true;\n\n\t\tthis.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;\n\t\tthis.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;\n\n\t}\n\n\tfromEquirectangularTexture( renderer, texture ) {\n\n\t\tthis.texture.type = texture.type;\n\t\tthis.texture.encoding = texture.encoding;\n\n\t\tthis.texture.generateMipmaps = texture.generateMipmaps;\n\t\tthis.texture.minFilter = texture.minFilter;\n\t\tthis.texture.magFilter = texture.magFilter;\n\n\t\tconst shader = {\n\n\t\t\tuniforms: {\n\t\t\t\ttEquirect: { value: null },\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t`\n\t\t};\n\n\t\tconst geometry = new BoxGeometry( 5, 5, 5 );\n\n\t\tconst material = new ShaderMaterial( {\n\n\t\t\tname: 'CubemapFromEquirect',\n\n\t\t\tuniforms: cloneUniforms( shader.uniforms ),\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tside: BackSide,\n\t\t\tblending: NoBlending\n\n\t\t} );\n\n\t\tmaterial.uniforms.tEquirect.value = texture;\n\n\t\tconst mesh = new Mesh( geometry, material );\n\n\t\tconst currentMinFilter = texture.minFilter;\n\n\t\t// Avoid blurred poles\n\t\tif ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;\n\n\t\tconst camera = new CubeCamera( 1, 10, this );\n\t\tcamera.update( renderer, mesh );\n\n\t\ttexture.minFilter = currentMinFilter;\n\n\t\tmesh.geometry.dispose();\n\t\tmesh.material.dispose();\n\n\t\treturn this;\n\n\t}\n\n\tclear( renderer, color, depth, stencil ) {\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\trenderer.setRenderTarget( this, i );\n\n\t\t\trenderer.clear( color, depth, stencil );\n\n\t\t}\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t}\n\n}\n\nexport { WebGLCubeRenderTarget };\n"],"mappings":"AAAA,SAASA,QAAQ,EAAEC,YAAY,EAAEC,wBAAwB,EAAEC,UAAU,QAAQ,iBAAiB;AAC9F,SAASC,IAAI,QAAQ,oBAAoB;AACzC,SAASC,WAAW,QAAQ,8BAA8B;AAC1D,SAASC,cAAc,QAAQ,gCAAgC;AAC/D,SAASC,aAAa,QAAQ,4BAA4B;AAC1D,SAASC,iBAAiB,QAAQ,wBAAwB;AAC1D,SAASC,UAAU,QAAQ,0BAA0B;AACrD,SAASC,WAAW,QAAQ,4BAA4B;AAExD,MAAMC,qBAAqB,SAASH,iBAAiB,CAAC;EAErDI,WAAW,GAA2B;IAAA,IAAzBC,IAAI,uEAAG,CAAC;IAAA,IAAEC,OAAO,uEAAG,CAAC,CAAC;IAElC,KAAK,CAAED,IAAI,EAAEA,IAAI,EAAEC,OAAO,CAAE;IAE5B,IAAI,CAACC,uBAAuB,GAAG,IAAI;IAEnC,MAAMC,KAAK,GAAG;MAAEC,KAAK,EAAEJ,IAAI;MAAEK,MAAM,EAAEL,IAAI;MAAEM,KAAK,EAAE;IAAE,CAAC;IACrD,MAAMC,MAAM,GAAG,CAAEJ,KAAK,EAAEA,KAAK,EAAEA,KAAK,EAAEA,KAAK,EAAEA,KAAK,EAAEA,KAAK,CAAE;IAE3D,IAAI,CAACK,OAAO,GAAG,IAAIX,WAAW,CAAEU,MAAM,EAAEN,OAAO,CAACQ,OAAO,EAAER,OAAO,CAACS,KAAK,EAAET,OAAO,CAACU,KAAK,EAAEV,OAAO,CAACW,SAAS,EAAEX,OAAO,CAACY,SAAS,EAAEZ,OAAO,CAACa,MAAM,EAAEb,OAAO,CAACc,IAAI,EAAEd,OAAO,CAACe,UAAU,EAAEf,OAAO,CAACgB,QAAQ,CAAE;;IAEjM;IACA;IACA;;IAEA;IACA;IACA;;IAEA,IAAI,CAACT,OAAO,CAACU,qBAAqB,GAAG,IAAI;IAEzC,IAAI,CAACV,OAAO,CAACW,eAAe,GAAGlB,OAAO,CAACkB,eAAe,KAAKC,SAAS,GAAGnB,OAAO,CAACkB,eAAe,GAAG,KAAK;IACtG,IAAI,CAACX,OAAO,CAACK,SAAS,GAAGZ,OAAO,CAACY,SAAS,KAAKO,SAAS,GAAGnB,OAAO,CAACY,SAAS,GAAGzB,YAAY;EAE5F;EAEAiC,0BAA0B,CAAEC,QAAQ,EAAEd,OAAO,EAAG;IAE/C,IAAI,CAACA,OAAO,CAACO,IAAI,GAAGP,OAAO,CAACO,IAAI;IAChC,IAAI,CAACP,OAAO,CAACS,QAAQ,GAAGT,OAAO,CAACS,QAAQ;IAExC,IAAI,CAACT,OAAO,CAACW,eAAe,GAAGX,OAAO,CAACW,eAAe;IACtD,IAAI,CAACX,OAAO,CAACK,SAAS,GAAGL,OAAO,CAACK,SAAS;IAC1C,IAAI,CAACL,OAAO,CAACI,SAAS,GAAGJ,OAAO,CAACI,SAAS;IAE1C,MAAMW,MAAM,GAAG;MAEdC,QAAQ,EAAE;QACTC,SAAS,EAAE;UAAEC,KAAK,EAAE;QAAK;MAC1B,CAAC;MAEDC,YAAY,EAAE,UAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;MAEDC,cAAc,EAAE,UAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACE,CAAC;IAED,MAAMC,QAAQ,GAAG,IAAIrC,WAAW,CAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAE;IAE3C,MAAMsC,QAAQ,GAAG,IAAIrC,cAAc,CAAE;MAEpCsC,IAAI,EAAE,qBAAqB;MAE3BP,QAAQ,EAAE9B,aAAa,CAAE6B,MAAM,CAACC,QAAQ,CAAE;MAC1CG,YAAY,EAAEJ,MAAM,CAACI,YAAY;MACjCC,cAAc,EAAEL,MAAM,CAACK,cAAc;MACrCI,IAAI,EAAE7C,QAAQ;MACd8C,QAAQ,EAAE3C;IAEX,CAAC,CAAE;IAEHwC,QAAQ,CAACN,QAAQ,CAACC,SAAS,CAACC,KAAK,GAAGlB,OAAO;IAE3C,MAAM0B,IAAI,GAAG,IAAI3C,IAAI,CAAEsC,QAAQ,EAAEC,QAAQ,CAAE;IAE3C,MAAMK,gBAAgB,GAAG3B,OAAO,CAACK,SAAS;;IAE1C;IACA,IAAKL,OAAO,CAACK,SAAS,KAAKxB,wBAAwB,EAAGmB,OAAO,CAACK,SAAS,GAAGzB,YAAY;IAEtF,MAAMgD,MAAM,GAAG,IAAIxC,UAAU,CAAE,CAAC,EAAE,EAAE,EAAE,IAAI,CAAE;IAC5CwC,MAAM,CAACC,MAAM,CAAEf,QAAQ,EAAEY,IAAI,CAAE;IAE/B1B,OAAO,CAACK,SAAS,GAAGsB,gBAAgB;IAEpCD,IAAI,CAACL,QAAQ,CAACS,OAAO,EAAE;IACvBJ,IAAI,CAACJ,QAAQ,CAACQ,OAAO,EAAE;IAEvB,OAAO,IAAI;EAEZ;EAEAC,KAAK,CAAEjB,QAAQ,EAAEkB,KAAK,EAAElC,KAAK,EAAEmC,OAAO,EAAG;IAExC,MAAMC,mBAAmB,GAAGpB,QAAQ,CAACqB,eAAe,EAAE;IAEtD,KAAM,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAG,EAAG;MAE9BtB,QAAQ,CAACuB,eAAe,CAAE,IAAI,EAAED,CAAC,CAAE;MAEnCtB,QAAQ,CAACiB,KAAK,CAAEC,KAAK,EAAElC,KAAK,EAAEmC,OAAO,CAAE;IAExC;IAEAnB,QAAQ,CAACuB,eAAe,CAAEH,mBAAmB,CAAE;EAEhD;AAED;AAEA,SAAS5C,qBAAqB"},"metadata":{},"sourceType":"module","externalDependencies":[]}