{"ast":null,"code":"import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\nclass WireframeGeometry extends BufferGeometry {\n  constructor() {\n    let geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    super();\n    this.type = 'WireframeGeometry';\n    this.parameters = {\n      geometry: geometry\n    };\n    if (geometry !== null) {\n      // buffer\n\n      const vertices = [];\n      const edges = new Set();\n\n      // helper variables\n\n      const start = new Vector3();\n      const end = new Vector3();\n      if (geometry.index !== null) {\n        // indexed BufferGeometry\n\n        const position = geometry.attributes.position;\n        const indices = geometry.index;\n        let groups = geometry.groups;\n        if (groups.length === 0) {\n          groups = [{\n            start: 0,\n            count: indices.count,\n            materialIndex: 0\n          }];\n        }\n\n        // create a data structure that contains all edges without duplicates\n\n        for (let o = 0, ol = groups.length; o < ol; ++o) {\n          const group = groups[o];\n          const groupStart = group.start;\n          const groupCount = group.count;\n          for (let i = groupStart, l = groupStart + groupCount; i < l; i += 3) {\n            for (let j = 0; j < 3; j++) {\n              const index1 = indices.getX(i + j);\n              const index2 = indices.getX(i + (j + 1) % 3);\n              start.fromBufferAttribute(position, index1);\n              end.fromBufferAttribute(position, index2);\n              if (isUniqueEdge(start, end, edges) === true) {\n                vertices.push(start.x, start.y, start.z);\n                vertices.push(end.x, end.y, end.z);\n              }\n            }\n          }\n        }\n      } else {\n        // non-indexed BufferGeometry\n\n        const position = geometry.attributes.position;\n        for (let i = 0, l = position.count / 3; i < l; i++) {\n          for (let j = 0; j < 3; j++) {\n            // three edges per triangle, an edge is represented as (index1, index2)\n            // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)\n\n            const index1 = 3 * i + j;\n            const index2 = 3 * i + (j + 1) % 3;\n            start.fromBufferAttribute(position, index1);\n            end.fromBufferAttribute(position, index2);\n            if (isUniqueEdge(start, end, edges) === true) {\n              vertices.push(start.x, start.y, start.z);\n              vertices.push(end.x, end.y, end.z);\n            }\n          }\n        }\n      }\n\n      // build geometry\n\n      this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    }\n  }\n}\nfunction isUniqueEdge(start, end, edges) {\n  const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;\n  const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`; // coincident edge\n\n  if (edges.has(hash1) === true || edges.has(hash2) === true) {\n    return false;\n  } else {\n    edges.add(hash1);\n    edges.add(hash2);\n    return true;\n  }\n}\nexport { WireframeGeometry };","map":{"version":3,"names":["BufferGeometry","Float32BufferAttribute","Vector3","WireframeGeometry","constructor","geometry","type","parameters","vertices","edges","Set","start","end","index","position","attributes","indices","groups","length","count","materialIndex","o","ol","group","groupStart","groupCount","i","l","j","index1","getX","index2","fromBufferAttribute","isUniqueEdge","push","x","y","z","setAttribute","hash1","hash2","has","add"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/geometries/WireframeGeometry.js"],"sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nclass WireframeGeometry extends BufferGeometry {\n\n\tconstructor( geometry = null ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'WireframeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tgeometry: geometry\n\t\t};\n\n\t\tif ( geometry !== null ) {\n\n\t\t\t// buffer\n\n\t\t\tconst vertices = [];\n\t\t\tconst edges = new Set();\n\n\t\t\t// helper variables\n\n\t\t\tconst start = new Vector3();\n\t\t\tconst end = new Vector3();\n\n\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\t// indexed BufferGeometry\n\n\t\t\t\tconst position = geometry.attributes.position;\n\t\t\t\tconst indices = geometry.index;\n\t\t\t\tlet groups = geometry.groups;\n\n\t\t\t\tif ( groups.length === 0 ) {\n\n\t\t\t\t\tgroups = [ { start: 0, count: indices.count, materialIndex: 0 } ];\n\n\t\t\t\t}\n\n\t\t\t\t// create a data structure that contains all edges without duplicates\n\n\t\t\t\tfor ( let o = 0, ol = groups.length; o < ol; ++ o ) {\n\n\t\t\t\t\tconst group = groups[ o ];\n\n\t\t\t\t\tconst groupStart = group.start;\n\t\t\t\t\tconst groupCount = group.count;\n\n\t\t\t\t\tfor ( let i = groupStart, l = ( groupStart + groupCount ); i < l; i += 3 ) {\n\n\t\t\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t\tconst index1 = indices.getX( i + j );\n\t\t\t\t\t\t\tconst index2 = indices.getX( i + ( j + 1 ) % 3 );\n\n\t\t\t\t\t\t\tstart.fromBufferAttribute( position, index1 );\n\t\t\t\t\t\t\tend.fromBufferAttribute( position, index2 );\n\n\t\t\t\t\t\t\tif ( isUniqueEdge( start, end, edges ) === true ) {\n\n\t\t\t\t\t\t\t\tvertices.push( start.x, start.y, start.z );\n\t\t\t\t\t\t\t\tvertices.push( end.x, end.y, end.z );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed BufferGeometry\n\n\t\t\t\tconst position = geometry.attributes.position;\n\n\t\t\t\tfor ( let i = 0, l = ( position.count / 3 ); i < l; i ++ ) {\n\n\t\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t// three edges per triangle, an edge is represented as (index1, index2)\n\t\t\t\t\t\t// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)\n\n\t\t\t\t\t\tconst index1 = 3 * i + j;\n\t\t\t\t\t\tconst index2 = 3 * i + ( ( j + 1 ) % 3 );\n\n\t\t\t\t\t\tstart.fromBufferAttribute( position, index1 );\n\t\t\t\t\t\tend.fromBufferAttribute( position, index2 );\n\n\t\t\t\t\t\tif ( isUniqueEdge( start, end, edges ) === true ) {\n\n\t\t\t\t\t\t\tvertices.push( start.x, start.y, start.z );\n\t\t\t\t\t\t\tvertices.push( end.x, end.y, end.z );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// build geometry\n\n\t\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\n\t\t}\n\n\t}\n\n}\n\nfunction isUniqueEdge( start, end, edges ) {\n\n\tconst hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;\n\tconst hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`; // coincident edge\n\n\tif ( edges.has( hash1 ) === true || edges.has( hash2 ) === true ) {\n\n\t\treturn false;\n\n\t} else {\n\n\t\tedges.add( hash1 );\n\t\tedges.add( hash2 );\n\t\treturn true;\n\n\t}\n\n}\n\n\nexport { WireframeGeometry };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}