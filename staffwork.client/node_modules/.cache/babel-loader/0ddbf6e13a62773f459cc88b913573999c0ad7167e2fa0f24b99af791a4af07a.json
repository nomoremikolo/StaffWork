{"ast":null,"code":"import { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Sphere } from '../math/Sphere.js';\nimport { Ray } from '../math/Ray.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Object3D } from '../core/Object3D.js';\nimport { Triangle } from '../math/Triangle.js';\nimport { DoubleSide, BackSide } from '../constants.js';\nimport { MeshBasicMaterial } from '../materials/MeshBasicMaterial.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nconst _inverseMatrix = /*@__PURE__*/new Matrix4();\nconst _ray = /*@__PURE__*/new Ray();\nconst _sphere = /*@__PURE__*/new Sphere();\nconst _vA = /*@__PURE__*/new Vector3();\nconst _vB = /*@__PURE__*/new Vector3();\nconst _vC = /*@__PURE__*/new Vector3();\nconst _tempA = /*@__PURE__*/new Vector3();\nconst _tempB = /*@__PURE__*/new Vector3();\nconst _tempC = /*@__PURE__*/new Vector3();\nconst _morphA = /*@__PURE__*/new Vector3();\nconst _morphB = /*@__PURE__*/new Vector3();\nconst _morphC = /*@__PURE__*/new Vector3();\nconst _uvA = /*@__PURE__*/new Vector2();\nconst _uvB = /*@__PURE__*/new Vector2();\nconst _uvC = /*@__PURE__*/new Vector2();\nconst _intersectionPoint = /*@__PURE__*/new Vector3();\nconst _intersectionPointWorld = /*@__PURE__*/new Vector3();\nclass Mesh extends Object3D {\n  constructor() {\n    let geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new BufferGeometry();\n    let material = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new MeshBasicMaterial();\n    super();\n    this.isMesh = true;\n    this.type = 'Mesh';\n    this.geometry = geometry;\n    this.material = material;\n    this.updateMorphTargets();\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    if (source.morphTargetInfluences !== undefined) {\n      this.morphTargetInfluences = source.morphTargetInfluences.slice();\n    }\n    if (source.morphTargetDictionary !== undefined) {\n      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);\n    }\n    this.material = source.material;\n    this.geometry = source.geometry;\n    return this;\n  }\n  updateMorphTargets() {\n    const geometry = this.geometry;\n    const morphAttributes = geometry.morphAttributes;\n    const keys = Object.keys(morphAttributes);\n    if (keys.length > 0) {\n      const morphAttribute = morphAttributes[keys[0]];\n      if (morphAttribute !== undefined) {\n        this.morphTargetInfluences = [];\n        this.morphTargetDictionary = {};\n        for (let m = 0, ml = morphAttribute.length; m < ml; m++) {\n          const name = morphAttribute[m].name || String(m);\n          this.morphTargetInfluences.push(0);\n          this.morphTargetDictionary[name] = m;\n        }\n      }\n    }\n  }\n  raycast(raycaster, intersects) {\n    const geometry = this.geometry;\n    const material = this.material;\n    const matrixWorld = this.matrixWorld;\n    if (material === undefined) return;\n\n    // Checking boundingSphere distance to ray\n\n    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n    _sphere.copy(geometry.boundingSphere);\n    _sphere.applyMatrix4(matrixWorld);\n    if (raycaster.ray.intersectsSphere(_sphere) === false) return;\n\n    //\n\n    _inverseMatrix.copy(matrixWorld).invert();\n    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);\n\n    // Check boundingBox before continuing\n\n    if (geometry.boundingBox !== null) {\n      if (_ray.intersectsBox(geometry.boundingBox) === false) return;\n    }\n    let intersection;\n    const index = geometry.index;\n    const position = geometry.attributes.position;\n    const morphPosition = geometry.morphAttributes.position;\n    const morphTargetsRelative = geometry.morphTargetsRelative;\n    const uv = geometry.attributes.uv;\n    const uv2 = geometry.attributes.uv2;\n    const groups = geometry.groups;\n    const drawRange = geometry.drawRange;\n    if (index !== null) {\n      // indexed buffer geometry\n\n      if (Array.isArray(material)) {\n        for (let i = 0, il = groups.length; i < il; i++) {\n          const group = groups[i];\n          const groupMaterial = material[group.materialIndex];\n          const start = Math.max(group.start, drawRange.start);\n          const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));\n          for (let j = start, jl = end; j < jl; j += 3) {\n            const a = index.getX(j);\n            const b = index.getX(j + 1);\n            const c = index.getX(j + 2);\n            intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);\n            if (intersection) {\n              intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics\n              intersection.face.materialIndex = group.materialIndex;\n              intersects.push(intersection);\n            }\n          }\n        }\n      } else {\n        const start = Math.max(0, drawRange.start);\n        const end = Math.min(index.count, drawRange.start + drawRange.count);\n        for (let i = start, il = end; i < il; i += 3) {\n          const a = index.getX(i);\n          const b = index.getX(i + 1);\n          const c = index.getX(i + 2);\n          intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);\n          if (intersection) {\n            intersection.faceIndex = Math.floor(i / 3); // triangle number in indexed buffer semantics\n            intersects.push(intersection);\n          }\n        }\n      }\n    } else if (position !== undefined) {\n      // non-indexed buffer geometry\n\n      if (Array.isArray(material)) {\n        for (let i = 0, il = groups.length; i < il; i++) {\n          const group = groups[i];\n          const groupMaterial = material[group.materialIndex];\n          const start = Math.max(group.start, drawRange.start);\n          const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));\n          for (let j = start, jl = end; j < jl; j += 3) {\n            const a = j;\n            const b = j + 1;\n            const c = j + 2;\n            intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);\n            if (intersection) {\n              intersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics\n              intersection.face.materialIndex = group.materialIndex;\n              intersects.push(intersection);\n            }\n          }\n        }\n      } else {\n        const start = Math.max(0, drawRange.start);\n        const end = Math.min(position.count, drawRange.start + drawRange.count);\n        for (let i = start, il = end; i < il; i += 3) {\n          const a = i;\n          const b = i + 1;\n          const c = i + 2;\n          intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);\n          if (intersection) {\n            intersection.faceIndex = Math.floor(i / 3); // triangle number in non-indexed buffer semantics\n            intersects.push(intersection);\n          }\n        }\n      }\n    }\n  }\n}\nfunction checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {\n  let intersect;\n  if (material.side === BackSide) {\n    intersect = ray.intersectTriangle(pC, pB, pA, true, point);\n  } else {\n    intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);\n  }\n  if (intersect === null) return null;\n  _intersectionPointWorld.copy(point);\n  _intersectionPointWorld.applyMatrix4(object.matrixWorld);\n  const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);\n  if (distance < raycaster.near || distance > raycaster.far) return null;\n  return {\n    distance: distance,\n    point: _intersectionPointWorld.clone(),\n    object: object\n  };\n}\nfunction checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {\n  _vA.fromBufferAttribute(position, a);\n  _vB.fromBufferAttribute(position, b);\n  _vC.fromBufferAttribute(position, c);\n  const morphInfluences = object.morphTargetInfluences;\n  if (morphPosition && morphInfluences) {\n    _morphA.set(0, 0, 0);\n    _morphB.set(0, 0, 0);\n    _morphC.set(0, 0, 0);\n    for (let i = 0, il = morphPosition.length; i < il; i++) {\n      const influence = morphInfluences[i];\n      const morphAttribute = morphPosition[i];\n      if (influence === 0) continue;\n      _tempA.fromBufferAttribute(morphAttribute, a);\n      _tempB.fromBufferAttribute(morphAttribute, b);\n      _tempC.fromBufferAttribute(morphAttribute, c);\n      if (morphTargetsRelative) {\n        _morphA.addScaledVector(_tempA, influence);\n        _morphB.addScaledVector(_tempB, influence);\n        _morphC.addScaledVector(_tempC, influence);\n      } else {\n        _morphA.addScaledVector(_tempA.sub(_vA), influence);\n        _morphB.addScaledVector(_tempB.sub(_vB), influence);\n        _morphC.addScaledVector(_tempC.sub(_vC), influence);\n      }\n    }\n    _vA.add(_morphA);\n    _vB.add(_morphB);\n    _vC.add(_morphC);\n  }\n  if (object.isSkinnedMesh) {\n    object.boneTransform(a, _vA);\n    object.boneTransform(b, _vB);\n    object.boneTransform(c, _vC);\n  }\n  const intersection = checkIntersection(object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint);\n  if (intersection) {\n    if (uv) {\n      _uvA.fromBufferAttribute(uv, a);\n      _uvB.fromBufferAttribute(uv, b);\n      _uvC.fromBufferAttribute(uv, c);\n      intersection.uv = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());\n    }\n    if (uv2) {\n      _uvA.fromBufferAttribute(uv2, a);\n      _uvB.fromBufferAttribute(uv2, b);\n      _uvC.fromBufferAttribute(uv2, c);\n      intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());\n    }\n    const face = {\n      a: a,\n      b: b,\n      c: c,\n      normal: new Vector3(),\n      materialIndex: 0\n    };\n    Triangle.getNormal(_vA, _vB, _vC, face.normal);\n    intersection.face = face;\n  }\n  return intersection;\n}\nexport { Mesh };","map":{"version":3,"names":["Vector3","Vector2","Sphere","Ray","Matrix4","Object3D","Triangle","DoubleSide","BackSide","MeshBasicMaterial","BufferGeometry","_inverseMatrix","_ray","_sphere","_vA","_vB","_vC","_tempA","_tempB","_tempC","_morphA","_morphB","_morphC","_uvA","_uvB","_uvC","_intersectionPoint","_intersectionPointWorld","Mesh","constructor","geometry","material","isMesh","type","updateMorphTargets","copy","source","recursive","morphTargetInfluences","undefined","slice","morphTargetDictionary","Object","assign","morphAttributes","keys","length","morphAttribute","m","ml","name","String","push","raycast","raycaster","intersects","matrixWorld","boundingSphere","computeBoundingSphere","applyMatrix4","ray","intersectsSphere","invert","boundingBox","intersectsBox","intersection","index","position","attributes","morphPosition","morphTargetsRelative","uv","uv2","groups","drawRange","Array","isArray","i","il","group","groupMaterial","materialIndex","start","Math","max","end","min","count","j","jl","a","getX","b","c","checkBufferGeometryIntersection","faceIndex","floor","face","checkIntersection","object","pA","pB","pC","point","intersect","side","intersectTriangle","distance","origin","distanceTo","near","far","clone","fromBufferAttribute","morphInfluences","set","influence","addScaledVector","sub","add","isSkinnedMesh","boneTransform","getUV","normal","getNormal"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/objects/Mesh.js"],"sourcesContent":["import { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Sphere } from '../math/Sphere.js';\nimport { Ray } from '../math/Ray.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Object3D } from '../core/Object3D.js';\nimport { Triangle } from '../math/Triangle.js';\nimport { DoubleSide, BackSide } from '../constants.js';\nimport { MeshBasicMaterial } from '../materials/MeshBasicMaterial.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\n\nconst _inverseMatrix = /*@__PURE__*/ new Matrix4();\nconst _ray = /*@__PURE__*/ new Ray();\nconst _sphere = /*@__PURE__*/ new Sphere();\n\nconst _vA = /*@__PURE__*/ new Vector3();\nconst _vB = /*@__PURE__*/ new Vector3();\nconst _vC = /*@__PURE__*/ new Vector3();\n\nconst _tempA = /*@__PURE__*/ new Vector3();\nconst _tempB = /*@__PURE__*/ new Vector3();\nconst _tempC = /*@__PURE__*/ new Vector3();\n\nconst _morphA = /*@__PURE__*/ new Vector3();\nconst _morphB = /*@__PURE__*/ new Vector3();\nconst _morphC = /*@__PURE__*/ new Vector3();\n\nconst _uvA = /*@__PURE__*/ new Vector2();\nconst _uvB = /*@__PURE__*/ new Vector2();\nconst _uvC = /*@__PURE__*/ new Vector2();\n\nconst _intersectionPoint = /*@__PURE__*/ new Vector3();\nconst _intersectionPointWorld = /*@__PURE__*/ new Vector3();\n\nclass Mesh extends Object3D {\n\n\tconstructor( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {\n\n\t\tsuper();\n\n\t\tthis.isMesh = true;\n\n\t\tthis.type = 'Mesh';\n\n\t\tthis.geometry = geometry;\n\t\tthis.material = material;\n\n\t\tthis.updateMorphTargets();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tif ( source.morphTargetInfluences !== undefined ) {\n\n\t\t\tthis.morphTargetInfluences = source.morphTargetInfluences.slice();\n\n\t\t}\n\n\t\tif ( source.morphTargetDictionary !== undefined ) {\n\n\t\t\tthis.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );\n\n\t\t}\n\n\t\tthis.material = source.material;\n\t\tthis.geometry = source.geometry;\n\n\t\treturn this;\n\n\t}\n\n\tupdateMorphTargets() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst morphAttributes = geometry.morphAttributes;\n\t\tconst keys = Object.keys( morphAttributes );\n\n\t\tif ( keys.length > 0 ) {\n\n\t\t\tconst morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\tfor ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\tconst name = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst material = this.material;\n\t\tconst matrixWorld = this.matrixWorld;\n\n\t\tif ( material === undefined ) return;\n\n\t\t// Checking boundingSphere distance to ray\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere.copy( geometry.boundingSphere );\n\t\t_sphere.applyMatrix4( matrixWorld );\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;\n\n\t\t//\n\n\t\t_inverseMatrix.copy( matrixWorld ).invert();\n\t\t_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );\n\n\t\t// Check boundingBox before continuing\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tif ( _ray.intersectsBox( geometry.boundingBox ) === false ) return;\n\n\t\t}\n\n\t\tlet intersection;\n\n\t\tconst index = geometry.index;\n\t\tconst position = geometry.attributes.position;\n\t\tconst morphPosition = geometry.morphAttributes.position;\n\t\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\t\tconst uv = geometry.attributes.uv;\n\t\tconst uv2 = geometry.attributes.uv2;\n\t\tconst groups = geometry.groups;\n\t\tconst drawRange = geometry.drawRange;\n\n\t\tif ( index !== null ) {\n\n\t\t\t// indexed buffer geometry\n\n\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\tconst start = Math.max( group.start, drawRange.start );\n\t\t\t\t\tconst end = Math.min( index.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );\n\n\t\t\t\t\tfor ( let j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\t\tconst a = index.getX( j );\n\t\t\t\t\t\tconst b = index.getX( j + 1 );\n\t\t\t\t\t\tconst c = index.getX( j + 2 );\n\n\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics\n\t\t\t\t\t\t\tintersection.face.materialIndex = group.materialIndex;\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\t\tconst end = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( let i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\t\tconst a = index.getX( i );\n\t\t\t\t\tconst b = index.getX( i + 1 );\n\t\t\t\t\tconst c = index.getX( i + 2 );\n\n\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );\n\n\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics\n\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( position !== undefined ) {\n\n\t\t\t// non-indexed buffer geometry\n\n\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\tconst start = Math.max( group.start, drawRange.start );\n\t\t\t\t\tconst end = Math.min( position.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );\n\n\t\t\t\t\tfor ( let j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\t\tconst a = j;\n\t\t\t\t\t\tconst b = j + 1;\n\t\t\t\t\t\tconst c = j + 2;\n\n\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics\n\t\t\t\t\t\t\tintersection.face.materialIndex = group.materialIndex;\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\t\tconst end = Math.min( position.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( let i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\t\tconst a = i;\n\t\t\t\t\tconst b = i + 1;\n\t\t\t\t\tconst c = i + 2;\n\n\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );\n\n\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics\n\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nfunction checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {\n\n\tlet intersect;\n\n\tif ( material.side === BackSide ) {\n\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t} else {\n\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );\n\n\t}\n\n\tif ( intersect === null ) return null;\n\n\t_intersectionPointWorld.copy( point );\n\t_intersectionPointWorld.applyMatrix4( object.matrixWorld );\n\n\tconst distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );\n\n\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\n\n\treturn {\n\t\tdistance: distance,\n\t\tpoint: _intersectionPointWorld.clone(),\n\t\tobject: object\n\t};\n\n}\n\nfunction checkBufferGeometryIntersection( object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c ) {\n\n\t_vA.fromBufferAttribute( position, a );\n\t_vB.fromBufferAttribute( position, b );\n\t_vC.fromBufferAttribute( position, c );\n\n\tconst morphInfluences = object.morphTargetInfluences;\n\n\tif ( morphPosition && morphInfluences ) {\n\n\t\t_morphA.set( 0, 0, 0 );\n\t\t_morphB.set( 0, 0, 0 );\n\t\t_morphC.set( 0, 0, 0 );\n\n\t\tfor ( let i = 0, il = morphPosition.length; i < il; i ++ ) {\n\n\t\t\tconst influence = morphInfluences[ i ];\n\t\t\tconst morphAttribute = morphPosition[ i ];\n\n\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t_tempA.fromBufferAttribute( morphAttribute, a );\n\t\t\t_tempB.fromBufferAttribute( morphAttribute, b );\n\t\t\t_tempC.fromBufferAttribute( morphAttribute, c );\n\n\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t} else {\n\n\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\n\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\n\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\n\n\t\t\t}\n\n\t\t}\n\n\t\t_vA.add( _morphA );\n\t\t_vB.add( _morphB );\n\t\t_vC.add( _morphC );\n\n\t}\n\n\tif ( object.isSkinnedMesh ) {\n\n\t\tobject.boneTransform( a, _vA );\n\t\tobject.boneTransform( b, _vB );\n\t\tobject.boneTransform( c, _vC );\n\n\t}\n\n\tconst intersection = checkIntersection( object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint );\n\n\tif ( intersection ) {\n\n\t\tif ( uv ) {\n\n\t\t\t_uvA.fromBufferAttribute( uv, a );\n\t\t\t_uvB.fromBufferAttribute( uv, b );\n\t\t\t_uvC.fromBufferAttribute( uv, c );\n\n\t\t\tintersection.uv = Triangle.getUV( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );\n\n\t\t}\n\n\t\tif ( uv2 ) {\n\n\t\t\t_uvA.fromBufferAttribute( uv2, a );\n\t\t\t_uvB.fromBufferAttribute( uv2, b );\n\t\t\t_uvC.fromBufferAttribute( uv2, c );\n\n\t\t\tintersection.uv2 = Triangle.getUV( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );\n\n\t\t}\n\n\t\tconst face = {\n\t\t\ta: a,\n\t\t\tb: b,\n\t\t\tc: c,\n\t\t\tnormal: new Vector3(),\n\t\t\tmaterialIndex: 0\n\t\t};\n\n\t\tTriangle.getNormal( _vA, _vB, _vC, face.normal );\n\n\t\tintersection.face = face;\n\n\t}\n\n\treturn intersection;\n\n}\n\nexport { Mesh };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}