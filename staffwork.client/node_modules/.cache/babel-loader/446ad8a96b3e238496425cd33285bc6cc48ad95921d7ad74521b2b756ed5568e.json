{"ast":null,"code":"import { Sphere } from '../math/Sphere.js';\nimport { Ray } from '../math/Ray.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Object3D } from '../core/Object3D.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { LineBasicMaterial } from '../materials/LineBasicMaterial.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nconst _start = /*@__PURE__*/new Vector3();\nconst _end = /*@__PURE__*/new Vector3();\nconst _inverseMatrix = /*@__PURE__*/new Matrix4();\nconst _ray = /*@__PURE__*/new Ray();\nconst _sphere = /*@__PURE__*/new Sphere();\nclass Line extends Object3D {\n  constructor() {\n    let geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new BufferGeometry();\n    let material = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new LineBasicMaterial();\n    super();\n    this.isLine = true;\n    this.type = 'Line';\n    this.geometry = geometry;\n    this.material = material;\n    this.updateMorphTargets();\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.material = source.material;\n    this.geometry = source.geometry;\n    return this;\n  }\n  computeLineDistances() {\n    const geometry = this.geometry;\n\n    // we assume non-indexed geometry\n\n    if (geometry.index === null) {\n      const positionAttribute = geometry.attributes.position;\n      const lineDistances = [0];\n      for (let i = 1, l = positionAttribute.count; i < l; i++) {\n        _start.fromBufferAttribute(positionAttribute, i - 1);\n        _end.fromBufferAttribute(positionAttribute, i);\n        lineDistances[i] = lineDistances[i - 1];\n        lineDistances[i] += _start.distanceTo(_end);\n      }\n      geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));\n    } else {\n      console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');\n    }\n    return this;\n  }\n  raycast(raycaster, intersects) {\n    const geometry = this.geometry;\n    const matrixWorld = this.matrixWorld;\n    const threshold = raycaster.params.Line.threshold;\n    const drawRange = geometry.drawRange;\n\n    // Checking boundingSphere distance to ray\n\n    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n    _sphere.copy(geometry.boundingSphere);\n    _sphere.applyMatrix4(matrixWorld);\n    _sphere.radius += threshold;\n    if (raycaster.ray.intersectsSphere(_sphere) === false) return;\n\n    //\n\n    _inverseMatrix.copy(matrixWorld).invert();\n    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);\n    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);\n    const localThresholdSq = localThreshold * localThreshold;\n    const vStart = new Vector3();\n    const vEnd = new Vector3();\n    const interSegment = new Vector3();\n    const interRay = new Vector3();\n    const step = this.isLineSegments ? 2 : 1;\n    const index = geometry.index;\n    const attributes = geometry.attributes;\n    const positionAttribute = attributes.position;\n    if (index !== null) {\n      const start = Math.max(0, drawRange.start);\n      const end = Math.min(index.count, drawRange.start + drawRange.count);\n      for (let i = start, l = end - 1; i < l; i += step) {\n        const a = index.getX(i);\n        const b = index.getX(i + 1);\n        vStart.fromBufferAttribute(positionAttribute, a);\n        vEnd.fromBufferAttribute(positionAttribute, b);\n        const distSq = _ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);\n        if (distSq > localThresholdSq) continue;\n        interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation\n\n        const distance = raycaster.ray.origin.distanceTo(interRay);\n        if (distance < raycaster.near || distance > raycaster.far) continue;\n        intersects.push({\n          distance: distance,\n          // What do we want? intersection point on the ray or on the segment??\n          // point: raycaster.ray.at( distance ),\n          point: interSegment.clone().applyMatrix4(this.matrixWorld),\n          index: i,\n          face: null,\n          faceIndex: null,\n          object: this\n        });\n      }\n    } else {\n      const start = Math.max(0, drawRange.start);\n      const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n      for (let i = start, l = end - 1; i < l; i += step) {\n        vStart.fromBufferAttribute(positionAttribute, i);\n        vEnd.fromBufferAttribute(positionAttribute, i + 1);\n        const distSq = _ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);\n        if (distSq > localThresholdSq) continue;\n        interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation\n\n        const distance = raycaster.ray.origin.distanceTo(interRay);\n        if (distance < raycaster.near || distance > raycaster.far) continue;\n        intersects.push({\n          distance: distance,\n          // What do we want? intersection point on the ray or on the segment??\n          // point: raycaster.ray.at( distance ),\n          point: interSegment.clone().applyMatrix4(this.matrixWorld),\n          index: i,\n          face: null,\n          faceIndex: null,\n          object: this\n        });\n      }\n    }\n  }\n  updateMorphTargets() {\n    const geometry = this.geometry;\n    const morphAttributes = geometry.morphAttributes;\n    const keys = Object.keys(morphAttributes);\n    if (keys.length > 0) {\n      const morphAttribute = morphAttributes[keys[0]];\n      if (morphAttribute !== undefined) {\n        this.morphTargetInfluences = [];\n        this.morphTargetDictionary = {};\n        for (let m = 0, ml = morphAttribute.length; m < ml; m++) {\n          const name = morphAttribute[m].name || String(m);\n          this.morphTargetInfluences.push(0);\n          this.morphTargetDictionary[name] = m;\n        }\n      }\n    }\n  }\n}\nexport { Line };","map":{"version":3,"names":["Sphere","Ray","Matrix4","Object3D","Vector3","LineBasicMaterial","BufferGeometry","Float32BufferAttribute","_start","_end","_inverseMatrix","_ray","_sphere","Line","constructor","geometry","material","isLine","type","updateMorphTargets","copy","source","recursive","computeLineDistances","index","positionAttribute","attributes","position","lineDistances","i","l","count","fromBufferAttribute","distanceTo","setAttribute","console","warn","raycast","raycaster","intersects","matrixWorld","threshold","params","drawRange","boundingSphere","computeBoundingSphere","applyMatrix4","radius","ray","intersectsSphere","invert","localThreshold","scale","x","y","z","localThresholdSq","vStart","vEnd","interSegment","interRay","step","isLineSegments","start","Math","max","end","min","a","getX","b","distSq","distanceSqToSegment","distance","origin","near","far","push","point","clone","face","faceIndex","object","morphAttributes","keys","Object","length","morphAttribute","undefined","morphTargetInfluences","morphTargetDictionary","m","ml","name","String"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/objects/Line.js"],"sourcesContent":["import { Sphere } from '../math/Sphere.js';\nimport { Ray } from '../math/Ray.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Object3D } from '../core/Object3D.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { LineBasicMaterial } from '../materials/LineBasicMaterial.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\n\nconst _start = /*@__PURE__*/ new Vector3();\nconst _end = /*@__PURE__*/ new Vector3();\nconst _inverseMatrix = /*@__PURE__*/ new Matrix4();\nconst _ray = /*@__PURE__*/ new Ray();\nconst _sphere = /*@__PURE__*/ new Sphere();\n\nclass Line extends Object3D {\n\n\tconstructor( geometry = new BufferGeometry(), material = new LineBasicMaterial() ) {\n\n\t\tsuper();\n\n\t\tthis.isLine = true;\n\n\t\tthis.type = 'Line';\n\n\t\tthis.geometry = geometry;\n\t\tthis.material = material;\n\n\t\tthis.updateMorphTargets();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.material = source.material;\n\t\tthis.geometry = source.geometry;\n\n\t\treturn this;\n\n\t}\n\n\tcomputeLineDistances() {\n\n\t\tconst geometry = this.geometry;\n\n\t\t// we assume non-indexed geometry\n\n\t\tif ( geometry.index === null ) {\n\n\t\t\tconst positionAttribute = geometry.attributes.position;\n\t\t\tconst lineDistances = [ 0 ];\n\n\t\t\tfor ( let i = 1, l = positionAttribute.count; i < l; i ++ ) {\n\n\t\t\t\t_start.fromBufferAttribute( positionAttribute, i - 1 );\n\t\t\t\t_end.fromBufferAttribute( positionAttribute, i );\n\n\t\t\t\tlineDistances[ i ] = lineDistances[ i - 1 ];\n\t\t\t\tlineDistances[ i ] += _start.distanceTo( _end );\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst threshold = raycaster.params.Line.threshold;\n\t\tconst drawRange = geometry.drawRange;\n\n\t\t// Checking boundingSphere distance to ray\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere.copy( geometry.boundingSphere );\n\t\t_sphere.applyMatrix4( matrixWorld );\n\t\t_sphere.radius += threshold;\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;\n\n\t\t//\n\n\t\t_inverseMatrix.copy( matrixWorld ).invert();\n\t\t_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );\n\n\t\tconst localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\tconst localThresholdSq = localThreshold * localThreshold;\n\n\t\tconst vStart = new Vector3();\n\t\tconst vEnd = new Vector3();\n\t\tconst interSegment = new Vector3();\n\t\tconst interRay = new Vector3();\n\t\tconst step = this.isLineSegments ? 2 : 1;\n\n\t\tconst index = geometry.index;\n\t\tconst attributes = geometry.attributes;\n\t\tconst positionAttribute = attributes.position;\n\n\t\tif ( index !== null ) {\n\n\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\tconst end = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( let i = start, l = end - 1; i < l; i += step ) {\n\n\t\t\t\tconst a = index.getX( i );\n\t\t\t\tconst b = index.getX( i + 1 );\n\n\t\t\t\tvStart.fromBufferAttribute( positionAttribute, a );\n\t\t\t\tvEnd.fromBufferAttribute( positionAttribute, b );\n\n\t\t\t\tconst distSq = _ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\tif ( distSq > localThresholdSq ) continue;\n\n\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\tconst distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\tintersects.push( {\n\n\t\t\t\t\tdistance: distance,\n\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\tindex: i,\n\t\t\t\t\tface: null,\n\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\tobject: this\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\tconst end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( let i = start, l = end - 1; i < l; i += step ) {\n\n\t\t\t\tvStart.fromBufferAttribute( positionAttribute, i );\n\t\t\t\tvEnd.fromBufferAttribute( positionAttribute, i + 1 );\n\n\t\t\t\tconst distSq = _ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\tif ( distSq > localThresholdSq ) continue;\n\n\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\tconst distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\tintersects.push( {\n\n\t\t\t\t\tdistance: distance,\n\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\tindex: i,\n\t\t\t\t\tface: null,\n\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\tobject: this\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tupdateMorphTargets() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst morphAttributes = geometry.morphAttributes;\n\t\tconst keys = Object.keys( morphAttributes );\n\n\t\tif ( keys.length > 0 ) {\n\n\t\t\tconst morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\tfor ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\tconst name = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nexport { Line };\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,mBAAmB;AAC1C,SAASC,GAAG,QAAQ,gBAAgB;AACpC,SAASC,OAAO,QAAQ,oBAAoB;AAC5C,SAASC,QAAQ,QAAQ,qBAAqB;AAC9C,SAASC,OAAO,QAAQ,oBAAoB;AAC5C,SAASC,iBAAiB,QAAQ,mCAAmC;AACrE,SAASC,cAAc,QAAQ,2BAA2B;AAC1D,SAASC,sBAAsB,QAAQ,4BAA4B;AAEnE,MAAMC,MAAM,GAAG,aAAc,IAAIJ,OAAO,EAAE;AAC1C,MAAMK,IAAI,GAAG,aAAc,IAAIL,OAAO,EAAE;AACxC,MAAMM,cAAc,GAAG,aAAc,IAAIR,OAAO,EAAE;AAClD,MAAMS,IAAI,GAAG,aAAc,IAAIV,GAAG,EAAE;AACpC,MAAMW,OAAO,GAAG,aAAc,IAAIZ,MAAM,EAAE;AAE1C,MAAMa,IAAI,SAASV,QAAQ,CAAC;EAE3BW,WAAW,GAAwE;IAAA,IAAtEC,QAAQ,uEAAG,IAAIT,cAAc,EAAE;IAAA,IAAEU,QAAQ,uEAAG,IAAIX,iBAAiB,EAAE;IAE/E,KAAK,EAAE;IAEP,IAAI,CAACY,MAAM,GAAG,IAAI;IAElB,IAAI,CAACC,IAAI,GAAG,MAAM;IAElB,IAAI,CAACH,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,QAAQ,GAAGA,QAAQ;IAExB,IAAI,CAACG,kBAAkB,EAAE;EAE1B;EAEAC,IAAI,CAAEC,MAAM,EAAEC,SAAS,EAAG;IAEzB,KAAK,CAACF,IAAI,CAAEC,MAAM,EAAEC,SAAS,CAAE;IAE/B,IAAI,CAACN,QAAQ,GAAGK,MAAM,CAACL,QAAQ;IAC/B,IAAI,CAACD,QAAQ,GAAGM,MAAM,CAACN,QAAQ;IAE/B,OAAO,IAAI;EAEZ;EAEAQ,oBAAoB,GAAG;IAEtB,MAAMR,QAAQ,GAAG,IAAI,CAACA,QAAQ;;IAE9B;;IAEA,IAAKA,QAAQ,CAACS,KAAK,KAAK,IAAI,EAAG;MAE9B,MAAMC,iBAAiB,GAAGV,QAAQ,CAACW,UAAU,CAACC,QAAQ;MACtD,MAAMC,aAAa,GAAG,CAAE,CAAC,CAAE;MAE3B,KAAM,IAAIC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGL,iBAAiB,CAACM,KAAK,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAG,EAAG;QAE3DrB,MAAM,CAACwB,mBAAmB,CAAEP,iBAAiB,EAAEI,CAAC,GAAG,CAAC,CAAE;QACtDpB,IAAI,CAACuB,mBAAmB,CAAEP,iBAAiB,EAAEI,CAAC,CAAE;QAEhDD,aAAa,CAAEC,CAAC,CAAE,GAAGD,aAAa,CAAEC,CAAC,GAAG,CAAC,CAAE;QAC3CD,aAAa,CAAEC,CAAC,CAAE,IAAIrB,MAAM,CAACyB,UAAU,CAAExB,IAAI,CAAE;MAEhD;MAEAM,QAAQ,CAACmB,YAAY,CAAE,cAAc,EAAE,IAAI3B,sBAAsB,CAAEqB,aAAa,EAAE,CAAC,CAAE,CAAE;IAExF,CAAC,MAAM;MAENO,OAAO,CAACC,IAAI,CAAE,+FAA+F,CAAE;IAEhH;IAEA,OAAO,IAAI;EAEZ;EAEAC,OAAO,CAAEC,SAAS,EAAEC,UAAU,EAAG;IAEhC,MAAMxB,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAC9B,MAAMyB,WAAW,GAAG,IAAI,CAACA,WAAW;IACpC,MAAMC,SAAS,GAAGH,SAAS,CAACI,MAAM,CAAC7B,IAAI,CAAC4B,SAAS;IACjD,MAAME,SAAS,GAAG5B,QAAQ,CAAC4B,SAAS;;IAEpC;;IAEA,IAAK5B,QAAQ,CAAC6B,cAAc,KAAK,IAAI,EAAG7B,QAAQ,CAAC8B,qBAAqB,EAAE;IAExEjC,OAAO,CAACQ,IAAI,CAAEL,QAAQ,CAAC6B,cAAc,CAAE;IACvChC,OAAO,CAACkC,YAAY,CAAEN,WAAW,CAAE;IACnC5B,OAAO,CAACmC,MAAM,IAAIN,SAAS;IAE3B,IAAKH,SAAS,CAACU,GAAG,CAACC,gBAAgB,CAAErC,OAAO,CAAE,KAAK,KAAK,EAAG;;IAE3D;;IAEAF,cAAc,CAACU,IAAI,CAAEoB,WAAW,CAAE,CAACU,MAAM,EAAE;IAC3CvC,IAAI,CAACS,IAAI,CAAEkB,SAAS,CAACU,GAAG,CAAE,CAACF,YAAY,CAAEpC,cAAc,CAAE;IAEzD,MAAMyC,cAAc,GAAGV,SAAS,IAAK,CAAE,IAAI,CAACW,KAAK,CAACC,CAAC,GAAG,IAAI,CAACD,KAAK,CAACE,CAAC,GAAG,IAAI,CAACF,KAAK,CAACG,CAAC,IAAK,CAAC,CAAE;IACzF,MAAMC,gBAAgB,GAAGL,cAAc,GAAGA,cAAc;IAExD,MAAMM,MAAM,GAAG,IAAIrD,OAAO,EAAE;IAC5B,MAAMsD,IAAI,GAAG,IAAItD,OAAO,EAAE;IAC1B,MAAMuD,YAAY,GAAG,IAAIvD,OAAO,EAAE;IAClC,MAAMwD,QAAQ,GAAG,IAAIxD,OAAO,EAAE;IAC9B,MAAMyD,IAAI,GAAG,IAAI,CAACC,cAAc,GAAG,CAAC,GAAG,CAAC;IAExC,MAAMtC,KAAK,GAAGT,QAAQ,CAACS,KAAK;IAC5B,MAAME,UAAU,GAAGX,QAAQ,CAACW,UAAU;IACtC,MAAMD,iBAAiB,GAAGC,UAAU,CAACC,QAAQ;IAE7C,IAAKH,KAAK,KAAK,IAAI,EAAG;MAErB,MAAMuC,KAAK,GAAGC,IAAI,CAACC,GAAG,CAAE,CAAC,EAAEtB,SAAS,CAACoB,KAAK,CAAE;MAC5C,MAAMG,GAAG,GAAGF,IAAI,CAACG,GAAG,CAAE3C,KAAK,CAACO,KAAK,EAAIY,SAAS,CAACoB,KAAK,GAAGpB,SAAS,CAACZ,KAAK,CAAI;MAE1E,KAAM,IAAIF,CAAC,GAAGkC,KAAK,EAAEjC,CAAC,GAAGoC,GAAG,GAAG,CAAC,EAAErC,CAAC,GAAGC,CAAC,EAAED,CAAC,IAAIgC,IAAI,EAAG;QAEpD,MAAMO,CAAC,GAAG5C,KAAK,CAAC6C,IAAI,CAAExC,CAAC,CAAE;QACzB,MAAMyC,CAAC,GAAG9C,KAAK,CAAC6C,IAAI,CAAExC,CAAC,GAAG,CAAC,CAAE;QAE7B4B,MAAM,CAACzB,mBAAmB,CAAEP,iBAAiB,EAAE2C,CAAC,CAAE;QAClDV,IAAI,CAAC1B,mBAAmB,CAAEP,iBAAiB,EAAE6C,CAAC,CAAE;QAEhD,MAAMC,MAAM,GAAG5D,IAAI,CAAC6D,mBAAmB,CAAEf,MAAM,EAAEC,IAAI,EAAEE,QAAQ,EAAED,YAAY,CAAE;QAE/E,IAAKY,MAAM,GAAGf,gBAAgB,EAAG;QAEjCI,QAAQ,CAACd,YAAY,CAAE,IAAI,CAACN,WAAW,CAAE,CAAC,CAAC;;QAE3C,MAAMiC,QAAQ,GAAGnC,SAAS,CAACU,GAAG,CAAC0B,MAAM,CAACzC,UAAU,CAAE2B,QAAQ,CAAE;QAE5D,IAAKa,QAAQ,GAAGnC,SAAS,CAACqC,IAAI,IAAIF,QAAQ,GAAGnC,SAAS,CAACsC,GAAG,EAAG;QAE7DrC,UAAU,CAACsC,IAAI,CAAE;UAEhBJ,QAAQ,EAAEA,QAAQ;UAClB;UACA;UACAK,KAAK,EAAEnB,YAAY,CAACoB,KAAK,EAAE,CAACjC,YAAY,CAAE,IAAI,CAACN,WAAW,CAAE;UAC5DhB,KAAK,EAAEK,CAAC;UACRmD,IAAI,EAAE,IAAI;UACVC,SAAS,EAAE,IAAI;UACfC,MAAM,EAAE;QAET,CAAC,CAAE;MAEJ;IAED,CAAC,MAAM;MAEN,MAAMnB,KAAK,GAAGC,IAAI,CAACC,GAAG,CAAE,CAAC,EAAEtB,SAAS,CAACoB,KAAK,CAAE;MAC5C,MAAMG,GAAG,GAAGF,IAAI,CAACG,GAAG,CAAE1C,iBAAiB,CAACM,KAAK,EAAIY,SAAS,CAACoB,KAAK,GAAGpB,SAAS,CAACZ,KAAK,CAAI;MAEtF,KAAM,IAAIF,CAAC,GAAGkC,KAAK,EAAEjC,CAAC,GAAGoC,GAAG,GAAG,CAAC,EAAErC,CAAC,GAAGC,CAAC,EAAED,CAAC,IAAIgC,IAAI,EAAG;QAEpDJ,MAAM,CAACzB,mBAAmB,CAAEP,iBAAiB,EAAEI,CAAC,CAAE;QAClD6B,IAAI,CAAC1B,mBAAmB,CAAEP,iBAAiB,EAAEI,CAAC,GAAG,CAAC,CAAE;QAEpD,MAAM0C,MAAM,GAAG5D,IAAI,CAAC6D,mBAAmB,CAAEf,MAAM,EAAEC,IAAI,EAAEE,QAAQ,EAAED,YAAY,CAAE;QAE/E,IAAKY,MAAM,GAAGf,gBAAgB,EAAG;QAEjCI,QAAQ,CAACd,YAAY,CAAE,IAAI,CAACN,WAAW,CAAE,CAAC,CAAC;;QAE3C,MAAMiC,QAAQ,GAAGnC,SAAS,CAACU,GAAG,CAAC0B,MAAM,CAACzC,UAAU,CAAE2B,QAAQ,CAAE;QAE5D,IAAKa,QAAQ,GAAGnC,SAAS,CAACqC,IAAI,IAAIF,QAAQ,GAAGnC,SAAS,CAACsC,GAAG,EAAG;QAE7DrC,UAAU,CAACsC,IAAI,CAAE;UAEhBJ,QAAQ,EAAEA,QAAQ;UAClB;UACA;UACAK,KAAK,EAAEnB,YAAY,CAACoB,KAAK,EAAE,CAACjC,YAAY,CAAE,IAAI,CAACN,WAAW,CAAE;UAC5DhB,KAAK,EAAEK,CAAC;UACRmD,IAAI,EAAE,IAAI;UACVC,SAAS,EAAE,IAAI;UACfC,MAAM,EAAE;QAET,CAAC,CAAE;MAEJ;IAED;EAED;EAEA/D,kBAAkB,GAAG;IAEpB,MAAMJ,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAE9B,MAAMoE,eAAe,GAAGpE,QAAQ,CAACoE,eAAe;IAChD,MAAMC,IAAI,GAAGC,MAAM,CAACD,IAAI,CAAED,eAAe,CAAE;IAE3C,IAAKC,IAAI,CAACE,MAAM,GAAG,CAAC,EAAG;MAEtB,MAAMC,cAAc,GAAGJ,eAAe,CAAEC,IAAI,CAAE,CAAC,CAAE,CAAE;MAEnD,IAAKG,cAAc,KAAKC,SAAS,EAAG;QAEnC,IAAI,CAACC,qBAAqB,GAAG,EAAE;QAC/B,IAAI,CAACC,qBAAqB,GAAG,CAAC,CAAC;QAE/B,KAAM,IAAIC,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGL,cAAc,CAACD,MAAM,EAAEK,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAG,EAAG;UAE3D,MAAME,IAAI,GAAGN,cAAc,CAAEI,CAAC,CAAE,CAACE,IAAI,IAAIC,MAAM,CAAEH,CAAC,CAAE;UAEpD,IAAI,CAACF,qBAAqB,CAACZ,IAAI,CAAE,CAAC,CAAE;UACpC,IAAI,CAACa,qBAAqB,CAAEG,IAAI,CAAE,GAAGF,CAAC;QAEvC;MAED;IAED;EAED;AAED;AAEA,SAAS9E,IAAI"},"metadata":{},"sourceType":"module","externalDependencies":[]}