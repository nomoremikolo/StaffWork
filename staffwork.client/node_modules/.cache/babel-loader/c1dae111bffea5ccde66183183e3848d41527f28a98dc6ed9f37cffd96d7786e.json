{"ast":null,"code":"import Node from '../core/Node.js';\nimport { attribute, float } from '../shadernode/ShaderNodeBaseElements.js';\nimport { MathUtils, InstancedBufferAttribute } from 'three';\nclass RangeNode extends Node {\n  constructor(min, max) {\n    super();\n    this.min = min;\n    this.max = max;\n  }\n  getVectorLength() {\n    const min = this.min;\n    let length = 1;\n    if (min.isVector2) length = 2;else if (min.isVector3) length = 3;else if (min.isVector4) length = 4;else if (min.isColor) length = 3;\n    return length;\n  }\n  getNodeType(builder) {\n    return builder.object.isInstancedMesh === true ? builder.getTypeFromLength(this.getVectorLength()) : 'float';\n  }\n  construct(builder) {\n    const {\n      min,\n      max\n    } = this;\n    const {\n      object,\n      geometry\n    } = builder;\n    let output = null;\n    if (object.isInstancedMesh === true) {\n      const vectorLength = this.getVectorLength();\n      const attributeName = 'node' + this.id;\n      const length = vectorLength * object.count;\n      const array = new Float32Array(length);\n      const attributeGeometry = geometry.getAttribute(attributeName);\n      if (attributeGeometry === undefined || attributeGeometry.array.length < length) {\n        if (vectorLength === 1) {\n          for (let i = 0; i < length; i++) {\n            array[i] = MathUtils.lerp(min, max, Math.random());\n          }\n        } else if (min.isColor) {\n          for (let i = 0; i < length; i += 3) {\n            array[i] = MathUtils.lerp(min.r, max.r, Math.random());\n            array[i + 1] = MathUtils.lerp(min.g, max.g, Math.random());\n            array[i + 2] = MathUtils.lerp(min.b, max.b, Math.random());\n          }\n        } else {\n          for (let i = 0; i < length; i++) {\n            const index = i % vectorLength;\n            const minValue = min.getComponent(index);\n            const maxValue = max.getComponent(index);\n            array[i] = MathUtils.lerp(minValue, maxValue, Math.random());\n          }\n        }\n        geometry.setAttribute(attributeName, new InstancedBufferAttribute(array, vectorLength));\n        geometry.dispose();\n      }\n      output = attribute(attributeName, builder.getTypeFromLength(vectorLength));\n    } else {\n      output = float(0);\n    }\n    return output;\n  }\n}\nexport default RangeNode;","map":{"version":3,"names":["Node","attribute","float","MathUtils","InstancedBufferAttribute","RangeNode","constructor","min","max","getVectorLength","length","isVector2","isVector3","isVector4","isColor","getNodeType","builder","object","isInstancedMesh","getTypeFromLength","construct","geometry","output","vectorLength","attributeName","id","count","array","Float32Array","attributeGeometry","getAttribute","undefined","i","lerp","Math","random","r","g","b","index","minValue","getComponent","maxValue","setAttribute","dispose"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/examples/jsm/nodes/geometry/RangeNode.js"],"sourcesContent":["import Node from '../core/Node.js';\nimport { attribute, float } from '../shadernode/ShaderNodeBaseElements.js';\nimport { MathUtils, InstancedBufferAttribute } from 'three';\n\nclass RangeNode extends Node {\n\n\tconstructor( min, max ) {\n\n\t\tsuper();\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tgetVectorLength() {\n\n\t\tconst min = this.min;\n\n\t\tlet length = 1;\n\n\t\tif ( min.isVector2 ) length = 2;\n\t\telse if ( min.isVector3 ) length = 3;\n\t\telse if ( min.isVector4 ) length = 4;\n\t\telse if ( min.isColor ) length = 3;\n\n\t\treturn length;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn ( builder.object.isInstancedMesh === true ) ? builder.getTypeFromLength( this.getVectorLength() ) : 'float';\n\n\t}\n\n\tconstruct( builder ) {\n\n\t\tconst { min, max } = this;\n\t\tconst { object, geometry } = builder;\n\n\t\tlet output = null;\n\n\t\tif ( object.isInstancedMesh === true ) {\n\n\t\t\tconst vectorLength = this.getVectorLength();\n\t\t\tconst attributeName = 'node' + this.id;\n\n\t\t\tconst length = vectorLength * object.count;\n\t\t\tconst array = new Float32Array( length );\n\n\t\t\tconst attributeGeometry = geometry.getAttribute( attributeName );\n\n\t\t\tif ( attributeGeometry === undefined || attributeGeometry.array.length < length ) {\n\n\t\t\t\tif ( vectorLength === 1 ) {\n\n\t\t\t\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\t\t\t\tarray[ i ] = MathUtils.lerp( min, max, Math.random() );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( min.isColor ) {\n\n\t\t\t\t\tfor ( let i = 0; i < length; i += 3 ) {\n\n\t\t\t\t\t\tarray[ i ] = MathUtils.lerp( min.r, max.r, Math.random() );\n\t\t\t\t\t\tarray[ i + 1 ] = MathUtils.lerp( min.g, max.g, Math.random() );\n\t\t\t\t\t\tarray[ i + 2 ] = MathUtils.lerp( min.b, max.b, Math.random() );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\t\t\t\tconst index = i % vectorLength;\n\n\t\t\t\t\t\tconst minValue = min.getComponent( index );\n\t\t\t\t\t\tconst maxValue = max.getComponent( index );\n\n\t\t\t\t\t\tarray[ i ] = MathUtils.lerp( minValue, maxValue, Math.random() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( attributeName, new InstancedBufferAttribute( array, vectorLength ) );\n\n\t\t\t\tgeometry.dispose();\n\n\t\t\t}\n\n\t\t\toutput = attribute( attributeName, builder.getTypeFromLength( vectorLength ) );\n\n\t\t} else {\n\n\t\t\toutput = float( 0 );\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n}\n\nexport default RangeNode;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}