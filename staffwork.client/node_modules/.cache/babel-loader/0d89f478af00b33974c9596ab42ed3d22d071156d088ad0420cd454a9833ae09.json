{"ast":null,"code":"import { Material, ShaderMaterial } from 'three';\nimport { getNodesKeys, getCacheKey } from '../core/NodeUtils.js';\nimport ExpressionNode from '../core/ExpressionNode.js';\nimport { float, vec3, vec4, assign, label, mul, bypass, attribute, positionLocal, skinning, instance, modelViewProjection, lightingContext, colorSpace, materialAlphaTest, materialColor, materialOpacity } from '../shadernode/ShaderNodeElements.js';\nclass NodeMaterial extends ShaderMaterial {\n  constructor() {\n    super();\n    this.isNodeMaterial = true;\n    this.type = this.constructor.name;\n    this.lights = true;\n  }\n  build(builder) {\n    this.generatePosition(builder);\n    const {\n      lightsNode\n    } = this;\n    const {\n      diffuseColorNode\n    } = this.generateDiffuseColor(builder);\n    const outgoingLightNode = this.generateLight(builder, {\n      diffuseColorNode,\n      lightsNode\n    });\n    this.generateOutput(builder, {\n      diffuseColorNode,\n      outgoingLightNode\n    });\n  }\n  customProgramCacheKey() {\n    return getCacheKey(this);\n  }\n  generatePosition(builder) {\n    const object = builder.object;\n\n    // < VERTEX STAGE >\n\n    let vertex = positionLocal;\n    if (this.positionNode !== null) {\n      vertex = bypass(vertex, assign(positionLocal, this.positionNode));\n    }\n    if (object.instanceMatrix?.isInstancedBufferAttribute === true && builder.isAvailable('instance') === true) {\n      vertex = bypass(vertex, instance(object));\n    }\n    if (object.isSkinnedMesh === true) {\n      vertex = bypass(vertex, skinning(object));\n    }\n    builder.context.vertex = vertex;\n    builder.addFlow('vertex', modelViewProjection());\n  }\n  generateDiffuseColor(builder) {\n    // < FRAGMENT STAGE >\n\n    let colorNode = vec4(this.colorNode || materialColor);\n    let opacityNode = this.opacityNode ? float(this.opacityNode) : materialOpacity;\n\n    // VERTEX COLORS\n\n    if (this.vertexColors === true && builder.geometry.hasAttribute('color')) {\n      colorNode = vec4(mul(colorNode.xyz, attribute('color')), colorNode.a);\n    }\n\n    // COLOR\n\n    colorNode = builder.addFlow('fragment', label(colorNode, 'Color'));\n    const diffuseColorNode = builder.addFlow('fragment', label(colorNode, 'DiffuseColor'));\n\n    // OPACITY\n\n    opacityNode = builder.addFlow('fragment', label(opacityNode, 'OPACITY'));\n    builder.addFlow('fragment', assign(diffuseColorNode.a, mul(diffuseColorNode.a, opacityNode)));\n\n    // ALPHA TEST\n\n    if (this.alphaTestNode || this.alphaTest > 0) {\n      const alphaTestNode = this.alphaTestNode ? float(this.alphaTestNode) : materialAlphaTest;\n      builder.addFlow('fragment', label(alphaTestNode, 'AlphaTest'));\n\n      // @TODO: remove ExpressionNode here and then possibly remove it completely\n      builder.addFlow('fragment', new ExpressionNode('if ( DiffuseColor.a <= AlphaTest ) { discard; }'));\n    }\n    return {\n      colorNode,\n      diffuseColorNode\n    };\n  }\n  generateLight(builder, _ref) {\n    let {\n      diffuseColorNode,\n      lightingModelNode,\n      lightsNode = builder.lightsNode\n    } = _ref;\n    // < ANALYTIC LIGHTS >\n\n    // OUTGOING LIGHT\n\n    let outgoingLightNode = diffuseColorNode.xyz;\n    if (lightsNode && lightsNode.hasLight !== false) outgoingLightNode = builder.addFlow('fragment', label(lightingContext(lightsNode, lightingModelNode), 'Light'));\n    return outgoingLightNode;\n  }\n  generateOutput(builder, _ref2) {\n    let {\n      diffuseColorNode,\n      outgoingLightNode\n    } = _ref2;\n    // OUTPUT\n\n    let outputNode = vec4(outgoingLightNode, diffuseColorNode.a);\n\n    // ENCODING\n\n    outputNode = colorSpace(outputNode, builder.renderer.outputEncoding);\n\n    // FOG\n\n    if (builder.fogNode) outputNode = vec4(vec3(builder.fogNode.mix(outputNode)), outputNode.w);\n\n    // RESULT\n\n    builder.addFlow('fragment', label(outputNode, 'Output'));\n    return outputNode;\n  }\n  setDefaultValues(values) {\n    // This approach is to reuse the native refreshUniforms*\n    // and turn available the use of features like transmission and environment in core\n\n    for (const property in values) {\n      const value = values[property];\n      if (this[property] === undefined) {\n        this[property] = value?.clone?.() || value;\n      }\n    }\n    Object.assign(this.defines, values.defines);\n  }\n  toJSON(meta) {\n    const isRoot = meta === undefined || typeof meta === 'string';\n    if (isRoot) {\n      meta = {\n        textures: {},\n        images: {},\n        nodes: {}\n      };\n    }\n    const data = Material.prototype.toJSON.call(this, meta);\n    const nodeKeys = getNodesKeys(this);\n    data.inputNodes = {};\n    for (const name of nodeKeys) {\n      data.inputNodes[name] = this[name].toJSON(meta).uuid;\n    }\n\n    // TODO: Copied from Object3D.toJSON\n\n    function extractFromCache(cache) {\n      const values = [];\n      for (const key in cache) {\n        const data = cache[key];\n        delete data.metadata;\n        values.push(data);\n      }\n      return values;\n    }\n    if (isRoot) {\n      const textures = extractFromCache(meta.textures);\n      const images = extractFromCache(meta.images);\n      const nodes = extractFromCache(meta.nodes);\n      if (textures.length > 0) data.textures = textures;\n      if (images.length > 0) data.images = images;\n      if (nodes.length > 0) data.nodes = nodes;\n    }\n    return data;\n  }\n  static fromMaterial( /*material*/) {}\n}\nexport default NodeMaterial;","map":{"version":3,"names":["Material","ShaderMaterial","getNodesKeys","getCacheKey","ExpressionNode","float","vec3","vec4","assign","label","mul","bypass","attribute","positionLocal","skinning","instance","modelViewProjection","lightingContext","colorSpace","materialAlphaTest","materialColor","materialOpacity","NodeMaterial","constructor","isNodeMaterial","type","name","lights","build","builder","generatePosition","lightsNode","diffuseColorNode","generateDiffuseColor","outgoingLightNode","generateLight","generateOutput","customProgramCacheKey","object","vertex","positionNode","instanceMatrix","isInstancedBufferAttribute","isAvailable","isSkinnedMesh","context","addFlow","colorNode","opacityNode","vertexColors","geometry","hasAttribute","xyz","a","alphaTestNode","alphaTest","lightingModelNode","hasLight","outputNode","renderer","outputEncoding","fogNode","mix","w","setDefaultValues","values","property","value","undefined","clone","Object","defines","toJSON","meta","isRoot","textures","images","nodes","data","prototype","call","nodeKeys","inputNodes","uuid","extractFromCache","cache","key","metadata","push","length","fromMaterial"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/examples/jsm/nodes/materials/NodeMaterial.js"],"sourcesContent":["import { Material, ShaderMaterial } from 'three';\nimport { getNodesKeys, getCacheKey } from '../core/NodeUtils.js';\nimport ExpressionNode from '../core/ExpressionNode.js';\nimport {\n\tfloat, vec3, vec4,\n\tassign, label, mul, bypass, attribute,\n\tpositionLocal, skinning, instance, modelViewProjection, lightingContext, colorSpace,\n\tmaterialAlphaTest, materialColor, materialOpacity\n} from '../shadernode/ShaderNodeElements.js';\n\nclass NodeMaterial extends ShaderMaterial {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isNodeMaterial = true;\n\n\t\tthis.type = this.constructor.name;\n\n\t\tthis.lights = true;\n\n\t}\n\n\tbuild( builder ) {\n\n\t\tthis.generatePosition( builder );\n\n\t\tconst { lightsNode } = this;\n\t\tconst { diffuseColorNode } = this.generateDiffuseColor( builder );\n\n\t\tconst outgoingLightNode = this.generateLight( builder, { diffuseColorNode, lightsNode } );\n\n\t\tthis.generateOutput( builder, { diffuseColorNode, outgoingLightNode } );\n\n\t}\n\n\tcustomProgramCacheKey() {\n\n\t\treturn getCacheKey( this );\n\n\t}\n\n\tgeneratePosition( builder ) {\n\n\t\tconst object = builder.object;\n\n\t\t// < VERTEX STAGE >\n\n\t\tlet vertex = positionLocal;\n\n\t\tif ( this.positionNode !== null ) {\n\n\t\t\tvertex = bypass( vertex, assign( positionLocal, this.positionNode ) );\n\n\t\t}\n\n\t\tif ( object.instanceMatrix?.isInstancedBufferAttribute === true && builder.isAvailable( 'instance' ) === true ) {\n\n\t\t\tvertex = bypass( vertex, instance( object ) );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh === true ) {\n\n\t\t\tvertex = bypass( vertex, skinning( object ) );\n\n\t\t}\n\n\t\tbuilder.context.vertex = vertex;\n\n\t\tbuilder.addFlow( 'vertex', modelViewProjection() );\n\n\t}\n\n\tgenerateDiffuseColor( builder ) {\n\n\t\t// < FRAGMENT STAGE >\n\n\t\tlet colorNode = vec4( this.colorNode || materialColor );\n\t\tlet opacityNode = this.opacityNode ? float( this.opacityNode ) : materialOpacity;\n\n\t\t// VERTEX COLORS\n\n\t\tif ( this.vertexColors === true && builder.geometry.hasAttribute( 'color' ) ) {\n\n\t\t\tcolorNode = vec4( mul( colorNode.xyz, attribute( 'color' ) ), colorNode.a );\n\t\t\n\t\t}\n\n\t\t// COLOR\n\n\t\tcolorNode = builder.addFlow( 'fragment', label( colorNode, 'Color' ) );\n\t\tconst diffuseColorNode = builder.addFlow( 'fragment', label( colorNode, 'DiffuseColor' ) );\n\n\t\t// OPACITY\n\n\t\topacityNode = builder.addFlow( 'fragment', label( opacityNode, 'OPACITY' ) );\n\t\tbuilder.addFlow( 'fragment', assign( diffuseColorNode.a, mul( diffuseColorNode.a, opacityNode ) ) );\n\n\t\t// ALPHA TEST\n\n\t\tif ( this.alphaTestNode || this.alphaTest > 0 ) {\n\n\t\t\tconst alphaTestNode = this.alphaTestNode ? float( this.alphaTestNode ) : materialAlphaTest;\n\n\t\t\tbuilder.addFlow( 'fragment', label( alphaTestNode, 'AlphaTest' ) );\n\n\t\t\t// @TODO: remove ExpressionNode here and then possibly remove it completely\n\t\t\tbuilder.addFlow( 'fragment', new ExpressionNode( 'if ( DiffuseColor.a <= AlphaTest ) { discard; }' ) );\n\n\t\t}\n\n\t\treturn { colorNode, diffuseColorNode };\n\n\t}\n\n\tgenerateLight( builder, { diffuseColorNode, lightingModelNode, lightsNode = builder.lightsNode } ) {\n\n\t\t// < ANALYTIC LIGHTS >\n\n\t\t// OUTGOING LIGHT\n\n\t\tlet outgoingLightNode = diffuseColorNode.xyz;\n\t\tif ( lightsNode && lightsNode.hasLight !== false ) outgoingLightNode = builder.addFlow( 'fragment', label( lightingContext( lightsNode, lightingModelNode ), 'Light' ) );\n\n\t\treturn outgoingLightNode;\n\n\t}\n\n\tgenerateOutput( builder, { diffuseColorNode, outgoingLightNode } ) {\n\n\t\t// OUTPUT\n\n\t\tlet outputNode = vec4( outgoingLightNode, diffuseColorNode.a );\n\n\t\t// ENCODING\n\n\t\toutputNode = colorSpace( outputNode, builder.renderer.outputEncoding );\n\n\t\t// FOG\n\n\t\tif ( builder.fogNode ) outputNode = vec4( vec3( builder.fogNode.mix( outputNode ) ), outputNode.w );\n\n\t\t// RESULT\n\n\t\tbuilder.addFlow( 'fragment', label( outputNode, 'Output' ) );\n\n\t\treturn outputNode;\n\n\t}\n\n\tsetDefaultValues( values ) {\n\n\t\t// This approach is to reuse the native refreshUniforms*\n\t\t// and turn available the use of features like transmission and environment in core\n\n\t\tfor ( const property in values ) {\n\n\t\t\tconst value = values[ property ];\n\n\t\t\tif ( this[ property ] === undefined ) {\n\n\t\t\t\tthis[ property ] = value?.clone?.() || value;\n\n\t\t\t}\n\n\t\t}\n\n\t\tObject.assign( this.defines, values.defines );\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst isRoot = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( isRoot ) {\n\n\t\t\tmeta = {\n\t\t\t\ttextures: {},\n\t\t\t\timages: {},\n\t\t\t\tnodes: {}\n\t\t\t};\n\n\t\t}\n\n\t\tconst data = Material.prototype.toJSON.call( this, meta );\n\t\tconst nodeKeys = getNodesKeys( this );\n\n\t\tdata.inputNodes = {};\n\n\t\tfor ( const name of nodeKeys ) {\n\n\t\t\tdata.inputNodes[ name ] = this[ name ].toJSON( meta ).uuid;\n\n\t\t}\n\n\t\t// TODO: Copied from Object3D.toJSON\n\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tconst values = [];\n\n\t\t\tfor ( const key in cache ) {\n\n\t\t\t\tconst data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t\tif ( isRoot ) {\n\n\t\t\tconst textures = extractFromCache( meta.textures );\n\t\t\tconst images = extractFromCache( meta.images );\n\t\t\tconst nodes = extractFromCache( meta.nodes );\n\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\tif ( images.length > 0 ) data.images = images;\n\t\t\tif ( nodes.length > 0 ) data.nodes = nodes;\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tstatic fromMaterial( /*material*/ ) { }\n\n}\n\nexport default NodeMaterial;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}