{"ast":null,"code":"import { LinearFilter } from '../constants.js';\nimport { FileLoader } from './FileLoader.js';\nimport { CompressedTexture } from '../textures/CompressedTexture.js';\nimport { Loader } from './Loader.js';\n\n/**\n * Abstract Base class to block based textures loader (dds, pvr, ...)\n *\n * Sub classes have to implement the parse() method which will be used in load().\n */\n\nclass CompressedTextureLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const images = [];\n    const texture = new CompressedTexture();\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    let loaded = 0;\n    function loadTexture(i) {\n      loader.load(url[i], function (buffer) {\n        const texDatas = scope.parse(buffer, true);\n        images[i] = {\n          width: texDatas.width,\n          height: texDatas.height,\n          format: texDatas.format,\n          mipmaps: texDatas.mipmaps\n        };\n        loaded += 1;\n        if (loaded === 6) {\n          if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;\n          texture.image = images;\n          texture.format = texDatas.format;\n          texture.needsUpdate = true;\n          if (onLoad) onLoad(texture);\n        }\n      }, onProgress, onError);\n    }\n    if (Array.isArray(url)) {\n      for (let i = 0, il = url.length; i < il; ++i) {\n        loadTexture(i);\n      }\n    } else {\n      // compressed cubemap texture stored in a single DDS file\n\n      loader.load(url, function (buffer) {\n        const texDatas = scope.parse(buffer, true);\n        if (texDatas.isCubemap) {\n          const faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n          for (let f = 0; f < faces; f++) {\n            images[f] = {\n              mipmaps: []\n            };\n            for (let i = 0; i < texDatas.mipmapCount; i++) {\n              images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);\n              images[f].format = texDatas.format;\n              images[f].width = texDatas.width;\n              images[f].height = texDatas.height;\n            }\n          }\n          texture.image = images;\n        } else {\n          texture.image.width = texDatas.width;\n          texture.image.height = texDatas.height;\n          texture.mipmaps = texDatas.mipmaps;\n        }\n        if (texDatas.mipmapCount === 1) {\n          texture.minFilter = LinearFilter;\n        }\n        texture.format = texDatas.format;\n        texture.needsUpdate = true;\n        if (onLoad) onLoad(texture);\n      }, onProgress, onError);\n    }\n    return texture;\n  }\n}\nexport { CompressedTextureLoader };","map":{"version":3,"names":["LinearFilter","FileLoader","CompressedTexture","Loader","CompressedTextureLoader","constructor","manager","load","url","onLoad","onProgress","onError","scope","images","texture","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","loaded","loadTexture","i","buffer","texDatas","parse","width","height","format","mipmaps","mipmapCount","minFilter","image","needsUpdate","Array","isArray","il","length","isCubemap","faces","f","push"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/loaders/CompressedTextureLoader.js"],"sourcesContent":["import { LinearFilter } from '../constants.js';\nimport { FileLoader } from './FileLoader.js';\nimport { CompressedTexture } from '../textures/CompressedTexture.js';\nimport { Loader } from './Loader.js';\n\n/**\n * Abstract Base class to block based textures loader (dds, pvr, ...)\n *\n * Sub classes have to implement the parse() method which will be used in load().\n */\n\nclass CompressedTextureLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst images = [];\n\n\t\tconst texture = new CompressedTexture();\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\n\t\tlet loaded = 0;\n\n\t\tfunction loadTexture( i ) {\n\n\t\t\tloader.load( url[ i ], function ( buffer ) {\n\n\t\t\t\tconst texDatas = scope.parse( buffer, true );\n\n\t\t\t\timages[ i ] = {\n\t\t\t\t\twidth: texDatas.width,\n\t\t\t\t\theight: texDatas.height,\n\t\t\t\t\tformat: texDatas.format,\n\t\t\t\t\tmipmaps: texDatas.mipmaps\n\t\t\t\t};\n\n\t\t\t\tloaded += 1;\n\n\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\tif ( texDatas.mipmapCount === 1 ) texture.minFilter = LinearFilter;\n\n\t\t\t\t\ttexture.image = images;\n\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\tif ( Array.isArray( url ) ) {\n\n\t\t\tfor ( let i = 0, il = url.length; i < il; ++ i ) {\n\n\t\t\t\tloadTexture( i );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// compressed cubemap texture stored in a single DDS file\n\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tconst texDatas = scope.parse( buffer, true );\n\n\t\t\t\tif ( texDatas.isCubemap ) {\n\n\t\t\t\t\tconst faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\n\t\t\t\t\tfor ( let f = 0; f < faces; f ++ ) {\n\n\t\t\t\t\t\timages[ f ] = { mipmaps: [] };\n\n\t\t\t\t\t\tfor ( let i = 0; i < texDatas.mipmapCount; i ++ ) {\n\n\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\n\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\n\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\n\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.image = images;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttexture.image.width = texDatas.width;\n\t\t\t\t\ttexture.image.height = texDatas.height;\n\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\n\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t\t}\n\n\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n}\n\n\nexport { CompressedTextureLoader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}