{"ast":null,"code":"import * as MathUtils from '../../math/MathUtils.js';\nimport { Vector2 } from '../../math/Vector2.js';\nimport { Vector3 } from '../../math/Vector3.js';\nimport { Matrix4 } from '../../math/Matrix4.js';\n\n/**\n * Extensible curve object.\n *\n * Some common of curve methods:\n * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )\n * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )\n * .getPoints(), .getSpacedPoints()\n * .getLength()\n * .updateArcLengths()\n *\n * This following curves inherit from THREE.Curve:\n *\n * -- 2D curves --\n * THREE.ArcCurve\n * THREE.CubicBezierCurve\n * THREE.EllipseCurve\n * THREE.LineCurve\n * THREE.QuadraticBezierCurve\n * THREE.SplineCurve\n *\n * -- 3D curves --\n * THREE.CatmullRomCurve3\n * THREE.CubicBezierCurve3\n * THREE.LineCurve3\n * THREE.QuadraticBezierCurve3\n *\n * A series of curves can be represented as a THREE.CurvePath.\n *\n **/\n\nclass Curve {\n  constructor() {\n    this.type = 'Curve';\n    this.arcLengthDivisions = 200;\n  }\n\n  // Virtual base class method to overwrite and implement in subclasses\n  //\t- t [0 .. 1]\n\n  getPoint( /* t, optionalTarget */\n  ) {\n    console.warn('THREE.Curve: .getPoint() not implemented.');\n    return null;\n  }\n\n  // Get point at relative position in curve according to arc length\n  // - u [0 .. 1]\n\n  getPointAt(u, optionalTarget) {\n    const t = this.getUtoTmapping(u);\n    return this.getPoint(t, optionalTarget);\n  }\n\n  // Get sequence of points using getPoint( t )\n\n  getPoints() {\n    let divisions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;\n    const points = [];\n    for (let d = 0; d <= divisions; d++) {\n      points.push(this.getPoint(d / divisions));\n    }\n    return points;\n  }\n\n  // Get sequence of points using getPointAt( u )\n\n  getSpacedPoints() {\n    let divisions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;\n    const points = [];\n    for (let d = 0; d <= divisions; d++) {\n      points.push(this.getPointAt(d / divisions));\n    }\n    return points;\n  }\n\n  // Get total curve arc length\n\n  getLength() {\n    const lengths = this.getLengths();\n    return lengths[lengths.length - 1];\n  }\n\n  // Get list of cumulative segment lengths\n\n  getLengths() {\n    let divisions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.arcLengthDivisions;\n    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {\n      return this.cacheArcLengths;\n    }\n    this.needsUpdate = false;\n    const cache = [];\n    let current,\n      last = this.getPoint(0);\n    let sum = 0;\n    cache.push(0);\n    for (let p = 1; p <= divisions; p++) {\n      current = this.getPoint(p / divisions);\n      sum += current.distanceTo(last);\n      cache.push(sum);\n      last = current;\n    }\n    this.cacheArcLengths = cache;\n    return cache; // { sums: cache, sum: sum }; Sum is in the last element.\n  }\n\n  updateArcLengths() {\n    this.needsUpdate = true;\n    this.getLengths();\n  }\n\n  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n  getUtoTmapping(u, distance) {\n    const arcLengths = this.getLengths();\n    let i = 0;\n    const il = arcLengths.length;\n    let targetArcLength; // The targeted u distance value to get\n\n    if (distance) {\n      targetArcLength = distance;\n    } else {\n      targetArcLength = u * arcLengths[il - 1];\n    }\n\n    // binary search for the index with largest value smaller than target u distance\n\n    let low = 0,\n      high = il - 1,\n      comparison;\n    while (low <= high) {\n      i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n      comparison = arcLengths[i] - targetArcLength;\n      if (comparison < 0) {\n        low = i + 1;\n      } else if (comparison > 0) {\n        high = i - 1;\n      } else {\n        high = i;\n        break;\n\n        // DONE\n      }\n    }\n\n    i = high;\n    if (arcLengths[i] === targetArcLength) {\n      return i / (il - 1);\n    }\n\n    // we could get finer grain at lengths, or use simple interpolation between two points\n\n    const lengthBefore = arcLengths[i];\n    const lengthAfter = arcLengths[i + 1];\n    const segmentLength = lengthAfter - lengthBefore;\n\n    // determine where we are between the 'before' and 'after' points\n\n    const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;\n\n    // add that fractional amount to t\n\n    const t = (i + segmentFraction) / (il - 1);\n    return t;\n  }\n\n  // Returns a unit vector tangent at t\n  // In case any sub curve does not implement its tangent derivation,\n  // 2 points a small delta apart will be used to find its gradient\n  // which seems to give a reasonable approximation\n\n  getTangent(t, optionalTarget) {\n    const delta = 0.0001;\n    let t1 = t - delta;\n    let t2 = t + delta;\n\n    // Capping in case of danger\n\n    if (t1 < 0) t1 = 0;\n    if (t2 > 1) t2 = 1;\n    const pt1 = this.getPoint(t1);\n    const pt2 = this.getPoint(t2);\n    const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());\n    tangent.copy(pt2).sub(pt1).normalize();\n    return tangent;\n  }\n  getTangentAt(u, optionalTarget) {\n    const t = this.getUtoTmapping(u);\n    return this.getTangent(t, optionalTarget);\n  }\n  computeFrenetFrames(segments, closed) {\n    // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\n    const normal = new Vector3();\n    const tangents = [];\n    const normals = [];\n    const binormals = [];\n    const vec = new Vector3();\n    const mat = new Matrix4();\n\n    // compute the tangent vectors for each segment on the curve\n\n    for (let i = 0; i <= segments; i++) {\n      const u = i / segments;\n      tangents[i] = this.getTangentAt(u, new Vector3());\n    }\n\n    // select an initial normal vector perpendicular to the first tangent vector,\n    // and in the direction of the minimum tangent xyz component\n\n    normals[0] = new Vector3();\n    binormals[0] = new Vector3();\n    let min = Number.MAX_VALUE;\n    const tx = Math.abs(tangents[0].x);\n    const ty = Math.abs(tangents[0].y);\n    const tz = Math.abs(tangents[0].z);\n    if (tx <= min) {\n      min = tx;\n      normal.set(1, 0, 0);\n    }\n    if (ty <= min) {\n      min = ty;\n      normal.set(0, 1, 0);\n    }\n    if (tz <= min) {\n      normal.set(0, 0, 1);\n    }\n    vec.crossVectors(tangents[0], normal).normalize();\n    normals[0].crossVectors(tangents[0], vec);\n    binormals[0].crossVectors(tangents[0], normals[0]);\n\n    // compute the slowly-varying normal and binormal vectors for each segment on the curve\n\n    for (let i = 1; i <= segments; i++) {\n      normals[i] = normals[i - 1].clone();\n      binormals[i] = binormals[i - 1].clone();\n      vec.crossVectors(tangents[i - 1], tangents[i]);\n      if (vec.length() > Number.EPSILON) {\n        vec.normalize();\n        const theta = Math.acos(MathUtils.clamp(tangents[i - 1].dot(tangents[i]), -1, 1)); // clamp for floating pt errors\n\n        normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));\n      }\n      binormals[i].crossVectors(tangents[i], normals[i]);\n    }\n\n    // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n    if (closed === true) {\n      let theta = Math.acos(MathUtils.clamp(normals[0].dot(normals[segments]), -1, 1));\n      theta /= segments;\n      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {\n        theta = -theta;\n      }\n      for (let i = 1; i <= segments; i++) {\n        // twist a little...\n        normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));\n        binormals[i].crossVectors(tangents[i], normals[i]);\n      }\n    }\n    return {\n      tangents: tangents,\n      normals: normals,\n      binormals: binormals\n    };\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  copy(source) {\n    this.arcLengthDivisions = source.arcLengthDivisions;\n    return this;\n  }\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: 'Curve',\n        generator: 'Curve.toJSON'\n      }\n    };\n    data.arcLengthDivisions = this.arcLengthDivisions;\n    data.type = this.type;\n    return data;\n  }\n  fromJSON(json) {\n    this.arcLengthDivisions = json.arcLengthDivisions;\n    return this;\n  }\n}\nexport { Curve };","map":{"version":3,"names":["MathUtils","Vector2","Vector3","Matrix4","Curve","constructor","type","arcLengthDivisions","getPoint","console","warn","getPointAt","u","optionalTarget","t","getUtoTmapping","getPoints","divisions","points","d","push","getSpacedPoints","getLength","lengths","getLengths","length","cacheArcLengths","needsUpdate","cache","current","last","sum","p","distanceTo","updateArcLengths","distance","arcLengths","i","il","targetArcLength","low","high","comparison","Math","floor","lengthBefore","lengthAfter","segmentLength","segmentFraction","getTangent","delta","t1","t2","pt1","pt2","tangent","isVector2","copy","sub","normalize","getTangentAt","computeFrenetFrames","segments","closed","normal","tangents","normals","binormals","vec","mat","min","Number","MAX_VALUE","tx","abs","x","ty","y","tz","z","set","crossVectors","clone","EPSILON","theta","acos","clamp","dot","applyMatrix4","makeRotationAxis","source","toJSON","data","metadata","version","generator","fromJSON","json"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/extras/core/Curve.js"],"sourcesContent":["import * as MathUtils from '../../math/MathUtils.js';\nimport { Vector2 } from '../../math/Vector2.js';\nimport { Vector3 } from '../../math/Vector3.js';\nimport { Matrix4 } from '../../math/Matrix4.js';\n\n/**\n * Extensible curve object.\n *\n * Some common of curve methods:\n * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )\n * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )\n * .getPoints(), .getSpacedPoints()\n * .getLength()\n * .updateArcLengths()\n *\n * This following curves inherit from THREE.Curve:\n *\n * -- 2D curves --\n * THREE.ArcCurve\n * THREE.CubicBezierCurve\n * THREE.EllipseCurve\n * THREE.LineCurve\n * THREE.QuadraticBezierCurve\n * THREE.SplineCurve\n *\n * -- 3D curves --\n * THREE.CatmullRomCurve3\n * THREE.CubicBezierCurve3\n * THREE.LineCurve3\n * THREE.QuadraticBezierCurve3\n *\n * A series of curves can be represented as a THREE.CurvePath.\n *\n **/\n\nclass Curve {\n\n\tconstructor() {\n\n\t\tthis.type = 'Curve';\n\n\t\tthis.arcLengthDivisions = 200;\n\n\t}\n\n\t// Virtual base class method to overwrite and implement in subclasses\n\t//\t- t [0 .. 1]\n\n\tgetPoint( /* t, optionalTarget */ ) {\n\n\t\tconsole.warn( 'THREE.Curve: .getPoint() not implemented.' );\n\t\treturn null;\n\n\t}\n\n\t// Get point at relative position in curve according to arc length\n\t// - u [0 .. 1]\n\n\tgetPointAt( u, optionalTarget ) {\n\n\t\tconst t = this.getUtoTmapping( u );\n\t\treturn this.getPoint( t, optionalTarget );\n\n\t}\n\n\t// Get sequence of points using getPoint( t )\n\n\tgetPoints( divisions = 5 ) {\n\n\t\tconst points = [];\n\n\t\tfor ( let d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpoints.push( this.getPoint( d / divisions ) );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\t// Get sequence of points using getPointAt( u )\n\n\tgetSpacedPoints( divisions = 5 ) {\n\n\t\tconst points = [];\n\n\t\tfor ( let d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpoints.push( this.getPointAt( d / divisions ) );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\t// Get total curve arc length\n\n\tgetLength() {\n\n\t\tconst lengths = this.getLengths();\n\t\treturn lengths[ lengths.length - 1 ];\n\n\t}\n\n\t// Get list of cumulative segment lengths\n\n\tgetLengths( divisions = this.arcLengthDivisions ) {\n\n\t\tif ( this.cacheArcLengths &&\n\t\t\t( this.cacheArcLengths.length === divisions + 1 ) &&\n\t\t\t! this.needsUpdate ) {\n\n\t\t\treturn this.cacheArcLengths;\n\n\t\t}\n\n\t\tthis.needsUpdate = false;\n\n\t\tconst cache = [];\n\t\tlet current, last = this.getPoint( 0 );\n\t\tlet sum = 0;\n\n\t\tcache.push( 0 );\n\n\t\tfor ( let p = 1; p <= divisions; p ++ ) {\n\n\t\t\tcurrent = this.getPoint( p / divisions );\n\t\t\tsum += current.distanceTo( last );\n\t\t\tcache.push( sum );\n\t\t\tlast = current;\n\n\t\t}\n\n\t\tthis.cacheArcLengths = cache;\n\n\t\treturn cache; // { sums: cache, sum: sum }; Sum is in the last element.\n\n\t}\n\n\tupdateArcLengths() {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.getLengths();\n\n\t}\n\n\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n\tgetUtoTmapping( u, distance ) {\n\n\t\tconst arcLengths = this.getLengths();\n\n\t\tlet i = 0;\n\t\tconst il = arcLengths.length;\n\n\t\tlet targetArcLength; // The targeted u distance value to get\n\n\t\tif ( distance ) {\n\n\t\t\ttargetArcLength = distance;\n\n\t\t} else {\n\n\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\n\n\t\t}\n\n\t\t// binary search for the index with largest value smaller than target u distance\n\n\t\tlet low = 0, high = il - 1, comparison;\n\n\t\twhile ( low <= high ) {\n\n\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\n\n\t\t\tif ( comparison < 0 ) {\n\n\t\t\t\tlow = i + 1;\n\n\t\t\t} else if ( comparison > 0 ) {\n\n\t\t\t\thigh = i - 1;\n\n\t\t\t} else {\n\n\t\t\t\thigh = i;\n\t\t\t\tbreak;\n\n\t\t\t\t// DONE\n\n\t\t\t}\n\n\t\t}\n\n\t\ti = high;\n\n\t\tif ( arcLengths[ i ] === targetArcLength ) {\n\n\t\t\treturn i / ( il - 1 );\n\n\t\t}\n\n\t\t// we could get finer grain at lengths, or use simple interpolation between two points\n\n\t\tconst lengthBefore = arcLengths[ i ];\n\t\tconst lengthAfter = arcLengths[ i + 1 ];\n\n\t\tconst segmentLength = lengthAfter - lengthBefore;\n\n\t\t// determine where we are between the 'before' and 'after' points\n\n\t\tconst segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\n\t\t// add that fractional amount to t\n\n\t\tconst t = ( i + segmentFraction ) / ( il - 1 );\n\n\t\treturn t;\n\n\t}\n\n\t// Returns a unit vector tangent at t\n\t// In case any sub curve does not implement its tangent derivation,\n\t// 2 points a small delta apart will be used to find its gradient\n\t// which seems to give a reasonable approximation\n\n\tgetTangent( t, optionalTarget ) {\n\n\t\tconst delta = 0.0001;\n\t\tlet t1 = t - delta;\n\t\tlet t2 = t + delta;\n\n\t\t// Capping in case of danger\n\n\t\tif ( t1 < 0 ) t1 = 0;\n\t\tif ( t2 > 1 ) t2 = 1;\n\n\t\tconst pt1 = this.getPoint( t1 );\n\t\tconst pt2 = this.getPoint( t2 );\n\n\t\tconst tangent = optionalTarget || ( ( pt1.isVector2 ) ? new Vector2() : new Vector3() );\n\n\t\ttangent.copy( pt2 ).sub( pt1 ).normalize();\n\n\t\treturn tangent;\n\n\t}\n\n\tgetTangentAt( u, optionalTarget ) {\n\n\t\tconst t = this.getUtoTmapping( u );\n\t\treturn this.getTangent( t, optionalTarget );\n\n\t}\n\n\tcomputeFrenetFrames( segments, closed ) {\n\n\t\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\n\t\tconst normal = new Vector3();\n\n\t\tconst tangents = [];\n\t\tconst normals = [];\n\t\tconst binormals = [];\n\n\t\tconst vec = new Vector3();\n\t\tconst mat = new Matrix4();\n\n\t\t// compute the tangent vectors for each segment on the curve\n\n\t\tfor ( let i = 0; i <= segments; i ++ ) {\n\n\t\t\tconst u = i / segments;\n\n\t\t\ttangents[ i ] = this.getTangentAt( u, new Vector3() );\n\n\t\t}\n\n\t\t// select an initial normal vector perpendicular to the first tangent vector,\n\t\t// and in the direction of the minimum tangent xyz component\n\n\t\tnormals[ 0 ] = new Vector3();\n\t\tbinormals[ 0 ] = new Vector3();\n\t\tlet min = Number.MAX_VALUE;\n\t\tconst tx = Math.abs( tangents[ 0 ].x );\n\t\tconst ty = Math.abs( tangents[ 0 ].y );\n\t\tconst tz = Math.abs( tangents[ 0 ].z );\n\n\t\tif ( tx <= min ) {\n\n\t\t\tmin = tx;\n\t\t\tnormal.set( 1, 0, 0 );\n\n\t\t}\n\n\t\tif ( ty <= min ) {\n\n\t\t\tmin = ty;\n\t\t\tnormal.set( 0, 1, 0 );\n\n\t\t}\n\n\t\tif ( tz <= min ) {\n\n\t\t\tnormal.set( 0, 0, 1 );\n\n\t\t}\n\n\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\n\n\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\n\t\t// compute the slowly-varying normal and binormal vectors for each segment on the curve\n\n\t\tfor ( let i = 1; i <= segments; i ++ ) {\n\n\t\t\tnormals[ i ] = normals[ i - 1 ].clone();\n\n\t\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\n\n\t\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\n\n\t\t\tif ( vec.length() > Number.EPSILON ) {\n\n\t\t\t\tvec.normalize();\n\n\t\t\t\tconst theta = Math.acos( MathUtils.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\n\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\n\t\t\t}\n\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t}\n\n\t\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\t\tif ( closed === true ) {\n\n\t\t\tlet theta = Math.acos( MathUtils.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\n\t\t\ttheta /= segments;\n\n\t\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\n\n\t\t\t\ttheta = - theta;\n\n\t\t\t}\n\n\t\t\tfor ( let i = 1; i <= segments; i ++ ) {\n\n\t\t\t\t// twist a little...\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\t\t\ttangents: tangents,\n\t\t\tnormals: normals,\n\t\t\tbinormals: binormals\n\t\t};\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.arcLengthDivisions = source.arcLengthDivisions;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'Curve',\n\t\t\t\tgenerator: 'Curve.toJSON'\n\t\t\t}\n\t\t};\n\n\t\tdata.arcLengthDivisions = this.arcLengthDivisions;\n\t\tdata.type = this.type;\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tthis.arcLengthDivisions = json.arcLengthDivisions;\n\n\t\treturn this;\n\n\t}\n\n}\n\n\nexport { Curve };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}