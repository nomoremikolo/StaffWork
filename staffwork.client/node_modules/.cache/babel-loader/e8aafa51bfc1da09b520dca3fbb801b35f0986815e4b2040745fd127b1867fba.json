{"ast":null,"code":"import { RGBAFormat, FloatType } from '../constants.js';\nimport { Bone } from './Bone.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { DataTexture } from '../textures/DataTexture.js';\nimport * as MathUtils from '../math/MathUtils.js';\nconst _offsetMatrix = /*@__PURE__*/new Matrix4();\nconst _identityMatrix = /*@__PURE__*/new Matrix4();\nclass Skeleton {\n  constructor() {\n    let bones = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let boneInverses = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    this.uuid = MathUtils.generateUUID();\n    this.bones = bones.slice(0);\n    this.boneInverses = boneInverses;\n    this.boneMatrices = null;\n    this.boneTexture = null;\n    this.boneTextureSize = 0;\n    this.frame = -1;\n    this.init();\n  }\n  init() {\n    const bones = this.bones;\n    const boneInverses = this.boneInverses;\n    this.boneMatrices = new Float32Array(bones.length * 16);\n\n    // calculate inverse bone matrices if necessary\n\n    if (boneInverses.length === 0) {\n      this.calculateInverses();\n    } else {\n      // handle special case\n\n      if (bones.length !== boneInverses.length) {\n        console.warn('THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.');\n        this.boneInverses = [];\n        for (let i = 0, il = this.bones.length; i < il; i++) {\n          this.boneInverses.push(new Matrix4());\n        }\n      }\n    }\n  }\n  calculateInverses() {\n    this.boneInverses.length = 0;\n    for (let i = 0, il = this.bones.length; i < il; i++) {\n      const inverse = new Matrix4();\n      if (this.bones[i]) {\n        inverse.copy(this.bones[i].matrixWorld).invert();\n      }\n      this.boneInverses.push(inverse);\n    }\n  }\n  pose() {\n    // recover the bind-time world matrices\n\n    for (let i = 0, il = this.bones.length; i < il; i++) {\n      const bone = this.bones[i];\n      if (bone) {\n        bone.matrixWorld.copy(this.boneInverses[i]).invert();\n      }\n    }\n\n    // compute the local matrices, positions, rotations and scales\n\n    for (let i = 0, il = this.bones.length; i < il; i++) {\n      const bone = this.bones[i];\n      if (bone) {\n        if (bone.parent && bone.parent.isBone) {\n          bone.matrix.copy(bone.parent.matrixWorld).invert();\n          bone.matrix.multiply(bone.matrixWorld);\n        } else {\n          bone.matrix.copy(bone.matrixWorld);\n        }\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n      }\n    }\n  }\n  update() {\n    const bones = this.bones;\n    const boneInverses = this.boneInverses;\n    const boneMatrices = this.boneMatrices;\n    const boneTexture = this.boneTexture;\n\n    // flatten bone matrices to array\n\n    for (let i = 0, il = bones.length; i < il; i++) {\n      // compute the offset between the current and the original transform\n\n      const matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;\n      _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);\n      _offsetMatrix.toArray(boneMatrices, i * 16);\n    }\n    if (boneTexture !== null) {\n      boneTexture.needsUpdate = true;\n    }\n  }\n  clone() {\n    return new Skeleton(this.bones, this.boneInverses);\n  }\n  computeBoneTexture() {\n    // layout (1 matrix = 4 pixels)\n    //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n    //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n    //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n    //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n    //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n\n    let size = Math.sqrt(this.bones.length * 4); // 4 pixels needed for 1 matrix\n    size = MathUtils.ceilPowerOfTwo(size);\n    size = Math.max(size, 4);\n    const boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel\n    boneMatrices.set(this.boneMatrices); // copy current values\n\n    const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);\n    boneTexture.needsUpdate = true;\n    this.boneMatrices = boneMatrices;\n    this.boneTexture = boneTexture;\n    this.boneTextureSize = size;\n    return this;\n  }\n  getBoneByName(name) {\n    for (let i = 0, il = this.bones.length; i < il; i++) {\n      const bone = this.bones[i];\n      if (bone.name === name) {\n        return bone;\n      }\n    }\n    return undefined;\n  }\n  dispose() {\n    if (this.boneTexture !== null) {\n      this.boneTexture.dispose();\n      this.boneTexture = null;\n    }\n  }\n  fromJSON(json, bones) {\n    this.uuid = json.uuid;\n    for (let i = 0, l = json.bones.length; i < l; i++) {\n      const uuid = json.bones[i];\n      let bone = bones[uuid];\n      if (bone === undefined) {\n        console.warn('THREE.Skeleton: No bone found with UUID:', uuid);\n        bone = new Bone();\n      }\n      this.bones.push(bone);\n      this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]));\n    }\n    this.init();\n    return this;\n  }\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: 'Skeleton',\n        generator: 'Skeleton.toJSON'\n      },\n      bones: [],\n      boneInverses: []\n    };\n    data.uuid = this.uuid;\n    const bones = this.bones;\n    const boneInverses = this.boneInverses;\n    for (let i = 0, l = bones.length; i < l; i++) {\n      const bone = bones[i];\n      data.bones.push(bone.uuid);\n      const boneInverse = boneInverses[i];\n      data.boneInverses.push(boneInverse.toArray());\n    }\n    return data;\n  }\n}\nexport { Skeleton };","map":{"version":3,"names":["RGBAFormat","FloatType","Bone","Matrix4","DataTexture","MathUtils","_offsetMatrix","_identityMatrix","Skeleton","constructor","bones","boneInverses","uuid","generateUUID","slice","boneMatrices","boneTexture","boneTextureSize","frame","init","Float32Array","length","calculateInverses","console","warn","i","il","push","inverse","copy","matrixWorld","invert","pose","bone","parent","isBone","matrix","multiply","decompose","position","quaternion","scale","update","multiplyMatrices","toArray","needsUpdate","clone","computeBoneTexture","size","Math","sqrt","ceilPowerOfTwo","max","set","getBoneByName","name","undefined","dispose","fromJSON","json","l","fromArray","toJSON","data","metadata","version","type","generator","boneInverse"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/objects/Skeleton.js"],"sourcesContent":["import {\n\tRGBAFormat,\n\tFloatType\n} from '../constants.js';\nimport { Bone } from './Bone.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { DataTexture } from '../textures/DataTexture.js';\nimport * as MathUtils from '../math/MathUtils.js';\n\nconst _offsetMatrix = /*@__PURE__*/ new Matrix4();\nconst _identityMatrix = /*@__PURE__*/ new Matrix4();\n\nclass Skeleton {\n\n\tconstructor( bones = [], boneInverses = [] ) {\n\n\t\tthis.uuid = MathUtils.generateUUID();\n\n\t\tthis.bones = bones.slice( 0 );\n\t\tthis.boneInverses = boneInverses;\n\t\tthis.boneMatrices = null;\n\n\t\tthis.boneTexture = null;\n\t\tthis.boneTextureSize = 0;\n\n\t\tthis.frame = - 1;\n\n\t\tthis.init();\n\n\t}\n\n\tinit() {\n\n\t\tconst bones = this.bones;\n\t\tconst boneInverses = this.boneInverses;\n\n\t\tthis.boneMatrices = new Float32Array( bones.length * 16 );\n\n\t\t// calculate inverse bone matrices if necessary\n\n\t\tif ( boneInverses.length === 0 ) {\n\n\t\t\tthis.calculateInverses();\n\n\t\t} else {\n\n\t\t\t// handle special case\n\n\t\t\tif ( bones.length !== boneInverses.length ) {\n\n\t\t\t\tconsole.warn( 'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.' );\n\n\t\t\t\tthis.boneInverses = [];\n\n\t\t\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\t\t\tthis.boneInverses.push( new Matrix4() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcalculateInverses() {\n\n\t\tthis.boneInverses.length = 0;\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst inverse = new Matrix4();\n\n\t\t\tif ( this.bones[ i ] ) {\n\n\t\t\t\tinverse.copy( this.bones[ i ].matrixWorld ).invert();\n\n\t\t\t}\n\n\t\t\tthis.boneInverses.push( inverse );\n\n\t\t}\n\n\t}\n\n\tpose() {\n\n\t\t// recover the bind-time world matrices\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst bone = this.bones[ i ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tbone.matrixWorld.copy( this.boneInverses[ i ] ).invert();\n\n\t\t\t}\n\n\t\t}\n\n\t\t// compute the local matrices, positions, rotations and scales\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst bone = this.bones[ i ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\t\t\tbone.matrix.copy( bone.parent.matrixWorld ).invert();\n\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tupdate() {\n\n\t\tconst bones = this.bones;\n\t\tconst boneInverses = this.boneInverses;\n\t\tconst boneMatrices = this.boneMatrices;\n\t\tconst boneTexture = this.boneTexture;\n\n\t\t// flatten bone matrices to array\n\n\t\tfor ( let i = 0, il = bones.length; i < il; i ++ ) {\n\n\t\t\t// compute the offset between the current and the original transform\n\n\t\t\tconst matrix = bones[ i ] ? bones[ i ].matrixWorld : _identityMatrix;\n\n\t\t\t_offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );\n\t\t\t_offsetMatrix.toArray( boneMatrices, i * 16 );\n\n\t\t}\n\n\t\tif ( boneTexture !== null ) {\n\n\t\t\tboneTexture.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new Skeleton( this.bones, this.boneInverses );\n\n\t}\n\n\tcomputeBoneTexture() {\n\n\t\t// layout (1 matrix = 4 pixels)\n\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n\t\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n\t\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n\t\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n\n\t\tlet size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix\n\t\tsize = MathUtils.ceilPowerOfTwo( size );\n\t\tsize = Math.max( size, 4 );\n\n\t\tconst boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel\n\t\tboneMatrices.set( this.boneMatrices ); // copy current values\n\n\t\tconst boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );\n\t\tboneTexture.needsUpdate = true;\n\n\t\tthis.boneMatrices = boneMatrices;\n\t\tthis.boneTexture = boneTexture;\n\t\tthis.boneTextureSize = size;\n\n\t\treturn this;\n\n\t}\n\n\tgetBoneByName( name ) {\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst bone = this.bones[ i ];\n\n\t\t\tif ( bone.name === name ) {\n\n\t\t\t\treturn bone;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn undefined;\n\n\t}\n\n\tdispose( ) {\n\n\t\tif ( this.boneTexture !== null ) {\n\n\t\t\tthis.boneTexture.dispose();\n\n\t\t\tthis.boneTexture = null;\n\n\t\t}\n\n\t}\n\n\tfromJSON( json, bones ) {\n\n\t\tthis.uuid = json.uuid;\n\n\t\tfor ( let i = 0, l = json.bones.length; i < l; i ++ ) {\n\n\t\t\tconst uuid = json.bones[ i ];\n\t\t\tlet bone = bones[ uuid ];\n\n\t\t\tif ( bone === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Skeleton: No bone found with UUID:', uuid );\n\t\t\t\tbone = new Bone();\n\n\t\t\t}\n\n\t\t\tthis.bones.push( bone );\n\t\t\tthis.boneInverses.push( new Matrix4().fromArray( json.boneInverses[ i ] ) );\n\n\t\t}\n\n\t\tthis.init();\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'Skeleton',\n\t\t\t\tgenerator: 'Skeleton.toJSON'\n\t\t\t},\n\t\t\tbones: [],\n\t\t\tboneInverses: []\n\t\t};\n\n\t\tdata.uuid = this.uuid;\n\n\t\tconst bones = this.bones;\n\t\tconst boneInverses = this.boneInverses;\n\n\t\tfor ( let i = 0, l = bones.length; i < l; i ++ ) {\n\n\t\t\tconst bone = bones[ i ];\n\t\t\tdata.bones.push( bone.uuid );\n\n\t\t\tconst boneInverse = boneInverses[ i ];\n\t\t\tdata.boneInverses.push( boneInverse.toArray() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n}\n\nexport { Skeleton };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}