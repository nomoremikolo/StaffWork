{"ast":null,"code":"import { CubeReflectionMapping, CubeRefractionMapping, EquirectangularReflectionMapping, EquirectangularRefractionMapping } from '../../constants.js';\nimport { PMREMGenerator } from '../../extras/PMREMGenerator.js';\nfunction WebGLCubeUVMaps(renderer) {\n  let cubeUVmaps = new WeakMap();\n  let pmremGenerator = null;\n  function get(texture) {\n    if (texture && texture.isTexture) {\n      const mapping = texture.mapping;\n      const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;\n      const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;\n\n      // equirect/cube map to cubeUV conversion\n\n      if (isEquirectMap || isCubeMap) {\n        if (texture.isRenderTargetTexture && texture.needsPMREMUpdate === true) {\n          texture.needsPMREMUpdate = false;\n          let renderTarget = cubeUVmaps.get(texture);\n          if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);\n          renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture, renderTarget) : pmremGenerator.fromCubemap(texture, renderTarget);\n          cubeUVmaps.set(texture, renderTarget);\n          return renderTarget.texture;\n        } else {\n          if (cubeUVmaps.has(texture)) {\n            return cubeUVmaps.get(texture).texture;\n          } else {\n            const image = texture.image;\n            if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {\n              if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);\n              const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);\n              cubeUVmaps.set(texture, renderTarget);\n              texture.addEventListener('dispose', onTextureDispose);\n              return renderTarget.texture;\n            } else {\n              // image not yet ready. try the conversion next frame\n\n              return null;\n            }\n          }\n        }\n      }\n    }\n    return texture;\n  }\n  function isCubeTextureComplete(image) {\n    let count = 0;\n    const length = 6;\n    for (let i = 0; i < length; i++) {\n      if (image[i] !== undefined) count++;\n    }\n    return count === length;\n  }\n  function onTextureDispose(event) {\n    const texture = event.target;\n    texture.removeEventListener('dispose', onTextureDispose);\n    const cubemapUV = cubeUVmaps.get(texture);\n    if (cubemapUV !== undefined) {\n      cubeUVmaps.delete(texture);\n      cubemapUV.dispose();\n    }\n  }\n  function dispose() {\n    cubeUVmaps = new WeakMap();\n    if (pmremGenerator !== null) {\n      pmremGenerator.dispose();\n      pmremGenerator = null;\n    }\n  }\n  return {\n    get: get,\n    dispose: dispose\n  };\n}\nexport { WebGLCubeUVMaps };","map":{"version":3,"names":["CubeReflectionMapping","CubeRefractionMapping","EquirectangularReflectionMapping","EquirectangularRefractionMapping","PMREMGenerator","WebGLCubeUVMaps","renderer","cubeUVmaps","WeakMap","pmremGenerator","get","texture","isTexture","mapping","isEquirectMap","isCubeMap","isRenderTargetTexture","needsPMREMUpdate","renderTarget","fromEquirectangular","fromCubemap","set","has","image","height","isCubeTextureComplete","addEventListener","onTextureDispose","count","length","i","undefined","event","target","removeEventListener","cubemapUV","delete","dispose"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/renderers/webgl/WebGLCubeUVMaps.js"],"sourcesContent":["import { CubeReflectionMapping, CubeRefractionMapping, EquirectangularReflectionMapping, EquirectangularRefractionMapping } from '../../constants.js';\nimport { PMREMGenerator } from '../../extras/PMREMGenerator.js';\n\nfunction WebGLCubeUVMaps( renderer ) {\n\n\tlet cubeUVmaps = new WeakMap();\n\n\tlet pmremGenerator = null;\n\n\tfunction get( texture ) {\n\n\t\tif ( texture && texture.isTexture ) {\n\n\t\t\tconst mapping = texture.mapping;\n\n\t\t\tconst isEquirectMap = ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping );\n\t\t\tconst isCubeMap = ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );\n\n\t\t\t// equirect/cube map to cubeUV conversion\n\n\t\t\tif ( isEquirectMap || isCubeMap ) {\n\n\t\t\t\tif ( texture.isRenderTargetTexture && texture.needsPMREMUpdate === true ) {\n\n\t\t\t\t\ttexture.needsPMREMUpdate = false;\n\n\t\t\t\t\tlet renderTarget = cubeUVmaps.get( texture );\n\n\t\t\t\t\tif ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );\n\n\t\t\t\t\trenderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture, renderTarget ) : pmremGenerator.fromCubemap( texture, renderTarget );\n\t\t\t\t\tcubeUVmaps.set( texture, renderTarget );\n\n\t\t\t\t\treturn renderTarget.texture;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( cubeUVmaps.has( texture ) ) {\n\n\t\t\t\t\t\treturn cubeUVmaps.get( texture ).texture;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst image = texture.image;\n\n\t\t\t\t\t\tif ( ( isEquirectMap && image && image.height > 0 ) || ( isCubeMap && image && isCubeTextureComplete( image ) ) ) {\n\n\t\t\t\t\t\t\tif ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );\n\n\t\t\t\t\t\t\tconst renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture ) : pmremGenerator.fromCubemap( texture );\n\t\t\t\t\t\t\tcubeUVmaps.set( texture, renderTarget );\n\n\t\t\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\t\t\t\treturn renderTarget.texture;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// image not yet ready. try the conversion next frame\n\n\t\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\tfunction isCubeTextureComplete( image ) {\n\n\t\tlet count = 0;\n\t\tconst length = 6;\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\tif ( image[ i ] !== undefined ) count ++;\n\n\t\t}\n\n\t\treturn count === length;\n\n\n\t}\n\n\tfunction onTextureDispose( event ) {\n\n\t\tconst texture = event.target;\n\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\t\tconst cubemapUV = cubeUVmaps.get( texture );\n\n\t\tif ( cubemapUV !== undefined ) {\n\n\t\t\tcubeUVmaps.delete( texture );\n\t\t\tcubemapUV.dispose();\n\n\t\t}\n\n\t}\n\n\tfunction dispose() {\n\n\t\tcubeUVmaps = new WeakMap();\n\n\t\tif ( pmremGenerator !== null ) {\n\n\t\t\tpmremGenerator.dispose();\n\t\t\tpmremGenerator = null;\n\n\t\t}\n\n\t}\n\n\treturn {\n\t\tget: get,\n\t\tdispose: dispose\n\t};\n\n}\n\nexport { WebGLCubeUVMaps };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}