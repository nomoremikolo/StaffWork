{"ast":null,"code":"/**\n * Abstract base class of interpolants over parametric samples.\n *\n * The parameter domain is one dimensional, typically the time or a path\n * along a curve defined by the data.\n *\n * The sample values can have any dimensionality and derived classes may\n * apply special interpretations to the data.\n *\n * This class provides the interval seek in a Template Method, deferring\n * the actual interpolation to derived classes.\n *\n * Time complexity is O(1) for linear access crossing at most two points\n * and O(log N) for random access, where N is the number of positions.\n *\n * References:\n *\n * \t\thttp://www.oodesign.com/template-method-pattern.html\n *\n */\n\nclass Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    this.parameterPositions = parameterPositions;\n    this._cachedIndex = 0;\n    this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);\n    this.sampleValues = sampleValues;\n    this.valueSize = sampleSize;\n    this.settings = null;\n    this.DefaultSettings_ = {};\n  }\n  evaluate(t) {\n    const pp = this.parameterPositions;\n    let i1 = this._cachedIndex,\n      t1 = pp[i1],\n      t0 = pp[i1 - 1];\n    validate_interval: {\n      seek: {\n        let right;\n        linear_scan: {\n          //- See http://jsperf.com/comparison-to-undefined/3\n          //- slower code:\n          //-\n          //- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n          forward_scan: if (!(t < t1)) {\n            for (let giveUpAt = i1 + 2;;) {\n              if (t1 === undefined) {\n                if (t < t0) break forward_scan;\n\n                // after end\n\n                i1 = pp.length;\n                this._cachedIndex = i1;\n                return this.copySampleValue_(i1 - 1);\n              }\n              if (i1 === giveUpAt) break; // this loop\n\n              t0 = t1;\n              t1 = pp[++i1];\n              if (t < t1) {\n                // we have arrived at the sought interval\n                break seek;\n              }\n            }\n\n            // prepare binary search on the right side of the index\n            right = pp.length;\n            break linear_scan;\n          }\n\n          //- slower code:\n          //-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n          if (!(t >= t0)) {\n            // looping?\n\n            const t1global = pp[1];\n            if (t < t1global) {\n              i1 = 2; // + 1, using the scan for the details\n              t0 = t1global;\n            }\n\n            // linear reverse scan\n\n            for (let giveUpAt = i1 - 2;;) {\n              if (t0 === undefined) {\n                // before start\n\n                this._cachedIndex = 0;\n                return this.copySampleValue_(0);\n              }\n              if (i1 === giveUpAt) break; // this loop\n\n              t1 = t0;\n              t0 = pp[--i1 - 1];\n              if (t >= t0) {\n                // we have arrived at the sought interval\n                break seek;\n              }\n            }\n\n            // prepare binary search on the left side of the index\n            right = i1;\n            i1 = 0;\n            break linear_scan;\n          }\n\n          // the interval is valid\n\n          break validate_interval;\n        } // linear scan\n\n        // binary search\n\n        while (i1 < right) {\n          const mid = i1 + right >>> 1;\n          if (t < pp[mid]) {\n            right = mid;\n          } else {\n            i1 = mid + 1;\n          }\n        }\n        t1 = pp[i1];\n        t0 = pp[i1 - 1];\n\n        // check boundary cases, again\n\n        if (t0 === undefined) {\n          this._cachedIndex = 0;\n          return this.copySampleValue_(0);\n        }\n        if (t1 === undefined) {\n          i1 = pp.length;\n          this._cachedIndex = i1;\n          return this.copySampleValue_(i1 - 1);\n        }\n      } // seek\n\n      this._cachedIndex = i1;\n      this.intervalChanged_(i1, t0, t1);\n    } // validate_interval\n\n    return this.interpolate_(i1, t0, t, t1);\n  }\n  getSettings_() {\n    return this.settings || this.DefaultSettings_;\n  }\n  copySampleValue_(index) {\n    // copies a sample value to the result buffer\n\n    const result = this.resultBuffer,\n      values = this.sampleValues,\n      stride = this.valueSize,\n      offset = index * stride;\n    for (let i = 0; i !== stride; ++i) {\n      result[i] = values[offset + i];\n    }\n    return result;\n  }\n\n  // Template methods for derived classes:\n\n  interpolate_( /* i1, t0, t, t1 */\n  ) {\n    throw new Error('call to abstract method');\n    // implementations shall return this.resultBuffer\n  }\n\n  intervalChanged_( /* i1, t0, t1 */\n  ) {\n\n    // empty\n  }\n}\nexport { Interpolant };","map":{"version":3,"names":["Interpolant","constructor","parameterPositions","sampleValues","sampleSize","resultBuffer","_cachedIndex","undefined","valueSize","settings","DefaultSettings_","evaluate","t","pp","i1","t1","t0","validate_interval","seek","right","linear_scan","forward_scan","giveUpAt","length","copySampleValue_","t1global","mid","intervalChanged_","interpolate_","getSettings_","index","result","values","stride","offset","i","Error"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/math/Interpolant.js"],"sourcesContent":["/**\n * Abstract base class of interpolants over parametric samples.\n *\n * The parameter domain is one dimensional, typically the time or a path\n * along a curve defined by the data.\n *\n * The sample values can have any dimensionality and derived classes may\n * apply special interpretations to the data.\n *\n * This class provides the interval seek in a Template Method, deferring\n * the actual interpolation to derived classes.\n *\n * Time complexity is O(1) for linear access crossing at most two points\n * and O(log N) for random access, where N is the number of positions.\n *\n * References:\n *\n * \t\thttp://www.oodesign.com/template-method-pattern.html\n *\n */\n\nclass Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tthis.parameterPositions = parameterPositions;\n\t\tthis._cachedIndex = 0;\n\n\t\tthis.resultBuffer = resultBuffer !== undefined ?\n\t\t\tresultBuffer : new sampleValues.constructor( sampleSize );\n\t\tthis.sampleValues = sampleValues;\n\t\tthis.valueSize = sampleSize;\n\n\t\tthis.settings = null;\n\t\tthis.DefaultSettings_ = {};\n\n\t}\n\n\tevaluate( t ) {\n\n\t\tconst pp = this.parameterPositions;\n\t\tlet i1 = this._cachedIndex,\n\t\t\tt1 = pp[ i1 ],\n\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\tvalidate_interval: {\n\n\t\t\tseek: {\n\n\t\t\t\tlet right;\n\n\t\t\t\tlinear_scan: {\n\n\t\t\t\t\t//- See http://jsperf.com/comparison-to-undefined/3\n\t\t\t\t\t//- slower code:\n\t\t\t\t\t//-\n\t\t\t\t\t//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\n\n\t\t\t\t\t\tfor ( let giveUpAt = i1 + 2; ; ) {\n\n\t\t\t\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\n\n\t\t\t\t\t\t\t\t// after end\n\n\t\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\n\n\t\t\t\t\t\t\tif ( t < t1 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the right side of the index\n\t\t\t\t\t\tright = pp.length;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//- slower code:\n\t\t\t\t\t//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\t\t\t\t\tif ( ! ( t >= t0 ) ) {\n\n\t\t\t\t\t\t// looping?\n\n\t\t\t\t\t\tconst t1global = pp[ 1 ];\n\n\t\t\t\t\t\tif ( t < t1global ) {\n\n\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\n\t\t\t\t\t\t\tt0 = t1global;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// linear reverse scan\n\n\t\t\t\t\t\tfor ( let giveUpAt = i1 - 2; ; ) {\n\n\t\t\t\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\t\t\t\t// before start\n\n\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\t\treturn this.copySampleValue_( 0 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt1 = t0;\n\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\n\n\t\t\t\t\t\t\tif ( t >= t0 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the left side of the index\n\t\t\t\t\t\tright = i1;\n\t\t\t\t\t\ti1 = 0;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// the interval is valid\n\n\t\t\t\t\tbreak validate_interval;\n\n\t\t\t\t} // linear scan\n\n\t\t\t\t// binary search\n\n\t\t\t\twhile ( i1 < right ) {\n\n\t\t\t\t\tconst mid = ( i1 + right ) >>> 1;\n\n\t\t\t\t\tif ( t < pp[ mid ] ) {\n\n\t\t\t\t\t\tright = mid;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ti1 = mid + 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tt1 = pp[ i1 ];\n\t\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\t\t\t// check boundary cases, again\n\n\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\treturn this.copySampleValue_( 0 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t\t\t\t}\n\n\t\t\t} // seek\n\n\t\t\tthis._cachedIndex = i1;\n\n\t\t\tthis.intervalChanged_( i1, t0, t1 );\n\n\t\t} // validate_interval\n\n\t\treturn this.interpolate_( i1, t0, t, t1 );\n\n\t}\n\n\tgetSettings_() {\n\n\t\treturn this.settings || this.DefaultSettings_;\n\n\t}\n\n\tcopySampleValue_( index ) {\n\n\t\t// copies a sample value to the result buffer\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = index * stride;\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\t// Template methods for derived classes:\n\n\tinterpolate_( /* i1, t0, t, t1 */ ) {\n\n\t\tthrow new Error( 'call to abstract method' );\n\t\t// implementations shall return this.resultBuffer\n\n\t}\n\n\tintervalChanged_( /* i1, t0, t1 */ ) {\n\n\t\t// empty\n\n\t}\n\n}\n\nexport { Interpolant };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}