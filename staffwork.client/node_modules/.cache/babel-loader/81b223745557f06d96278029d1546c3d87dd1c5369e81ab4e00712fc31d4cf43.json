{"ast":null,"code":"import { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Box3 } from '../math/Box3.js';\nimport { EventDispatcher } from './EventDispatcher.js';\nimport { BufferAttribute, Float32BufferAttribute, Uint16BufferAttribute, Uint32BufferAttribute } from './BufferAttribute.js';\nimport { Sphere } from '../math/Sphere.js';\nimport { Object3D } from './Object3D.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Matrix3 } from '../math/Matrix3.js';\nimport * as MathUtils from '../math/MathUtils.js';\nimport { arrayNeedsUint32 } from '../utils.js';\nlet _id = 0;\nconst _m1 = /*@__PURE__*/new Matrix4();\nconst _obj = /*@__PURE__*/new Object3D();\nconst _offset = /*@__PURE__*/new Vector3();\nconst _box = /*@__PURE__*/new Box3();\nconst _boxMorphTargets = /*@__PURE__*/new Box3();\nconst _vector = /*@__PURE__*/new Vector3();\nclass BufferGeometry extends EventDispatcher {\n  constructor() {\n    super();\n    this.isBufferGeometry = true;\n    Object.defineProperty(this, 'id', {\n      value: _id++\n    });\n    this.uuid = MathUtils.generateUUID();\n    this.name = '';\n    this.type = 'BufferGeometry';\n    this.index = null;\n    this.attributes = {};\n    this.morphAttributes = {};\n    this.morphTargetsRelative = false;\n    this.groups = [];\n    this.boundingBox = null;\n    this.boundingSphere = null;\n    this.drawRange = {\n      start: 0,\n      count: Infinity\n    };\n    this.userData = {};\n  }\n  getIndex() {\n    return this.index;\n  }\n  setIndex(index) {\n    if (Array.isArray(index)) {\n      this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);\n    } else {\n      this.index = index;\n    }\n    return this;\n  }\n  getAttribute(name) {\n    return this.attributes[name];\n  }\n  setAttribute(name, attribute) {\n    this.attributes[name] = attribute;\n    return this;\n  }\n  deleteAttribute(name) {\n    delete this.attributes[name];\n    return this;\n  }\n  hasAttribute(name) {\n    return this.attributes[name] !== undefined;\n  }\n  addGroup(start, count) {\n    let materialIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    this.groups.push({\n      start: start,\n      count: count,\n      materialIndex: materialIndex\n    });\n  }\n  clearGroups() {\n    this.groups = [];\n  }\n  setDrawRange(start, count) {\n    this.drawRange.start = start;\n    this.drawRange.count = count;\n  }\n  applyMatrix4(matrix) {\n    const position = this.attributes.position;\n    if (position !== undefined) {\n      position.applyMatrix4(matrix);\n      position.needsUpdate = true;\n    }\n    const normal = this.attributes.normal;\n    if (normal !== undefined) {\n      const normalMatrix = new Matrix3().getNormalMatrix(matrix);\n      normal.applyNormalMatrix(normalMatrix);\n      normal.needsUpdate = true;\n    }\n    const tangent = this.attributes.tangent;\n    if (tangent !== undefined) {\n      tangent.transformDirection(matrix);\n      tangent.needsUpdate = true;\n    }\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n    return this;\n  }\n  applyQuaternion(q) {\n    _m1.makeRotationFromQuaternion(q);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  rotateX(angle) {\n    // rotate geometry around world x-axis\n\n    _m1.makeRotationX(angle);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  rotateY(angle) {\n    // rotate geometry around world y-axis\n\n    _m1.makeRotationY(angle);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  rotateZ(angle) {\n    // rotate geometry around world z-axis\n\n    _m1.makeRotationZ(angle);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  translate(x, y, z) {\n    // translate geometry\n\n    _m1.makeTranslation(x, y, z);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  scale(x, y, z) {\n    // scale geometry\n\n    _m1.makeScale(x, y, z);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  lookAt(vector) {\n    _obj.lookAt(vector);\n    _obj.updateMatrix();\n    this.applyMatrix4(_obj.matrix);\n    return this;\n  }\n  center() {\n    this.computeBoundingBox();\n    this.boundingBox.getCenter(_offset).negate();\n    this.translate(_offset.x, _offset.y, _offset.z);\n    return this;\n  }\n  setFromPoints(points) {\n    const position = [];\n    for (let i = 0, l = points.length; i < l; i++) {\n      const point = points[i];\n      position.push(point.x, point.y, point.z || 0);\n    }\n    this.setAttribute('position', new Float32BufferAttribute(position, 3));\n    return this;\n  }\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n    const position = this.attributes.position;\n    const morphAttributesPosition = this.morphAttributes.position;\n    if (position && position.isGLBufferAttribute) {\n      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set \"mesh.frustumCulled\" to \"false\".', this);\n      this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(+Infinity, +Infinity, +Infinity));\n      return;\n    }\n    if (position !== undefined) {\n      this.boundingBox.setFromBufferAttribute(position);\n\n      // process morph attributes if present\n\n      if (morphAttributesPosition) {\n        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n          const morphAttribute = morphAttributesPosition[i];\n          _box.setFromBufferAttribute(morphAttribute);\n          if (this.morphTargetsRelative) {\n            _vector.addVectors(this.boundingBox.min, _box.min);\n            this.boundingBox.expandByPoint(_vector);\n            _vector.addVectors(this.boundingBox.max, _box.max);\n            this.boundingBox.expandByPoint(_vector);\n          } else {\n            this.boundingBox.expandByPoint(_box.min);\n            this.boundingBox.expandByPoint(_box.max);\n          }\n        }\n      }\n    } else {\n      this.boundingBox.makeEmpty();\n    }\n    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {\n      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this);\n    }\n  }\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n    const position = this.attributes.position;\n    const morphAttributesPosition = this.morphAttributes.position;\n    if (position && position.isGLBufferAttribute) {\n      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set \"mesh.frustumCulled\" to \"false\".', this);\n      this.boundingSphere.set(new Vector3(), Infinity);\n      return;\n    }\n    if (position) {\n      // first, find the center of the bounding sphere\n\n      const center = this.boundingSphere.center;\n      _box.setFromBufferAttribute(position);\n\n      // process morph attributes if present\n\n      if (morphAttributesPosition) {\n        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n          const morphAttribute = morphAttributesPosition[i];\n          _boxMorphTargets.setFromBufferAttribute(morphAttribute);\n          if (this.morphTargetsRelative) {\n            _vector.addVectors(_box.min, _boxMorphTargets.min);\n            _box.expandByPoint(_vector);\n            _vector.addVectors(_box.max, _boxMorphTargets.max);\n            _box.expandByPoint(_vector);\n          } else {\n            _box.expandByPoint(_boxMorphTargets.min);\n            _box.expandByPoint(_boxMorphTargets.max);\n          }\n        }\n      }\n      _box.getCenter(center);\n\n      // second, try to find a boundingSphere with a radius smaller than the\n      // boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n      let maxRadiusSq = 0;\n      for (let i = 0, il = position.count; i < il; i++) {\n        _vector.fromBufferAttribute(position, i);\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n      }\n\n      // process morph attributes if present\n\n      if (morphAttributesPosition) {\n        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n          const morphAttribute = morphAttributesPosition[i];\n          const morphTargetsRelative = this.morphTargetsRelative;\n          for (let j = 0, jl = morphAttribute.count; j < jl; j++) {\n            _vector.fromBufferAttribute(morphAttribute, j);\n            if (morphTargetsRelative) {\n              _offset.fromBufferAttribute(position, j);\n              _vector.add(_offset);\n            }\n            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n          }\n        }\n      }\n      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n      if (isNaN(this.boundingSphere.radius)) {\n        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this);\n      }\n    }\n  }\n  computeTangents() {\n    const index = this.index;\n    const attributes = this.attributes;\n\n    // based on http://www.terathon.com/code/tangent.html\n    // (per vertex tangents)\n\n    if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {\n      console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');\n      return;\n    }\n    const indices = index.array;\n    const positions = attributes.position.array;\n    const normals = attributes.normal.array;\n    const uvs = attributes.uv.array;\n    const nVertices = positions.length / 3;\n    if (this.hasAttribute('tangent') === false) {\n      this.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * nVertices), 4));\n    }\n    const tangents = this.getAttribute('tangent').array;\n    const tan1 = [],\n      tan2 = [];\n    for (let i = 0; i < nVertices; i++) {\n      tan1[i] = new Vector3();\n      tan2[i] = new Vector3();\n    }\n    const vA = new Vector3(),\n      vB = new Vector3(),\n      vC = new Vector3(),\n      uvA = new Vector2(),\n      uvB = new Vector2(),\n      uvC = new Vector2(),\n      sdir = new Vector3(),\n      tdir = new Vector3();\n    function handleTriangle(a, b, c) {\n      vA.fromArray(positions, a * 3);\n      vB.fromArray(positions, b * 3);\n      vC.fromArray(positions, c * 3);\n      uvA.fromArray(uvs, a * 2);\n      uvB.fromArray(uvs, b * 2);\n      uvC.fromArray(uvs, c * 2);\n      vB.sub(vA);\n      vC.sub(vA);\n      uvB.sub(uvA);\n      uvC.sub(uvA);\n      const r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y);\n\n      // silently ignore degenerate uv triangles having coincident or colinear vertices\n\n      if (!isFinite(r)) return;\n      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);\n      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);\n      tan1[a].add(sdir);\n      tan1[b].add(sdir);\n      tan1[c].add(sdir);\n      tan2[a].add(tdir);\n      tan2[b].add(tdir);\n      tan2[c].add(tdir);\n    }\n    let groups = this.groups;\n    if (groups.length === 0) {\n      groups = [{\n        start: 0,\n        count: indices.length\n      }];\n    }\n    for (let i = 0, il = groups.length; i < il; ++i) {\n      const group = groups[i];\n      const start = group.start;\n      const count = group.count;\n      for (let j = start, jl = start + count; j < jl; j += 3) {\n        handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);\n      }\n    }\n    const tmp = new Vector3(),\n      tmp2 = new Vector3();\n    const n = new Vector3(),\n      n2 = new Vector3();\n    function handleVertex(v) {\n      n.fromArray(normals, v * 3);\n      n2.copy(n);\n      const t = tan1[v];\n\n      // Gram-Schmidt orthogonalize\n\n      tmp.copy(t);\n      tmp.sub(n.multiplyScalar(n.dot(t))).normalize();\n\n      // Calculate handedness\n\n      tmp2.crossVectors(n2, t);\n      const test = tmp2.dot(tan2[v]);\n      const w = test < 0.0 ? -1.0 : 1.0;\n      tangents[v * 4] = tmp.x;\n      tangents[v * 4 + 1] = tmp.y;\n      tangents[v * 4 + 2] = tmp.z;\n      tangents[v * 4 + 3] = w;\n    }\n    for (let i = 0, il = groups.length; i < il; ++i) {\n      const group = groups[i];\n      const start = group.start;\n      const count = group.count;\n      for (let j = start, jl = start + count; j < jl; j += 3) {\n        handleVertex(indices[j + 0]);\n        handleVertex(indices[j + 1]);\n        handleVertex(indices[j + 2]);\n      }\n    }\n  }\n  computeVertexNormals() {\n    const index = this.index;\n    const positionAttribute = this.getAttribute('position');\n    if (positionAttribute !== undefined) {\n      let normalAttribute = this.getAttribute('normal');\n      if (normalAttribute === undefined) {\n        normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);\n        this.setAttribute('normal', normalAttribute);\n      } else {\n        // reset existing normals to zero\n\n        for (let i = 0, il = normalAttribute.count; i < il; i++) {\n          normalAttribute.setXYZ(i, 0, 0, 0);\n        }\n      }\n      const pA = new Vector3(),\n        pB = new Vector3(),\n        pC = new Vector3();\n      const nA = new Vector3(),\n        nB = new Vector3(),\n        nC = new Vector3();\n      const cb = new Vector3(),\n        ab = new Vector3();\n\n      // indexed elements\n\n      if (index) {\n        for (let i = 0, il = index.count; i < il; i += 3) {\n          const vA = index.getX(i + 0);\n          const vB = index.getX(i + 1);\n          const vC = index.getX(i + 2);\n          pA.fromBufferAttribute(positionAttribute, vA);\n          pB.fromBufferAttribute(positionAttribute, vB);\n          pC.fromBufferAttribute(positionAttribute, vC);\n          cb.subVectors(pC, pB);\n          ab.subVectors(pA, pB);\n          cb.cross(ab);\n          nA.fromBufferAttribute(normalAttribute, vA);\n          nB.fromBufferAttribute(normalAttribute, vB);\n          nC.fromBufferAttribute(normalAttribute, vC);\n          nA.add(cb);\n          nB.add(cb);\n          nC.add(cb);\n          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);\n          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);\n          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);\n        }\n      } else {\n        // non-indexed elements (unconnected triangle soup)\n\n        for (let i = 0, il = positionAttribute.count; i < il; i += 3) {\n          pA.fromBufferAttribute(positionAttribute, i + 0);\n          pB.fromBufferAttribute(positionAttribute, i + 1);\n          pC.fromBufferAttribute(positionAttribute, i + 2);\n          cb.subVectors(pC, pB);\n          ab.subVectors(pA, pB);\n          cb.cross(ab);\n          normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);\n          normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);\n          normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);\n        }\n      }\n      this.normalizeNormals();\n      normalAttribute.needsUpdate = true;\n    }\n  }\n\n  // @deprecated since r144\n\n  merge() {\n    console.error('THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead.');\n    return this;\n  }\n  normalizeNormals() {\n    const normals = this.attributes.normal;\n    for (let i = 0, il = normals.count; i < il; i++) {\n      _vector.fromBufferAttribute(normals, i);\n      _vector.normalize();\n      normals.setXYZ(i, _vector.x, _vector.y, _vector.z);\n    }\n  }\n  toNonIndexed() {\n    function convertBufferAttribute(attribute, indices) {\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      const normalized = attribute.normalized;\n      const array2 = new array.constructor(indices.length * itemSize);\n      let index = 0,\n        index2 = 0;\n      for (let i = 0, l = indices.length; i < l; i++) {\n        if (attribute.isInterleavedBufferAttribute) {\n          index = indices[i] * attribute.data.stride + attribute.offset;\n        } else {\n          index = indices[i] * itemSize;\n        }\n        for (let j = 0; j < itemSize; j++) {\n          array2[index2++] = array[index++];\n        }\n      }\n      return new BufferAttribute(array2, itemSize, normalized);\n    }\n\n    //\n\n    if (this.index === null) {\n      console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');\n      return this;\n    }\n    const geometry2 = new BufferGeometry();\n    const indices = this.index.array;\n    const attributes = this.attributes;\n\n    // attributes\n\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      const newAttribute = convertBufferAttribute(attribute, indices);\n      geometry2.setAttribute(name, newAttribute);\n    }\n\n    // morph attributes\n\n    const morphAttributes = this.morphAttributes;\n    for (const name in morphAttributes) {\n      const morphArray = [];\n      const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes\n\n      for (let i = 0, il = morphAttribute.length; i < il; i++) {\n        const attribute = morphAttribute[i];\n        const newAttribute = convertBufferAttribute(attribute, indices);\n        morphArray.push(newAttribute);\n      }\n      geometry2.morphAttributes[name] = morphArray;\n    }\n    geometry2.morphTargetsRelative = this.morphTargetsRelative;\n\n    // groups\n\n    const groups = this.groups;\n    for (let i = 0, l = groups.length; i < l; i++) {\n      const group = groups[i];\n      geometry2.addGroup(group.start, group.count, group.materialIndex);\n    }\n    return geometry2;\n  }\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: 'BufferGeometry',\n        generator: 'BufferGeometry.toJSON'\n      }\n    };\n\n    // standard BufferGeometry serialization\n\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== '') data.name = this.name;\n    if (Object.keys(this.userData).length > 0) data.userData = this.userData;\n    if (this.parameters !== undefined) {\n      const parameters = this.parameters;\n      for (const key in parameters) {\n        if (parameters[key] !== undefined) data[key] = parameters[key];\n      }\n      return data;\n    }\n\n    // for simplicity the code assumes attributes are not shared across geometries, see #15811\n\n    data.data = {\n      attributes: {}\n    };\n    const index = this.index;\n    if (index !== null) {\n      data.data.index = {\n        type: index.array.constructor.name,\n        array: Array.prototype.slice.call(index.array)\n      };\n    }\n    const attributes = this.attributes;\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      data.data.attributes[key] = attribute.toJSON(data.data);\n    }\n    const morphAttributes = {};\n    let hasMorphAttributes = false;\n    for (const key in this.morphAttributes) {\n      const attributeArray = this.morphAttributes[key];\n      const array = [];\n      for (let i = 0, il = attributeArray.length; i < il; i++) {\n        const attribute = attributeArray[i];\n        array.push(attribute.toJSON(data.data));\n      }\n      if (array.length > 0) {\n        morphAttributes[key] = array;\n        hasMorphAttributes = true;\n      }\n    }\n    if (hasMorphAttributes) {\n      data.data.morphAttributes = morphAttributes;\n      data.data.morphTargetsRelative = this.morphTargetsRelative;\n    }\n    const groups = this.groups;\n    if (groups.length > 0) {\n      data.data.groups = JSON.parse(JSON.stringify(groups));\n    }\n    const boundingSphere = this.boundingSphere;\n    if (boundingSphere !== null) {\n      data.data.boundingSphere = {\n        center: boundingSphere.center.toArray(),\n        radius: boundingSphere.radius\n      };\n    }\n    return data;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  copy(source) {\n    // reset\n\n    this.index = null;\n    this.attributes = {};\n    this.morphAttributes = {};\n    this.groups = [];\n    this.boundingBox = null;\n    this.boundingSphere = null;\n\n    // used for storing cloned, shared data\n\n    const data = {};\n\n    // name\n\n    this.name = source.name;\n\n    // index\n\n    const index = source.index;\n    if (index !== null) {\n      this.setIndex(index.clone(data));\n    }\n\n    // attributes\n\n    const attributes = source.attributes;\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      this.setAttribute(name, attribute.clone(data));\n    }\n\n    // morph attributes\n\n    const morphAttributes = source.morphAttributes;\n    for (const name in morphAttributes) {\n      const array = [];\n      const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes\n\n      for (let i = 0, l = morphAttribute.length; i < l; i++) {\n        array.push(morphAttribute[i].clone(data));\n      }\n      this.morphAttributes[name] = array;\n    }\n    this.morphTargetsRelative = source.morphTargetsRelative;\n\n    // groups\n\n    const groups = source.groups;\n    for (let i = 0, l = groups.length; i < l; i++) {\n      const group = groups[i];\n      this.addGroup(group.start, group.count, group.materialIndex);\n    }\n\n    // bounding box\n\n    const boundingBox = source.boundingBox;\n    if (boundingBox !== null) {\n      this.boundingBox = boundingBox.clone();\n    }\n\n    // bounding sphere\n\n    const boundingSphere = source.boundingSphere;\n    if (boundingSphere !== null) {\n      this.boundingSphere = boundingSphere.clone();\n    }\n\n    // draw range\n\n    this.drawRange.start = source.drawRange.start;\n    this.drawRange.count = source.drawRange.count;\n\n    // user data\n\n    this.userData = source.userData;\n\n    // geometry generator parameters\n\n    if (source.parameters !== undefined) this.parameters = Object.assign({}, source.parameters);\n    return this;\n  }\n  dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n}\nexport { BufferGeometry };","map":{"version":3,"names":["Vector3","Vector2","Box3","EventDispatcher","BufferAttribute","Float32BufferAttribute","Uint16BufferAttribute","Uint32BufferAttribute","Sphere","Object3D","Matrix4","Matrix3","MathUtils","arrayNeedsUint32","_id","_m1","_obj","_offset","_box","_boxMorphTargets","_vector","BufferGeometry","constructor","isBufferGeometry","Object","defineProperty","value","uuid","generateUUID","name","type","index","attributes","morphAttributes","morphTargetsRelative","groups","boundingBox","boundingSphere","drawRange","start","count","Infinity","userData","getIndex","setIndex","Array","isArray","getAttribute","setAttribute","attribute","deleteAttribute","hasAttribute","undefined","addGroup","materialIndex","push","clearGroups","setDrawRange","applyMatrix4","matrix","position","needsUpdate","normal","normalMatrix","getNormalMatrix","applyNormalMatrix","tangent","transformDirection","computeBoundingBox","computeBoundingSphere","applyQuaternion","q","makeRotationFromQuaternion","rotateX","angle","makeRotationX","rotateY","makeRotationY","rotateZ","makeRotationZ","translate","x","y","z","makeTranslation","scale","makeScale","lookAt","vector","updateMatrix","center","getCenter","negate","setFromPoints","points","i","l","length","point","morphAttributesPosition","isGLBufferAttribute","console","error","set","setFromBufferAttribute","il","morphAttribute","addVectors","min","expandByPoint","max","makeEmpty","isNaN","maxRadiusSq","fromBufferAttribute","Math","distanceToSquared","j","jl","add","radius","sqrt","computeTangents","uv","indices","array","positions","normals","uvs","nVertices","Float32Array","tangents","tan1","tan2","vA","vB","vC","uvA","uvB","uvC","sdir","tdir","handleTriangle","a","b","c","fromArray","sub","r","isFinite","copy","multiplyScalar","addScaledVector","group","tmp","tmp2","n","n2","handleVertex","v","t","dot","normalize","crossVectors","test","w","computeVertexNormals","positionAttribute","normalAttribute","setXYZ","pA","pB","pC","nA","nB","nC","cb","ab","getX","subVectors","cross","normalizeNormals","merge","toNonIndexed","convertBufferAttribute","itemSize","normalized","array2","index2","isInterleavedBufferAttribute","data","stride","offset","warn","geometry2","newAttribute","morphArray","toJSON","metadata","version","generator","keys","parameters","key","prototype","slice","call","hasMorphAttributes","attributeArray","JSON","parse","stringify","toArray","clone","source","assign","dispose","dispatchEvent"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/core/BufferGeometry.js"],"sourcesContent":["import { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Box3 } from '../math/Box3.js';\nimport { EventDispatcher } from './EventDispatcher.js';\nimport { BufferAttribute, Float32BufferAttribute, Uint16BufferAttribute, Uint32BufferAttribute } from './BufferAttribute.js';\nimport { Sphere } from '../math/Sphere.js';\nimport { Object3D } from './Object3D.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Matrix3 } from '../math/Matrix3.js';\nimport * as MathUtils from '../math/MathUtils.js';\nimport { arrayNeedsUint32 } from '../utils.js';\n\nlet _id = 0;\n\nconst _m1 = /*@__PURE__*/ new Matrix4();\nconst _obj = /*@__PURE__*/ new Object3D();\nconst _offset = /*@__PURE__*/ new Vector3();\nconst _box = /*@__PURE__*/ new Box3();\nconst _boxMorphTargets = /*@__PURE__*/ new Box3();\nconst _vector = /*@__PURE__*/ new Vector3();\n\nclass BufferGeometry extends EventDispatcher {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isBufferGeometry = true;\n\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\tthis.uuid = MathUtils.generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\tthis.index = null;\n\t\tthis.attributes = {};\n\n\t\tthis.morphAttributes = {};\n\t\tthis.morphTargetsRelative = false;\n\n\t\tthis.groups = [];\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\tthis.userData = {};\n\n\t}\n\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}\n\n\tsetAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}\n\n\tdeleteAttribute( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t}\n\n\thasAttribute( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t}\n\n\taddGroup( start, count, materialIndex = 0 ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t}\n\n\tclearGroups() {\n\n\t\tthis.groups = [];\n\n\t}\n\n\tsetDrawRange( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tconst position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tposition.applyMatrix4( matrix );\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tconst normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tconst tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\ttangent.transformDirection( matrix );\n\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tapplyQuaternion( q ) {\n\n\t\t_m1.makeRotationFromQuaternion( q );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateX( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateY( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateZ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1.makeRotationZ( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\tscale( x, y, z ) {\n\n\t\t// scale geometry\n\n\t\t_m1.makeScale( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\tlookAt( vector ) {\n\n\t\t_obj.lookAt( vector );\n\n\t\t_obj.updateMatrix();\n\n\t\tthis.applyMatrix4( _obj.matrix );\n\n\t\treturn this;\n\n\t}\n\n\tcenter() {\n\n\t\tthis.computeBoundingBox();\n\n\t\tthis.boundingBox.getCenter( _offset ).negate();\n\n\t\tthis.translate( _offset.x, _offset.y, _offset.z );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\tconst position = [];\n\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst point = points[ i ];\n\t\t\tposition.push( point.x, point.y, point.z || 0 );\n\n\t\t}\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\n\t\treturn this;\n\n\t}\n\n\tcomputeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set \"mesh.frustumCulled\" to \"false\".', this );\n\n\t\t\tthis.boundingBox.set(\n\t\t\t\tnew Vector3( - Infinity, - Infinity, - Infinity ),\n\t\t\t\tnew Vector3( + Infinity, + Infinity, + Infinity )\n\t\t\t);\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_box.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.min, _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.max, _box.max );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t}\n\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set \"mesh.frustumCulled\" to \"false\".', this );\n\n\t\t\tthis.boundingSphere.set( new Vector3(), Infinity );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position ) {\n\n\t\t\t// first, find the center of the bounding sphere\n\n\t\t\tconst center = this.boundingSphere.center;\n\n\t\t\t_box.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_boxMorphTargets.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( _box.min, _boxMorphTargets.min );\n\t\t\t\t\t\t_box.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( _box.max, _boxMorphTargets.max );\n\t\t\t\t\t\t_box.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.min );\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_box.getCenter( center );\n\n\t\t\t// second, try to find a boundingSphere with a radius smaller than the\n\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\tlet maxRadiusSq = 0;\n\n\t\t\tfor ( let i = 0, il = position.count; i < il; i ++ ) {\n\n\t\t\t\t_vector.fromBufferAttribute( position, i );\n\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t}\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\tconst morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t\t\t\tfor ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t_vector.fromBufferAttribute( morphAttribute, j );\n\n\t\t\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t\t\t_offset.fromBufferAttribute( position, j );\n\t\t\t\t\t\t\t_vector.add( _offset );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcomputeTangents() {\n\n\t\tconst index = this.index;\n\t\tconst attributes = this.attributes;\n\n\t\t// based on http://www.terathon.com/code/tangent.html\n\t\t// (per vertex tangents)\n\n\t\tif ( index === null ||\n\t\t\t attributes.position === undefined ||\n\t\t\t attributes.normal === undefined ||\n\t\t\t attributes.uv === undefined ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst indices = index.array;\n\t\tconst positions = attributes.position.array;\n\t\tconst normals = attributes.normal.array;\n\t\tconst uvs = attributes.uv.array;\n\n\t\tconst nVertices = positions.length / 3;\n\n\t\tif ( this.hasAttribute( 'tangent' ) === false ) {\n\n\t\t\tthis.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );\n\n\t\t}\n\n\t\tconst tangents = this.getAttribute( 'tangent' ).array;\n\n\t\tconst tan1 = [], tan2 = [];\n\n\t\tfor ( let i = 0; i < nVertices; i ++ ) {\n\n\t\t\ttan1[ i ] = new Vector3();\n\t\t\ttan2[ i ] = new Vector3();\n\n\t\t}\n\n\t\tconst vA = new Vector3(),\n\t\t\tvB = new Vector3(),\n\t\t\tvC = new Vector3(),\n\n\t\t\tuvA = new Vector2(),\n\t\t\tuvB = new Vector2(),\n\t\t\tuvC = new Vector2(),\n\n\t\t\tsdir = new Vector3(),\n\t\t\ttdir = new Vector3();\n\n\t\tfunction handleTriangle( a, b, c ) {\n\n\t\t\tvA.fromArray( positions, a * 3 );\n\t\t\tvB.fromArray( positions, b * 3 );\n\t\t\tvC.fromArray( positions, c * 3 );\n\n\t\t\tuvA.fromArray( uvs, a * 2 );\n\t\t\tuvB.fromArray( uvs, b * 2 );\n\t\t\tuvC.fromArray( uvs, c * 2 );\n\n\t\t\tvB.sub( vA );\n\t\t\tvC.sub( vA );\n\n\t\t\tuvB.sub( uvA );\n\t\t\tuvC.sub( uvA );\n\n\t\t\tconst r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );\n\n\t\t\t// silently ignore degenerate uv triangles having coincident or colinear vertices\n\n\t\t\tif ( ! isFinite( r ) ) return;\n\n\t\t\tsdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );\n\t\t\ttdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );\n\n\t\t\ttan1[ a ].add( sdir );\n\t\t\ttan1[ b ].add( sdir );\n\t\t\ttan1[ c ].add( sdir );\n\n\t\t\ttan2[ a ].add( tdir );\n\t\t\ttan2[ b ].add( tdir );\n\t\t\ttan2[ c ].add( tdir );\n\n\t\t}\n\n\t\tlet groups = this.groups;\n\n\t\tif ( groups.length === 0 ) {\n\n\t\t\tgroups = [ {\n\t\t\t\tstart: 0,\n\t\t\t\tcount: indices.length\n\t\t\t} ];\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleTriangle(\n\t\t\t\t\tindices[ j + 0 ],\n\t\t\t\t\tindices[ j + 1 ],\n\t\t\t\t\tindices[ j + 2 ]\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst tmp = new Vector3(), tmp2 = new Vector3();\n\t\tconst n = new Vector3(), n2 = new Vector3();\n\n\t\tfunction handleVertex( v ) {\n\n\t\t\tn.fromArray( normals, v * 3 );\n\t\t\tn2.copy( n );\n\n\t\t\tconst t = tan1[ v ];\n\n\t\t\t// Gram-Schmidt orthogonalize\n\n\t\t\ttmp.copy( t );\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\n\t\t\t// Calculate handedness\n\n\t\t\ttmp2.crossVectors( n2, t );\n\t\t\tconst test = tmp2.dot( tan2[ v ] );\n\t\t\tconst w = ( test < 0.0 ) ? - 1.0 : 1.0;\n\n\t\t\ttangents[ v * 4 ] = tmp.x;\n\t\t\ttangents[ v * 4 + 1 ] = tmp.y;\n\t\t\ttangents[ v * 4 + 2 ] = tmp.z;\n\t\t\ttangents[ v * 4 + 3 ] = w;\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleVertex( indices[ j + 0 ] );\n\t\t\t\thandleVertex( indices[ j + 1 ] );\n\t\t\t\thandleVertex( indices[ j + 2 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcomputeVertexNormals() {\n\n\t\tconst index = this.index;\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute !== undefined ) {\n\n\t\t\tlet normalAttribute = this.getAttribute( 'normal' );\n\n\t\t\tif ( normalAttribute === undefined ) {\n\n\t\t\t\tnormalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );\n\t\t\t\tthis.setAttribute( 'normal', normalAttribute );\n\n\t\t\t} else {\n\n\t\t\t\t// reset existing normals to zero\n\n\t\t\t\tfor ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {\n\n\t\t\t\t\tnormalAttribute.setXYZ( i, 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\n\t\t\tconst nA = new Vector3(), nB = new Vector3(), nC = new Vector3();\n\t\t\tconst cb = new Vector3(), ab = new Vector3();\n\n\t\t\t// indexed elements\n\n\t\t\tif ( index ) {\n\n\t\t\t\tfor ( let i = 0, il = index.count; i < il; i += 3 ) {\n\n\t\t\t\t\tconst vA = index.getX( i + 0 );\n\t\t\t\t\tconst vB = index.getX( i + 1 );\n\t\t\t\t\tconst vC = index.getX( i + 2 );\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, vA );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, vB );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, vC );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnA.fromBufferAttribute( normalAttribute, vA );\n\t\t\t\t\tnB.fromBufferAttribute( normalAttribute, vB );\n\t\t\t\t\tnC.fromBufferAttribute( normalAttribute, vC );\n\n\t\t\t\t\tnA.add( cb );\n\t\t\t\t\tnB.add( cb );\n\t\t\t\t\tnC.add( cb );\n\n\t\t\t\t\tnormalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\tfor ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, i + 0 );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, i + 1 );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, i + 2 );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tnormalAttribute.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\t// @deprecated since r144\n\n\tmerge() {\n\n\t\tconsole.error( 'THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead.' );\n\t\treturn this;\n\n\t}\n\n\tnormalizeNormals() {\n\n\t\tconst normals = this.attributes.normal;\n\n\t\tfor ( let i = 0, il = normals.count; i < il; i ++ ) {\n\n\t\t\t_vector.fromBufferAttribute( normals, i );\n\n\t\t\t_vector.normalize();\n\n\t\t\tnormals.setXYZ( i, _vector.x, _vector.y, _vector.z );\n\n\t\t}\n\n\t}\n\n\ttoNonIndexed() {\n\n\t\tfunction convertBufferAttribute( attribute, indices ) {\n\n\t\t\tconst array = attribute.array;\n\t\t\tconst itemSize = attribute.itemSize;\n\t\t\tconst normalized = attribute.normalized;\n\n\t\t\tconst array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tlet index = 0, index2 = 0;\n\n\t\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\tindex = indices[ i ] * attribute.data.stride + attribute.offset;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( array2, itemSize, normalized );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.index === null ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst geometry2 = new BufferGeometry();\n\n\t\tconst indices = this.index.array;\n\t\tconst attributes = this.attributes;\n\n\t\t// attributes\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\n\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\tgeometry2.setAttribute( name, newAttribute );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = this.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst morphArray = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = morphAttribute[ i ];\n\n\t\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\t\tmorphArray.push( newAttribute );\n\n\t\t\t}\n\n\t\t\tgeometry2.morphAttributes[ name ] = morphArray;\n\n\t\t}\n\n\t\tgeometry2.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = this.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tgeometry2.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\treturn geometry2;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard BufferGeometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\t\tif ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tconst parameters = this.parameters;\n\n\t\t\tfor ( const key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\t// for simplicity the code assumes attributes are not shared across geometries, see #15811\n\n\t\tdata.data = { attributes: {} };\n\n\t\tconst index = this.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tdata.data.index = {\n\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\tarray: Array.prototype.slice.call( index.array )\n\t\t\t};\n\n\t\t}\n\n\t\tconst attributes = this.attributes;\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attribute = attributes[ key ];\n\n\t\t\tdata.data.attributes[ key ] = attribute.toJSON( data.data );\n\n\t\t}\n\n\t\tconst morphAttributes = {};\n\t\tlet hasMorphAttributes = false;\n\n\t\tfor ( const key in this.morphAttributes ) {\n\n\t\t\tconst attributeArray = this.morphAttributes[ key ];\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0, il = attributeArray.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = attributeArray[ i ];\n\n\t\t\t\tarray.push( attribute.toJSON( data.data ) );\n\n\t\t\t}\n\n\t\t\tif ( array.length > 0 ) {\n\n\t\t\t\tmorphAttributes[ key ] = array;\n\n\t\t\t\thasMorphAttributes = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( hasMorphAttributes ) {\n\n\t\t\tdata.data.morphAttributes = morphAttributes;\n\t\t\tdata.data.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t}\n\n\t\tconst groups = this.groups;\n\n\t\tif ( groups.length > 0 ) {\n\n\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\n\t\t}\n\n\t\tconst boundingSphere = this.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tdata.data.boundingSphere = {\n\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\tradius: boundingSphere.radius\n\t\t\t};\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tclone() {\n\n\t\t return new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\t// reset\n\n\t\tthis.index = null;\n\t\tthis.attributes = {};\n\t\tthis.morphAttributes = {};\n\t\tthis.groups = [];\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// used for storing cloned, shared data\n\n\t\tconst data = {};\n\n\t\t// name\n\n\t\tthis.name = source.name;\n\n\t\t// index\n\n\t\tconst index = source.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.setIndex( index.clone( data ) );\n\n\t\t}\n\n\t\t// attributes\n\n\t\tconst attributes = source.attributes;\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\t\t\tthis.setAttribute( name, attribute.clone( data ) );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = source.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst array = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {\n\n\t\t\t\tarray.push( morphAttribute[ i ].clone( data ) );\n\n\t\t\t}\n\n\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t}\n\n\t\tthis.morphTargetsRelative = source.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = source.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\t// bounding box\n\n\t\tconst boundingBox = source.boundingBox;\n\n\t\tif ( boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = boundingBox.clone();\n\n\t\t}\n\n\t\t// bounding sphere\n\n\t\tconst boundingSphere = source.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = boundingSphere.clone();\n\n\t\t}\n\n\t\t// draw range\n\n\t\tthis.drawRange.start = source.drawRange.start;\n\t\tthis.drawRange.count = source.drawRange.count;\n\n\t\t// user data\n\n\t\tthis.userData = source.userData;\n\n\t\t// geometry generator parameters\n\n\t\tif ( source.parameters !== undefined ) this.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n}\n\nexport { BufferGeometry };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}