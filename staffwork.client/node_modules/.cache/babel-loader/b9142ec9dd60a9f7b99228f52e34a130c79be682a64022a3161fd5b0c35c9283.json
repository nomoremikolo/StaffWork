{"ast":null,"code":"import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\nclass CylinderGeometry extends BufferGeometry {\n  constructor() {\n    let radiusTop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    let radiusBottom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    let height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    let radialSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 8;\n    let heightSegments = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n    let openEnded = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    let thetaStart = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n    let thetaLength = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : Math.PI * 2;\n    super();\n    this.type = 'CylinderGeometry';\n    this.parameters = {\n      radiusTop: radiusTop,\n      radiusBottom: radiusBottom,\n      height: height,\n      radialSegments: radialSegments,\n      heightSegments: heightSegments,\n      openEnded: openEnded,\n      thetaStart: thetaStart,\n      thetaLength: thetaLength\n    };\n    const scope = this;\n    radialSegments = Math.floor(radialSegments);\n    heightSegments = Math.floor(heightSegments);\n\n    // buffers\n\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n\n    // helper variables\n\n    let index = 0;\n    const indexArray = [];\n    const halfHeight = height / 2;\n    let groupStart = 0;\n\n    // generate geometry\n\n    generateTorso();\n    if (openEnded === false) {\n      if (radiusTop > 0) generateCap(true);\n      if (radiusBottom > 0) generateCap(false);\n    }\n\n    // build geometry\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n    function generateTorso() {\n      const normal = new Vector3();\n      const vertex = new Vector3();\n      let groupCount = 0;\n\n      // this will be used to calculate the normal\n      const slope = (radiusBottom - radiusTop) / height;\n\n      // generate vertices, normals and uvs\n\n      for (let y = 0; y <= heightSegments; y++) {\n        const indexRow = [];\n        const v = y / heightSegments;\n\n        // calculate the radius of the current row\n\n        const radius = v * (radiusBottom - radiusTop) + radiusTop;\n        for (let x = 0; x <= radialSegments; x++) {\n          const u = x / radialSegments;\n          const theta = u * thetaLength + thetaStart;\n          const sinTheta = Math.sin(theta);\n          const cosTheta = Math.cos(theta);\n\n          // vertex\n\n          vertex.x = radius * sinTheta;\n          vertex.y = -v * height + halfHeight;\n          vertex.z = radius * cosTheta;\n          vertices.push(vertex.x, vertex.y, vertex.z);\n\n          // normal\n\n          normal.set(sinTheta, slope, cosTheta).normalize();\n          normals.push(normal.x, normal.y, normal.z);\n\n          // uv\n\n          uvs.push(u, 1 - v);\n\n          // save index of vertex in respective row\n\n          indexRow.push(index++);\n        }\n\n        // now save vertices of the row in our index array\n\n        indexArray.push(indexRow);\n      }\n\n      // generate indices\n\n      for (let x = 0; x < radialSegments; x++) {\n        for (let y = 0; y < heightSegments; y++) {\n          // we use the index array to access the correct indices\n\n          const a = indexArray[y][x];\n          const b = indexArray[y + 1][x];\n          const c = indexArray[y + 1][x + 1];\n          const d = indexArray[y][x + 1];\n\n          // faces\n\n          indices.push(a, b, d);\n          indices.push(b, c, d);\n\n          // update group counter\n\n          groupCount += 6;\n        }\n      }\n\n      // add a group to the geometry. this will ensure multi material support\n\n      scope.addGroup(groupStart, groupCount, 0);\n\n      // calculate new start value for groups\n\n      groupStart += groupCount;\n    }\n    function generateCap(top) {\n      // save the index of the first center vertex\n      const centerIndexStart = index;\n      const uv = new Vector2();\n      const vertex = new Vector3();\n      let groupCount = 0;\n      const radius = top === true ? radiusTop : radiusBottom;\n      const sign = top === true ? 1 : -1;\n\n      // first we generate the center vertex data of the cap.\n      // because the geometry needs one set of uvs per face,\n      // we must generate a center vertex per face/segment\n\n      for (let x = 1; x <= radialSegments; x++) {\n        // vertex\n\n        vertices.push(0, halfHeight * sign, 0);\n\n        // normal\n\n        normals.push(0, sign, 0);\n\n        // uv\n\n        uvs.push(0.5, 0.5);\n\n        // increase index\n\n        index++;\n      }\n\n      // save the index of the last center vertex\n      const centerIndexEnd = index;\n\n      // now we generate the surrounding vertices, normals and uvs\n\n      for (let x = 0; x <= radialSegments; x++) {\n        const u = x / radialSegments;\n        const theta = u * thetaLength + thetaStart;\n        const cosTheta = Math.cos(theta);\n        const sinTheta = Math.sin(theta);\n\n        // vertex\n\n        vertex.x = radius * sinTheta;\n        vertex.y = halfHeight * sign;\n        vertex.z = radius * cosTheta;\n        vertices.push(vertex.x, vertex.y, vertex.z);\n\n        // normal\n\n        normals.push(0, sign, 0);\n\n        // uv\n\n        uv.x = cosTheta * 0.5 + 0.5;\n        uv.y = sinTheta * 0.5 * sign + 0.5;\n        uvs.push(uv.x, uv.y);\n\n        // increase index\n\n        index++;\n      }\n\n      // generate indices\n\n      for (let x = 0; x < radialSegments; x++) {\n        const c = centerIndexStart + x;\n        const i = centerIndexEnd + x;\n        if (top === true) {\n          // face top\n\n          indices.push(i, i + 1, c);\n        } else {\n          // face bottom\n\n          indices.push(i + 1, i, c);\n        }\n        groupCount += 3;\n      }\n\n      // add a group to the geometry. this will ensure multi material support\n\n      scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);\n\n      // calculate new start value for groups\n\n      groupStart += groupCount;\n    }\n  }\n  static fromJSON(data) {\n    return new CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);\n  }\n}\nexport { CylinderGeometry };","map":{"version":3,"names":["BufferGeometry","Float32BufferAttribute","Vector3","Vector2","CylinderGeometry","constructor","radiusTop","radiusBottom","height","radialSegments","heightSegments","openEnded","thetaStart","thetaLength","Math","PI","type","parameters","scope","floor","indices","vertices","normals","uvs","index","indexArray","halfHeight","groupStart","generateTorso","generateCap","setIndex","setAttribute","normal","vertex","groupCount","slope","y","indexRow","v","radius","x","u","theta","sinTheta","sin","cosTheta","cos","z","push","set","normalize","a","b","c","d","addGroup","top","centerIndexStart","uv","sign","centerIndexEnd","i","fromJSON","data"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/geometries/CylinderGeometry.js"],"sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\n\nclass CylinderGeometry extends BufferGeometry {\n\n\tconstructor( radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'CylinderGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradiusTop: radiusTop,\n\t\t\tradiusBottom: radiusBottom,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tconst scope = this;\n\n\t\tradialSegments = Math.floor( radialSegments );\n\t\theightSegments = Math.floor( heightSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tlet index = 0;\n\t\tconst indexArray = [];\n\t\tconst halfHeight = height / 2;\n\t\tlet groupStart = 0;\n\n\t\t// generate geometry\n\n\t\tgenerateTorso();\n\n\t\tif ( openEnded === false ) {\n\n\t\t\tif ( radiusTop > 0 ) generateCap( true );\n\t\t\tif ( radiusBottom > 0 ) generateCap( false );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\tfunction generateTorso() {\n\n\t\t\tconst normal = new Vector3();\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tlet groupCount = 0;\n\n\t\t\t// this will be used to calculate the normal\n\t\t\tconst slope = ( radiusBottom - radiusTop ) / height;\n\n\t\t\t// generate vertices, normals and uvs\n\n\t\t\tfor ( let y = 0; y <= heightSegments; y ++ ) {\n\n\t\t\t\tconst indexRow = [];\n\n\t\t\t\tconst v = y / heightSegments;\n\n\t\t\t\t// calculate the radius of the current row\n\n\t\t\t\tconst radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n\n\t\t\t\tfor ( let x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\t\tconst u = x / radialSegments;\n\n\t\t\t\t\tconst theta = u * thetaLength + thetaStart;\n\n\t\t\t\t\tconst sinTheta = Math.sin( theta );\n\t\t\t\t\tconst cosTheta = Math.cos( theta );\n\n\t\t\t\t\t// vertex\n\n\t\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\t\tvertex.y = - v * height + halfHeight;\n\t\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t\t// normal\n\n\t\t\t\t\tnormal.set( sinTheta, slope, cosTheta ).normalize();\n\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t\t// uv\n\n\t\t\t\t\tuvs.push( u, 1 - v );\n\n\t\t\t\t\t// save index of vertex in respective row\n\n\t\t\t\t\tindexRow.push( index ++ );\n\n\t\t\t\t}\n\n\t\t\t\t// now save vertices of the row in our index array\n\n\t\t\t\tindexArray.push( indexRow );\n\n\t\t\t}\n\n\t\t\t// generate indices\n\n\t\t\tfor ( let x = 0; x < radialSegments; x ++ ) {\n\n\t\t\t\tfor ( let y = 0; y < heightSegments; y ++ ) {\n\n\t\t\t\t\t// we use the index array to access the correct indices\n\n\t\t\t\t\tconst a = indexArray[ y ][ x ];\n\t\t\t\t\tconst b = indexArray[ y + 1 ][ x ];\n\t\t\t\t\tconst c = indexArray[ y + 1 ][ x + 1 ];\n\t\t\t\t\tconst d = indexArray[ y ][ x + 1 ];\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t\t// update group counter\n\n\t\t\t\t\tgroupCount += 6;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\t\tscope.addGroup( groupStart, groupCount, 0 );\n\n\t\t\t// calculate new start value for groups\n\n\t\t\tgroupStart += groupCount;\n\n\t\t}\n\n\t\tfunction generateCap( top ) {\n\n\t\t\t// save the index of the first center vertex\n\t\t\tconst centerIndexStart = index;\n\n\t\t\tconst uv = new Vector2();\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tlet groupCount = 0;\n\n\t\t\tconst radius = ( top === true ) ? radiusTop : radiusBottom;\n\t\t\tconst sign = ( top === true ) ? 1 : - 1;\n\n\t\t\t// first we generate the center vertex data of the cap.\n\t\t\t// because the geometry needs one set of uvs per face,\n\t\t\t// we must generate a center vertex per face/segment\n\n\t\t\tfor ( let x = 1; x <= radialSegments; x ++ ) {\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertices.push( 0, halfHeight * sign, 0 );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormals.push( 0, sign, 0 );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( 0.5, 0.5 );\n\n\t\t\t\t// increase index\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// save the index of the last center vertex\n\t\t\tconst centerIndexEnd = index;\n\n\t\t\t// now we generate the surrounding vertices, normals and uvs\n\n\t\t\tfor ( let x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\tconst u = x / radialSegments;\n\t\t\t\tconst theta = u * thetaLength + thetaStart;\n\n\t\t\t\tconst cosTheta = Math.cos( theta );\n\t\t\t\tconst sinTheta = Math.sin( theta );\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\tvertex.y = halfHeight * sign;\n\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormals.push( 0, sign, 0 );\n\n\t\t\t\t// uv\n\n\t\t\t\tuv.x = ( cosTheta * 0.5 ) + 0.5;\n\t\t\t\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\t// increase index\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// generate indices\n\n\t\t\tfor ( let x = 0; x < radialSegments; x ++ ) {\n\n\t\t\t\tconst c = centerIndexStart + x;\n\t\t\t\tconst i = centerIndexEnd + x;\n\n\t\t\t\tif ( top === true ) {\n\n\t\t\t\t\t// face top\n\n\t\t\t\t\tindices.push( i, i + 1, c );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// face bottom\n\n\t\t\t\t\tindices.push( i + 1, i, c );\n\n\t\t\t\t}\n\n\t\t\t\tgroupCount += 3;\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\t\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\n\n\t\t\t// calculate new start value for groups\n\n\t\t\tgroupStart += groupCount;\n\n\t\t}\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new CylinderGeometry( data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\n\nexport { CylinderGeometry };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}