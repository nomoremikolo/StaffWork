{"ast":null,"code":"function WebGLAttributes(gl, capabilities) {\n  const isWebGL2 = capabilities.isWebGL2;\n  const buffers = new WeakMap();\n  function createBuffer(attribute, bufferType) {\n    const array = attribute.array;\n    const usage = attribute.usage;\n    const buffer = gl.createBuffer();\n    gl.bindBuffer(bufferType, buffer);\n    gl.bufferData(bufferType, array, usage);\n    attribute.onUploadCallback();\n    let type;\n    if (array instanceof Float32Array) {\n      type = gl.FLOAT;\n    } else if (array instanceof Uint16Array) {\n      if (attribute.isFloat16BufferAttribute) {\n        if (isWebGL2) {\n          type = gl.HALF_FLOAT;\n        } else {\n          throw new Error('THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.');\n        }\n      } else {\n        type = gl.UNSIGNED_SHORT;\n      }\n    } else if (array instanceof Int16Array) {\n      type = gl.SHORT;\n    } else if (array instanceof Uint32Array) {\n      type = gl.UNSIGNED_INT;\n    } else if (array instanceof Int32Array) {\n      type = gl.INT;\n    } else if (array instanceof Int8Array) {\n      type = gl.BYTE;\n    } else if (array instanceof Uint8Array) {\n      type = gl.UNSIGNED_BYTE;\n    } else if (array instanceof Uint8ClampedArray) {\n      type = gl.UNSIGNED_BYTE;\n    } else {\n      throw new Error('THREE.WebGLAttributes: Unsupported buffer data format: ' + array);\n    }\n    return {\n      buffer: buffer,\n      type: type,\n      bytesPerElement: array.BYTES_PER_ELEMENT,\n      version: attribute.version\n    };\n  }\n  function updateBuffer(buffer, attribute, bufferType) {\n    const array = attribute.array;\n    const updateRange = attribute.updateRange;\n    gl.bindBuffer(bufferType, buffer);\n    if (updateRange.count === -1) {\n      // Not using update ranges\n\n      gl.bufferSubData(bufferType, 0, array);\n    } else {\n      if (isWebGL2) {\n        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);\n      } else {\n        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));\n      }\n      updateRange.count = -1; // reset range\n    }\n\n    attribute.onUploadCallback();\n  }\n\n  //\n\n  function get(attribute) {\n    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;\n    return buffers.get(attribute);\n  }\n  function remove(attribute) {\n    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;\n    const data = buffers.get(attribute);\n    if (data) {\n      gl.deleteBuffer(data.buffer);\n      buffers.delete(attribute);\n    }\n  }\n  function update(attribute, bufferType) {\n    if (attribute.isGLBufferAttribute) {\n      const cached = buffers.get(attribute);\n      if (!cached || cached.version < attribute.version) {\n        buffers.set(attribute, {\n          buffer: attribute.buffer,\n          type: attribute.type,\n          bytesPerElement: attribute.elementSize,\n          version: attribute.version\n        });\n      }\n      return;\n    }\n    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;\n    const data = buffers.get(attribute);\n    if (data === undefined) {\n      buffers.set(attribute, createBuffer(attribute, bufferType));\n    } else if (data.version < attribute.version) {\n      updateBuffer(data.buffer, attribute, bufferType);\n      data.version = attribute.version;\n    }\n  }\n  return {\n    get: get,\n    remove: remove,\n    update: update\n  };\n}\nexport { WebGLAttributes };","map":{"version":3,"names":["WebGLAttributes","gl","capabilities","isWebGL2","buffers","WeakMap","createBuffer","attribute","bufferType","array","usage","buffer","bindBuffer","bufferData","onUploadCallback","type","Float32Array","FLOAT","Uint16Array","isFloat16BufferAttribute","HALF_FLOAT","Error","UNSIGNED_SHORT","Int16Array","SHORT","Uint32Array","UNSIGNED_INT","Int32Array","INT","Int8Array","BYTE","Uint8Array","UNSIGNED_BYTE","Uint8ClampedArray","bytesPerElement","BYTES_PER_ELEMENT","version","updateBuffer","updateRange","count","bufferSubData","offset","subarray","get","isInterleavedBufferAttribute","data","remove","deleteBuffer","delete","update","isGLBufferAttribute","cached","set","elementSize","undefined"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/renderers/webgl/WebGLAttributes.js"],"sourcesContent":["function WebGLAttributes( gl, capabilities ) {\n\n\tconst isWebGL2 = capabilities.isWebGL2;\n\n\tconst buffers = new WeakMap();\n\n\tfunction createBuffer( attribute, bufferType ) {\n\n\t\tconst array = attribute.array;\n\t\tconst usage = attribute.usage;\n\n\t\tconst buffer = gl.createBuffer();\n\n\t\tgl.bindBuffer( bufferType, buffer );\n\t\tgl.bufferData( bufferType, array, usage );\n\n\t\tattribute.onUploadCallback();\n\n\t\tlet type;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\ttype = gl.FLOAT;\n\n\t\t} else if ( array instanceof Uint16Array ) {\n\n\t\t\tif ( attribute.isFloat16BufferAttribute ) {\n\n\t\t\t\tif ( isWebGL2 ) {\n\n\t\t\t\t\ttype = gl.HALF_FLOAT;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.' );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\ttype = gl.UNSIGNED_SHORT;\n\n\t\t\t}\n\n\t\t} else if ( array instanceof Int16Array ) {\n\n\t\t\ttype = gl.SHORT;\n\n\t\t} else if ( array instanceof Uint32Array ) {\n\n\t\t\ttype = gl.UNSIGNED_INT;\n\n\t\t} else if ( array instanceof Int32Array ) {\n\n\t\t\ttype = gl.INT;\n\n\t\t} else if ( array instanceof Int8Array ) {\n\n\t\t\ttype = gl.BYTE;\n\n\t\t} else if ( array instanceof Uint8Array ) {\n\n\t\t\ttype = gl.UNSIGNED_BYTE;\n\n\t\t} else if ( array instanceof Uint8ClampedArray ) {\n\n\t\t\ttype = gl.UNSIGNED_BYTE;\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.WebGLAttributes: Unsupported buffer data format: ' + array );\n\n\t\t}\n\n\t\treturn {\n\t\t\tbuffer: buffer,\n\t\t\ttype: type,\n\t\t\tbytesPerElement: array.BYTES_PER_ELEMENT,\n\t\t\tversion: attribute.version\n\t\t};\n\n\t}\n\n\tfunction updateBuffer( buffer, attribute, bufferType ) {\n\n\t\tconst array = attribute.array;\n\t\tconst updateRange = attribute.updateRange;\n\n\t\tgl.bindBuffer( bufferType, buffer );\n\n\t\tif ( updateRange.count === - 1 ) {\n\n\t\t\t// Not using update ranges\n\n\t\t\tgl.bufferSubData( bufferType, 0, array );\n\n\t\t} else {\n\n\t\t\tif ( isWebGL2 ) {\n\n\t\t\t\tgl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,\n\t\t\t\t\tarray, updateRange.offset, updateRange.count );\n\n\t\t\t} else {\n\n\t\t\t\tgl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,\n\t\t\t\t\tarray.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );\n\n\t\t\t}\n\n\t\t\tupdateRange.count = - 1; // reset range\n\n\t\t}\n\n\t\tattribute.onUploadCallback();\n\n\t}\n\n\t//\n\n\tfunction get( attribute ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\treturn buffers.get( attribute );\n\n\t}\n\n\tfunction remove( attribute ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\tconst data = buffers.get( attribute );\n\n\t\tif ( data ) {\n\n\t\t\tgl.deleteBuffer( data.buffer );\n\n\t\t\tbuffers.delete( attribute );\n\n\t\t}\n\n\t}\n\n\tfunction update( attribute, bufferType ) {\n\n\t\tif ( attribute.isGLBufferAttribute ) {\n\n\t\t\tconst cached = buffers.get( attribute );\n\n\t\t\tif ( ! cached || cached.version < attribute.version ) {\n\n\t\t\t\tbuffers.set( attribute, {\n\t\t\t\t\tbuffer: attribute.buffer,\n\t\t\t\t\ttype: attribute.type,\n\t\t\t\t\tbytesPerElement: attribute.elementSize,\n\t\t\t\t\tversion: attribute.version\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\tconst data = buffers.get( attribute );\n\n\t\tif ( data === undefined ) {\n\n\t\t\tbuffers.set( attribute, createBuffer( attribute, bufferType ) );\n\n\t\t} else if ( data.version < attribute.version ) {\n\n\t\t\tupdateBuffer( data.buffer, attribute, bufferType );\n\n\t\t\tdata.version = attribute.version;\n\n\t\t}\n\n\t}\n\n\treturn {\n\n\t\tget: get,\n\t\tremove: remove,\n\t\tupdate: update\n\n\t};\n\n}\n\n\nexport { WebGLAttributes };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}