{"ast":null,"code":"import { Vector3 } from '../../math/Vector3.js';\nimport { Group } from '../../objects/Group.js';\nconst _moveEvent = {\n  type: 'move'\n};\nclass WebXRController {\n  constructor() {\n    this._targetRay = null;\n    this._grip = null;\n    this._hand = null;\n  }\n  getHandSpace() {\n    if (this._hand === null) {\n      this._hand = new Group();\n      this._hand.matrixAutoUpdate = false;\n      this._hand.visible = false;\n      this._hand.joints = {};\n      this._hand.inputState = {\n        pinching: false\n      };\n    }\n    return this._hand;\n  }\n  getTargetRaySpace() {\n    if (this._targetRay === null) {\n      this._targetRay = new Group();\n      this._targetRay.matrixAutoUpdate = false;\n      this._targetRay.visible = false;\n      this._targetRay.hasLinearVelocity = false;\n      this._targetRay.linearVelocity = new Vector3();\n      this._targetRay.hasAngularVelocity = false;\n      this._targetRay.angularVelocity = new Vector3();\n    }\n    return this._targetRay;\n  }\n  getGripSpace() {\n    if (this._grip === null) {\n      this._grip = new Group();\n      this._grip.matrixAutoUpdate = false;\n      this._grip.visible = false;\n      this._grip.hasLinearVelocity = false;\n      this._grip.linearVelocity = new Vector3();\n      this._grip.hasAngularVelocity = false;\n      this._grip.angularVelocity = new Vector3();\n    }\n    return this._grip;\n  }\n  dispatchEvent(event) {\n    if (this._targetRay !== null) {\n      this._targetRay.dispatchEvent(event);\n    }\n    if (this._grip !== null) {\n      this._grip.dispatchEvent(event);\n    }\n    if (this._hand !== null) {\n      this._hand.dispatchEvent(event);\n    }\n    return this;\n  }\n  connect(inputSource) {\n    if (inputSource && inputSource.hand) {\n      const hand = this._hand;\n      if (hand) {\n        for (const inputjoint of inputSource.hand.values()) {\n          // Initialize hand with joints when connected\n          this._getHandJoint(hand, inputjoint);\n        }\n      }\n    }\n    this.dispatchEvent({\n      type: 'connected',\n      data: inputSource\n    });\n    return this;\n  }\n  disconnect(inputSource) {\n    this.dispatchEvent({\n      type: 'disconnected',\n      data: inputSource\n    });\n    if (this._targetRay !== null) {\n      this._targetRay.visible = false;\n    }\n    if (this._grip !== null) {\n      this._grip.visible = false;\n    }\n    if (this._hand !== null) {\n      this._hand.visible = false;\n    }\n    return this;\n  }\n  update(inputSource, frame, referenceSpace) {\n    let inputPose = null;\n    let gripPose = null;\n    let handPose = null;\n    const targetRay = this._targetRay;\n    const grip = this._grip;\n    const hand = this._hand;\n    if (inputSource && frame.session.visibilityState !== 'visible-blurred') {\n      if (hand && inputSource.hand) {\n        handPose = true;\n        for (const inputjoint of inputSource.hand.values()) {\n          // Update the joints groups with the XRJoint poses\n          const jointPose = frame.getJointPose(inputjoint, referenceSpace);\n\n          // The transform of this joint will be updated with the joint pose on each frame\n          const joint = this._getHandJoint(hand, inputjoint);\n          if (jointPose !== null) {\n            joint.matrix.fromArray(jointPose.transform.matrix);\n            joint.matrix.decompose(joint.position, joint.rotation, joint.scale);\n            joint.jointRadius = jointPose.radius;\n          }\n          joint.visible = jointPose !== null;\n        }\n\n        // Custom events\n\n        // Check pinchz\n        const indexTip = hand.joints['index-finger-tip'];\n        const thumbTip = hand.joints['thumb-tip'];\n        const distance = indexTip.position.distanceTo(thumbTip.position);\n        const distanceToPinch = 0.02;\n        const threshold = 0.005;\n        if (hand.inputState.pinching && distance > distanceToPinch + threshold) {\n          hand.inputState.pinching = false;\n          this.dispatchEvent({\n            type: 'pinchend',\n            handedness: inputSource.handedness,\n            target: this\n          });\n        } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {\n          hand.inputState.pinching = true;\n          this.dispatchEvent({\n            type: 'pinchstart',\n            handedness: inputSource.handedness,\n            target: this\n          });\n        }\n      } else {\n        if (grip !== null && inputSource.gripSpace) {\n          gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);\n          if (gripPose !== null) {\n            grip.matrix.fromArray(gripPose.transform.matrix);\n            grip.matrix.decompose(grip.position, grip.rotation, grip.scale);\n            if (gripPose.linearVelocity) {\n              grip.hasLinearVelocity = true;\n              grip.linearVelocity.copy(gripPose.linearVelocity);\n            } else {\n              grip.hasLinearVelocity = false;\n            }\n            if (gripPose.angularVelocity) {\n              grip.hasAngularVelocity = true;\n              grip.angularVelocity.copy(gripPose.angularVelocity);\n            } else {\n              grip.hasAngularVelocity = false;\n            }\n          }\n        }\n      }\n      if (targetRay !== null) {\n        inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);\n\n        // Some runtimes (namely Vive Cosmos with Vive OpenXR Runtime) have only grip space and ray space is equal to it\n        if (inputPose === null && gripPose !== null) {\n          inputPose = gripPose;\n        }\n        if (inputPose !== null) {\n          targetRay.matrix.fromArray(inputPose.transform.matrix);\n          targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);\n          if (inputPose.linearVelocity) {\n            targetRay.hasLinearVelocity = true;\n            targetRay.linearVelocity.copy(inputPose.linearVelocity);\n          } else {\n            targetRay.hasLinearVelocity = false;\n          }\n          if (inputPose.angularVelocity) {\n            targetRay.hasAngularVelocity = true;\n            targetRay.angularVelocity.copy(inputPose.angularVelocity);\n          } else {\n            targetRay.hasAngularVelocity = false;\n          }\n          this.dispatchEvent(_moveEvent);\n        }\n      }\n    }\n    if (targetRay !== null) {\n      targetRay.visible = inputPose !== null;\n    }\n    if (grip !== null) {\n      grip.visible = gripPose !== null;\n    }\n    if (hand !== null) {\n      hand.visible = handPose !== null;\n    }\n    return this;\n  }\n\n  // private method\n\n  _getHandJoint(hand, inputjoint) {\n    if (hand.joints[inputjoint.jointName] === undefined) {\n      const joint = new Group();\n      joint.matrixAutoUpdate = false;\n      joint.visible = false;\n      hand.joints[inputjoint.jointName] = joint;\n      hand.add(joint);\n    }\n    return hand.joints[inputjoint.jointName];\n  }\n}\nexport { WebXRController };","map":{"version":3,"names":["Vector3","Group","_moveEvent","type","WebXRController","constructor","_targetRay","_grip","_hand","getHandSpace","matrixAutoUpdate","visible","joints","inputState","pinching","getTargetRaySpace","hasLinearVelocity","linearVelocity","hasAngularVelocity","angularVelocity","getGripSpace","dispatchEvent","event","connect","inputSource","hand","inputjoint","values","_getHandJoint","data","disconnect","update","frame","referenceSpace","inputPose","gripPose","handPose","targetRay","grip","session","visibilityState","jointPose","getJointPose","joint","matrix","fromArray","transform","decompose","position","rotation","scale","jointRadius","radius","indexTip","thumbTip","distance","distanceTo","distanceToPinch","threshold","handedness","target","gripSpace","getPose","copy","targetRaySpace","jointName","undefined","add"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/renderers/webxr/WebXRController.js"],"sourcesContent":["import { Vector3 } from '../../math/Vector3.js';\nimport { Group } from '../../objects/Group.js';\n\nconst _moveEvent = { type: 'move' };\n\nclass WebXRController {\n\n\tconstructor() {\n\n\t\tthis._targetRay = null;\n\t\tthis._grip = null;\n\t\tthis._hand = null;\n\n\t}\n\n\tgetHandSpace() {\n\n\t\tif ( this._hand === null ) {\n\n\t\t\tthis._hand = new Group();\n\t\t\tthis._hand.matrixAutoUpdate = false;\n\t\t\tthis._hand.visible = false;\n\n\t\t\tthis._hand.joints = {};\n\t\t\tthis._hand.inputState = { pinching: false };\n\n\t\t}\n\n\t\treturn this._hand;\n\n\t}\n\n\tgetTargetRaySpace() {\n\n\t\tif ( this._targetRay === null ) {\n\n\t\t\tthis._targetRay = new Group();\n\t\t\tthis._targetRay.matrixAutoUpdate = false;\n\t\t\tthis._targetRay.visible = false;\n\t\t\tthis._targetRay.hasLinearVelocity = false;\n\t\t\tthis._targetRay.linearVelocity = new Vector3();\n\t\t\tthis._targetRay.hasAngularVelocity = false;\n\t\t\tthis._targetRay.angularVelocity = new Vector3();\n\n\t\t}\n\n\t\treturn this._targetRay;\n\n\t}\n\n\tgetGripSpace() {\n\n\t\tif ( this._grip === null ) {\n\n\t\t\tthis._grip = new Group();\n\t\t\tthis._grip.matrixAutoUpdate = false;\n\t\t\tthis._grip.visible = false;\n\t\t\tthis._grip.hasLinearVelocity = false;\n\t\t\tthis._grip.linearVelocity = new Vector3();\n\t\t\tthis._grip.hasAngularVelocity = false;\n\t\t\tthis._grip.angularVelocity = new Vector3();\n\n\t\t}\n\n\t\treturn this._grip;\n\n\t}\n\n\tdispatchEvent( event ) {\n\n\t\tif ( this._targetRay !== null ) {\n\n\t\t\tthis._targetRay.dispatchEvent( event );\n\n\t\t}\n\n\t\tif ( this._grip !== null ) {\n\n\t\t\tthis._grip.dispatchEvent( event );\n\n\t\t}\n\n\t\tif ( this._hand !== null ) {\n\n\t\t\tthis._hand.dispatchEvent( event );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tconnect( inputSource ) {\n\n\t\tif ( inputSource && inputSource.hand ) {\n\n\t\t\tconst hand = this._hand;\n\n\t\t\tif ( hand ) {\n\n\t\t\t\tfor ( const inputjoint of inputSource.hand.values() ) {\n\n\t\t\t\t\t// Initialize hand with joints when connected\n\t\t\t\t\tthis._getHandJoint( hand, inputjoint );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.dispatchEvent( { type: 'connected', data: inputSource } );\n\n\t\treturn this;\n\n\t}\n\n\tdisconnect( inputSource ) {\n\n\t\tthis.dispatchEvent( { type: 'disconnected', data: inputSource } );\n\n\t\tif ( this._targetRay !== null ) {\n\n\t\t\tthis._targetRay.visible = false;\n\n\t\t}\n\n\t\tif ( this._grip !== null ) {\n\n\t\t\tthis._grip.visible = false;\n\n\t\t}\n\n\t\tif ( this._hand !== null ) {\n\n\t\t\tthis._hand.visible = false;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tupdate( inputSource, frame, referenceSpace ) {\n\n\t\tlet inputPose = null;\n\t\tlet gripPose = null;\n\t\tlet handPose = null;\n\n\t\tconst targetRay = this._targetRay;\n\t\tconst grip = this._grip;\n\t\tconst hand = this._hand;\n\n\t\tif ( inputSource && frame.session.visibilityState !== 'visible-blurred' ) {\n\n\t\t\tif ( hand && inputSource.hand ) {\n\n\t\t\t\thandPose = true;\n\n\t\t\t\tfor ( const inputjoint of inputSource.hand.values() ) {\n\n\t\t\t\t\t// Update the joints groups with the XRJoint poses\n\t\t\t\t\tconst jointPose = frame.getJointPose( inputjoint, referenceSpace );\n\n\t\t\t\t\t// The transform of this joint will be updated with the joint pose on each frame\n\t\t\t\t\tconst joint = this._getHandJoint( hand, inputjoint );\n\n\t\t\t\t\tif ( jointPose !== null ) {\n\n\t\t\t\t\t\tjoint.matrix.fromArray( jointPose.transform.matrix );\n\t\t\t\t\t\tjoint.matrix.decompose( joint.position, joint.rotation, joint.scale );\n\t\t\t\t\t\tjoint.jointRadius = jointPose.radius;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tjoint.visible = jointPose !== null;\n\n\t\t\t\t}\n\n\t\t\t\t// Custom events\n\n\t\t\t\t// Check pinchz\n\t\t\t\tconst indexTip = hand.joints[ 'index-finger-tip' ];\n\t\t\t\tconst thumbTip = hand.joints[ 'thumb-tip' ];\n\t\t\t\tconst distance = indexTip.position.distanceTo( thumbTip.position );\n\n\t\t\t\tconst distanceToPinch = 0.02;\n\t\t\t\tconst threshold = 0.005;\n\n\t\t\t\tif ( hand.inputState.pinching && distance > distanceToPinch + threshold ) {\n\n\t\t\t\t\thand.inputState.pinching = false;\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'pinchend',\n\t\t\t\t\t\thandedness: inputSource.handedness,\n\t\t\t\t\t\ttarget: this\n\t\t\t\t\t} );\n\n\t\t\t\t} else if ( ! hand.inputState.pinching && distance <= distanceToPinch - threshold ) {\n\n\t\t\t\t\thand.inputState.pinching = true;\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'pinchstart',\n\t\t\t\t\t\thandedness: inputSource.handedness,\n\t\t\t\t\t\ttarget: this\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( grip !== null && inputSource.gripSpace ) {\n\n\t\t\t\t\tgripPose = frame.getPose( inputSource.gripSpace, referenceSpace );\n\n\t\t\t\t\tif ( gripPose !== null ) {\n\n\t\t\t\t\t\tgrip.matrix.fromArray( gripPose.transform.matrix );\n\t\t\t\t\t\tgrip.matrix.decompose( grip.position, grip.rotation, grip.scale );\n\n\t\t\t\t\t\tif ( gripPose.linearVelocity ) {\n\n\t\t\t\t\t\t\tgrip.hasLinearVelocity = true;\n\t\t\t\t\t\t\tgrip.linearVelocity.copy( gripPose.linearVelocity );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tgrip.hasLinearVelocity = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( gripPose.angularVelocity ) {\n\n\t\t\t\t\t\t\tgrip.hasAngularVelocity = true;\n\t\t\t\t\t\t\tgrip.angularVelocity.copy( gripPose.angularVelocity );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tgrip.hasAngularVelocity = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( targetRay !== null ) {\n\n\t\t\t\tinputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );\n\n\t\t\t\t// Some runtimes (namely Vive Cosmos with Vive OpenXR Runtime) have only grip space and ray space is equal to it\n\t\t\t\tif ( inputPose === null && gripPose !== null ) {\n\n\t\t\t\t\tinputPose = gripPose;\n\n\t\t\t\t}\n\n\t\t\t\tif ( inputPose !== null ) {\n\n\t\t\t\t\ttargetRay.matrix.fromArray( inputPose.transform.matrix );\n\t\t\t\t\ttargetRay.matrix.decompose( targetRay.position, targetRay.rotation, targetRay.scale );\n\n\t\t\t\t\tif ( inputPose.linearVelocity ) {\n\n\t\t\t\t\t\ttargetRay.hasLinearVelocity = true;\n\t\t\t\t\t\ttargetRay.linearVelocity.copy( inputPose.linearVelocity );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttargetRay.hasLinearVelocity = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( inputPose.angularVelocity ) {\n\n\t\t\t\t\t\ttargetRay.hasAngularVelocity = true;\n\t\t\t\t\t\ttargetRay.angularVelocity.copy( inputPose.angularVelocity );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttargetRay.hasAngularVelocity = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.dispatchEvent( _moveEvent );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t}\n\n\t\tif ( targetRay !== null ) {\n\n\t\t\ttargetRay.visible = ( inputPose !== null );\n\n\t\t}\n\n\t\tif ( grip !== null ) {\n\n\t\t\tgrip.visible = ( gripPose !== null );\n\n\t\t}\n\n\t\tif ( hand !== null ) {\n\n\t\t\thand.visible = ( handPose !== null );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// private method\n\n\t_getHandJoint( hand, inputjoint ) {\n\n\t\tif ( hand.joints[ inputjoint.jointName ] === undefined ) {\n\n\t\t\tconst joint = new Group();\n\t\t\tjoint.matrixAutoUpdate = false;\n\t\t\tjoint.visible = false;\n\t\t\thand.joints[ inputjoint.jointName ] = joint;\n\n\t\t\thand.add( joint );\n\n\t\t}\n\n\t\treturn hand.joints[ inputjoint.jointName ];\n\n\t}\n\n}\n\n\nexport { WebXRController };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}