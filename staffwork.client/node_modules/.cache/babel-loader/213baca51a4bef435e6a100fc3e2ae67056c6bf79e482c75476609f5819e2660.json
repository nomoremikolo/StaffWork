{"ast":null,"code":"import { Matrix3 } from '../../math/Matrix3.js';\nimport { Plane } from '../../math/Plane.js';\nfunction WebGLClipping(properties) {\n  const scope = this;\n  let globalState = null,\n    numGlobalPlanes = 0,\n    localClippingEnabled = false,\n    renderingShadows = false;\n  const plane = new Plane(),\n    viewNormalMatrix = new Matrix3(),\n    uniform = {\n      value: null,\n      needsUpdate: false\n    };\n  this.uniform = uniform;\n  this.numPlanes = 0;\n  this.numIntersection = 0;\n  this.init = function (planes, enableLocalClipping, camera) {\n    const enabled = planes.length !== 0 || enableLocalClipping ||\n    // enable state of previous frame - the clipping code has to\n    // run another frame in order to reset the state:\n    numGlobalPlanes !== 0 || localClippingEnabled;\n    localClippingEnabled = enableLocalClipping;\n    globalState = projectPlanes(planes, camera, 0);\n    numGlobalPlanes = planes.length;\n    return enabled;\n  };\n  this.beginShadows = function () {\n    renderingShadows = true;\n    projectPlanes(null);\n  };\n  this.endShadows = function () {\n    renderingShadows = false;\n    resetGlobalState();\n  };\n  this.setState = function (material, camera, useCache) {\n    const planes = material.clippingPlanes,\n      clipIntersection = material.clipIntersection,\n      clipShadows = material.clipShadows;\n    const materialProperties = properties.get(material);\n    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {\n      // there's no local clipping\n\n      if (renderingShadows) {\n        // there's no global clipping\n\n        projectPlanes(null);\n      } else {\n        resetGlobalState();\n      }\n    } else {\n      const nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n        lGlobal = nGlobal * 4;\n      let dstArray = materialProperties.clippingState || null;\n      uniform.value = dstArray; // ensure unique state\n\n      dstArray = projectPlanes(planes, camera, lGlobal, useCache);\n      for (let i = 0; i !== lGlobal; ++i) {\n        dstArray[i] = globalState[i];\n      }\n      materialProperties.clippingState = dstArray;\n      this.numIntersection = clipIntersection ? this.numPlanes : 0;\n      this.numPlanes += nGlobal;\n    }\n  };\n  function resetGlobalState() {\n    if (uniform.value !== globalState) {\n      uniform.value = globalState;\n      uniform.needsUpdate = numGlobalPlanes > 0;\n    }\n    scope.numPlanes = numGlobalPlanes;\n    scope.numIntersection = 0;\n  }\n  function projectPlanes(planes, camera, dstOffset, skipTransform) {\n    const nPlanes = planes !== null ? planes.length : 0;\n    let dstArray = null;\n    if (nPlanes !== 0) {\n      dstArray = uniform.value;\n      if (skipTransform !== true || dstArray === null) {\n        const flatSize = dstOffset + nPlanes * 4,\n          viewMatrix = camera.matrixWorldInverse;\n        viewNormalMatrix.getNormalMatrix(viewMatrix);\n        if (dstArray === null || dstArray.length < flatSize) {\n          dstArray = new Float32Array(flatSize);\n        }\n        for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {\n          plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);\n          plane.normal.toArray(dstArray, i4);\n          dstArray[i4 + 3] = plane.constant;\n        }\n      }\n      uniform.value = dstArray;\n      uniform.needsUpdate = true;\n    }\n    scope.numPlanes = nPlanes;\n    scope.numIntersection = 0;\n    return dstArray;\n  }\n}\nexport { WebGLClipping };","map":{"version":3,"names":["Matrix3","Plane","WebGLClipping","properties","scope","globalState","numGlobalPlanes","localClippingEnabled","renderingShadows","plane","viewNormalMatrix","uniform","value","needsUpdate","numPlanes","numIntersection","init","planes","enableLocalClipping","camera","enabled","length","projectPlanes","beginShadows","endShadows","resetGlobalState","setState","material","useCache","clippingPlanes","clipIntersection","clipShadows","materialProperties","get","nGlobal","lGlobal","dstArray","clippingState","i","dstOffset","skipTransform","nPlanes","flatSize","viewMatrix","matrixWorldInverse","getNormalMatrix","Float32Array","i4","copy","applyMatrix4","normal","toArray","constant"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/renderers/webgl/WebGLClipping.js"],"sourcesContent":["import { Matrix3 } from '../../math/Matrix3.js';\nimport { Plane } from '../../math/Plane.js';\n\nfunction WebGLClipping( properties ) {\n\n\tconst scope = this;\n\n\tlet globalState = null,\n\t\tnumGlobalPlanes = 0,\n\t\tlocalClippingEnabled = false,\n\t\trenderingShadows = false;\n\n\tconst plane = new Plane(),\n\t\tviewNormalMatrix = new Matrix3(),\n\n\t\tuniform = { value: null, needsUpdate: false };\n\n\tthis.uniform = uniform;\n\tthis.numPlanes = 0;\n\tthis.numIntersection = 0;\n\n\tthis.init = function ( planes, enableLocalClipping, camera ) {\n\n\t\tconst enabled =\n\t\t\tplanes.length !== 0 ||\n\t\t\tenableLocalClipping ||\n\t\t\t// enable state of previous frame - the clipping code has to\n\t\t\t// run another frame in order to reset the state:\n\t\t\tnumGlobalPlanes !== 0 ||\n\t\t\tlocalClippingEnabled;\n\n\t\tlocalClippingEnabled = enableLocalClipping;\n\n\t\tglobalState = projectPlanes( planes, camera, 0 );\n\t\tnumGlobalPlanes = planes.length;\n\n\t\treturn enabled;\n\n\t};\n\n\tthis.beginShadows = function () {\n\n\t\trenderingShadows = true;\n\t\tprojectPlanes( null );\n\n\t};\n\n\tthis.endShadows = function () {\n\n\t\trenderingShadows = false;\n\t\tresetGlobalState();\n\n\t};\n\n\tthis.setState = function ( material, camera, useCache ) {\n\n\t\tconst planes = material.clippingPlanes,\n\t\t\tclipIntersection = material.clipIntersection,\n\t\t\tclipShadows = material.clipShadows;\n\n\t\tconst materialProperties = properties.get( material );\n\n\t\tif ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {\n\n\t\t\t// there's no local clipping\n\n\t\t\tif ( renderingShadows ) {\n\n\t\t\t\t// there's no global clipping\n\n\t\t\t\tprojectPlanes( null );\n\n\t\t\t} else {\n\n\t\t\t\tresetGlobalState();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n\t\t\t\tlGlobal = nGlobal * 4;\n\n\t\t\tlet dstArray = materialProperties.clippingState || null;\n\n\t\t\tuniform.value = dstArray; // ensure unique state\n\n\t\t\tdstArray = projectPlanes( planes, camera, lGlobal, useCache );\n\n\t\t\tfor ( let i = 0; i !== lGlobal; ++ i ) {\n\n\t\t\t\tdstArray[ i ] = globalState[ i ];\n\n\t\t\t}\n\n\t\t\tmaterialProperties.clippingState = dstArray;\n\t\t\tthis.numIntersection = clipIntersection ? this.numPlanes : 0;\n\t\t\tthis.numPlanes += nGlobal;\n\n\t\t}\n\n\n\t};\n\n\tfunction resetGlobalState() {\n\n\t\tif ( uniform.value !== globalState ) {\n\n\t\t\tuniform.value = globalState;\n\t\t\tuniform.needsUpdate = numGlobalPlanes > 0;\n\n\t\t}\n\n\t\tscope.numPlanes = numGlobalPlanes;\n\t\tscope.numIntersection = 0;\n\n\t}\n\n\tfunction projectPlanes( planes, camera, dstOffset, skipTransform ) {\n\n\t\tconst nPlanes = planes !== null ? planes.length : 0;\n\t\tlet dstArray = null;\n\n\t\tif ( nPlanes !== 0 ) {\n\n\t\t\tdstArray = uniform.value;\n\n\t\t\tif ( skipTransform !== true || dstArray === null ) {\n\n\t\t\t\tconst flatSize = dstOffset + nPlanes * 4,\n\t\t\t\t\tviewMatrix = camera.matrixWorldInverse;\n\n\t\t\t\tviewNormalMatrix.getNormalMatrix( viewMatrix );\n\n\t\t\t\tif ( dstArray === null || dstArray.length < flatSize ) {\n\n\t\t\t\t\tdstArray = new Float32Array( flatSize );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {\n\n\t\t\t\t\tplane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );\n\n\t\t\t\t\tplane.normal.toArray( dstArray, i4 );\n\t\t\t\t\tdstArray[ i4 + 3 ] = plane.constant;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tuniform.value = dstArray;\n\t\t\tuniform.needsUpdate = true;\n\n\t\t}\n\n\t\tscope.numPlanes = nPlanes;\n\t\tscope.numIntersection = 0;\n\n\t\treturn dstArray;\n\n\t}\n\n}\n\n\nexport { WebGLClipping };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}