{"ast":null,"code":"import { PropertyBinding } from './PropertyBinding.js';\nimport * as MathUtils from '../math/MathUtils.js';\n\n/**\n *\n * A group of objects that receives a shared animation state.\n *\n * Usage:\n *\n *  - Add objects you would otherwise pass as 'root' to the\n *    constructor or the .clipAction method of AnimationMixer.\n *\n *  - Instead pass this object as 'root'.\n *\n *  - You can also add and remove objects later when the mixer\n *    is running.\n *\n * Note:\n *\n *    Objects of this class appear as one object to the mixer,\n *    so cache control of the individual objects must be done\n *    on the group.\n *\n * Limitation:\n *\n *  - The animated properties must be compatible among the\n *    all objects in the group.\n *\n *  - A single property can either be controlled through a\n *    target group or directly, but not both.\n */\n\nclass AnimationObjectGroup {\n  constructor() {\n    this.isAnimationObjectGroup = true;\n    this.uuid = MathUtils.generateUUID();\n\n    // cached objects followed by the active ones\n    this._objects = Array.prototype.slice.call(arguments);\n    this.nCachedObjects_ = 0; // threshold\n    // note: read by PropertyBinding.Composite\n\n    const indices = {};\n    this._indicesByUUID = indices; // for bookkeeping\n\n    for (let i = 0, n = arguments.length; i !== n; ++i) {\n      indices[arguments[i].uuid] = i;\n    }\n    this._paths = []; // inside: string\n    this._parsedPaths = []; // inside: { we don't care, here }\n    this._bindings = []; // inside: Array< PropertyBinding >\n    this._bindingsIndicesByPath = {}; // inside: indices in these arrays\n\n    const scope = this;\n    this.stats = {\n      objects: {\n        get total() {\n          return scope._objects.length;\n        },\n        get inUse() {\n          return this.total - scope.nCachedObjects_;\n        }\n      },\n      get bindingsPerObject() {\n        return scope._bindings.length;\n      }\n    };\n  }\n  add() {\n    const objects = this._objects,\n      indicesByUUID = this._indicesByUUID,\n      paths = this._paths,\n      parsedPaths = this._parsedPaths,\n      bindings = this._bindings,\n      nBindings = bindings.length;\n    let knownObject = undefined,\n      nObjects = objects.length,\n      nCachedObjects = this.nCachedObjects_;\n    for (let i = 0, n = arguments.length; i !== n; ++i) {\n      const object = arguments[i],\n        uuid = object.uuid;\n      let index = indicesByUUID[uuid];\n      if (index === undefined) {\n        // unknown object -> add it to the ACTIVE region\n\n        index = nObjects++;\n        indicesByUUID[uuid] = index;\n        objects.push(object);\n\n        // accounting is done, now do the same for all bindings\n\n        for (let j = 0, m = nBindings; j !== m; ++j) {\n          bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));\n        }\n      } else if (index < nCachedObjects) {\n        knownObject = objects[index];\n\n        // move existing object to the ACTIVE region\n\n        const firstActiveIndex = --nCachedObjects,\n          lastCachedObject = objects[firstActiveIndex];\n        indicesByUUID[lastCachedObject.uuid] = index;\n        objects[index] = lastCachedObject;\n        indicesByUUID[uuid] = firstActiveIndex;\n        objects[firstActiveIndex] = object;\n\n        // accounting is done, now do the same for all bindings\n\n        for (let j = 0, m = nBindings; j !== m; ++j) {\n          const bindingsForPath = bindings[j],\n            lastCached = bindingsForPath[firstActiveIndex];\n          let binding = bindingsForPath[index];\n          bindingsForPath[index] = lastCached;\n          if (binding === undefined) {\n            // since we do not bother to create new bindings\n            // for objects that are cached, the binding may\n            // or may not exist\n\n            binding = new PropertyBinding(object, paths[j], parsedPaths[j]);\n          }\n          bindingsForPath[firstActiveIndex] = binding;\n        }\n      } else if (objects[index] !== knownObject) {\n        console.error('THREE.AnimationObjectGroup: Different objects with the same UUID ' + 'detected. Clean the caches or recreate your infrastructure when reloading scenes.');\n      } // else the object is already where we want it to be\n    } // for arguments\n\n    this.nCachedObjects_ = nCachedObjects;\n  }\n  remove() {\n    const objects = this._objects,\n      indicesByUUID = this._indicesByUUID,\n      bindings = this._bindings,\n      nBindings = bindings.length;\n    let nCachedObjects = this.nCachedObjects_;\n    for (let i = 0, n = arguments.length; i !== n; ++i) {\n      const object = arguments[i],\n        uuid = object.uuid,\n        index = indicesByUUID[uuid];\n      if (index !== undefined && index >= nCachedObjects) {\n        // move existing object into the CACHED region\n\n        const lastCachedIndex = nCachedObjects++,\n          firstActiveObject = objects[lastCachedIndex];\n        indicesByUUID[firstActiveObject.uuid] = index;\n        objects[index] = firstActiveObject;\n        indicesByUUID[uuid] = lastCachedIndex;\n        objects[lastCachedIndex] = object;\n\n        // accounting is done, now do the same for all bindings\n\n        for (let j = 0, m = nBindings; j !== m; ++j) {\n          const bindingsForPath = bindings[j],\n            firstActive = bindingsForPath[lastCachedIndex],\n            binding = bindingsForPath[index];\n          bindingsForPath[index] = firstActive;\n          bindingsForPath[lastCachedIndex] = binding;\n        }\n      }\n    } // for arguments\n\n    this.nCachedObjects_ = nCachedObjects;\n  }\n\n  // remove & forget\n  uncache() {\n    const objects = this._objects,\n      indicesByUUID = this._indicesByUUID,\n      bindings = this._bindings,\n      nBindings = bindings.length;\n    let nCachedObjects = this.nCachedObjects_,\n      nObjects = objects.length;\n    for (let i = 0, n = arguments.length; i !== n; ++i) {\n      const object = arguments[i],\n        uuid = object.uuid,\n        index = indicesByUUID[uuid];\n      if (index !== undefined) {\n        delete indicesByUUID[uuid];\n        if (index < nCachedObjects) {\n          // object is cached, shrink the CACHED region\n\n          const firstActiveIndex = --nCachedObjects,\n            lastCachedObject = objects[firstActiveIndex],\n            lastIndex = --nObjects,\n            lastObject = objects[lastIndex];\n\n          // last cached object takes this object's place\n          indicesByUUID[lastCachedObject.uuid] = index;\n          objects[index] = lastCachedObject;\n\n          // last object goes to the activated slot and pop\n          indicesByUUID[lastObject.uuid] = firstActiveIndex;\n          objects[firstActiveIndex] = lastObject;\n          objects.pop();\n\n          // accounting is done, now do the same for all bindings\n\n          for (let j = 0, m = nBindings; j !== m; ++j) {\n            const bindingsForPath = bindings[j],\n              lastCached = bindingsForPath[firstActiveIndex],\n              last = bindingsForPath[lastIndex];\n            bindingsForPath[index] = lastCached;\n            bindingsForPath[firstActiveIndex] = last;\n            bindingsForPath.pop();\n          }\n        } else {\n          // object is active, just swap with the last and pop\n\n          const lastIndex = --nObjects,\n            lastObject = objects[lastIndex];\n          if (lastIndex > 0) {\n            indicesByUUID[lastObject.uuid] = index;\n          }\n          objects[index] = lastObject;\n          objects.pop();\n\n          // accounting is done, now do the same for all bindings\n\n          for (let j = 0, m = nBindings; j !== m; ++j) {\n            const bindingsForPath = bindings[j];\n            bindingsForPath[index] = bindingsForPath[lastIndex];\n            bindingsForPath.pop();\n          }\n        } // cached or active\n      } // if object is known\n    } // for arguments\n\n    this.nCachedObjects_ = nCachedObjects;\n  }\n\n  // Internal interface used by befriended PropertyBinding.Composite:\n\n  subscribe_(path, parsedPath) {\n    // returns an array of bindings for the given path that is changed\n    // according to the contained objects in the group\n\n    const indicesByPath = this._bindingsIndicesByPath;\n    let index = indicesByPath[path];\n    const bindings = this._bindings;\n    if (index !== undefined) return bindings[index];\n    const paths = this._paths,\n      parsedPaths = this._parsedPaths,\n      objects = this._objects,\n      nObjects = objects.length,\n      nCachedObjects = this.nCachedObjects_,\n      bindingsForPath = new Array(nObjects);\n    index = bindings.length;\n    indicesByPath[path] = index;\n    paths.push(path);\n    parsedPaths.push(parsedPath);\n    bindings.push(bindingsForPath);\n    for (let i = nCachedObjects, n = objects.length; i !== n; ++i) {\n      const object = objects[i];\n      bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);\n    }\n    return bindingsForPath;\n  }\n  unsubscribe_(path) {\n    // tells the group to forget about a property path and no longer\n    // update the array previously obtained with 'subscribe_'\n\n    const indicesByPath = this._bindingsIndicesByPath,\n      index = indicesByPath[path];\n    if (index !== undefined) {\n      const paths = this._paths,\n        parsedPaths = this._parsedPaths,\n        bindings = this._bindings,\n        lastBindingsIndex = bindings.length - 1,\n        lastBindings = bindings[lastBindingsIndex],\n        lastBindingsPath = path[lastBindingsIndex];\n      indicesByPath[lastBindingsPath] = index;\n      bindings[index] = lastBindings;\n      bindings.pop();\n      parsedPaths[index] = parsedPaths[lastBindingsIndex];\n      parsedPaths.pop();\n      paths[index] = paths[lastBindingsIndex];\n      paths.pop();\n    }\n  }\n}\nexport { AnimationObjectGroup };","map":{"version":3,"names":["PropertyBinding","MathUtils","AnimationObjectGroup","constructor","isAnimationObjectGroup","uuid","generateUUID","_objects","Array","prototype","slice","call","arguments","nCachedObjects_","indices","_indicesByUUID","i","n","length","_paths","_parsedPaths","_bindings","_bindingsIndicesByPath","scope","stats","objects","total","inUse","bindingsPerObject","add","indicesByUUID","paths","parsedPaths","bindings","nBindings","knownObject","undefined","nObjects","nCachedObjects","object","index","push","j","m","firstActiveIndex","lastCachedObject","bindingsForPath","lastCached","binding","console","error","remove","lastCachedIndex","firstActiveObject","firstActive","uncache","lastIndex","lastObject","pop","last","subscribe_","path","parsedPath","indicesByPath","unsubscribe_","lastBindingsIndex","lastBindings","lastBindingsPath"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/animation/AnimationObjectGroup.js"],"sourcesContent":["import { PropertyBinding } from './PropertyBinding.js';\nimport * as MathUtils from '../math/MathUtils.js';\n\n/**\n *\n * A group of objects that receives a shared animation state.\n *\n * Usage:\n *\n *  - Add objects you would otherwise pass as 'root' to the\n *    constructor or the .clipAction method of AnimationMixer.\n *\n *  - Instead pass this object as 'root'.\n *\n *  - You can also add and remove objects later when the mixer\n *    is running.\n *\n * Note:\n *\n *    Objects of this class appear as one object to the mixer,\n *    so cache control of the individual objects must be done\n *    on the group.\n *\n * Limitation:\n *\n *  - The animated properties must be compatible among the\n *    all objects in the group.\n *\n *  - A single property can either be controlled through a\n *    target group or directly, but not both.\n */\n\nclass AnimationObjectGroup {\n\n\tconstructor() {\n\n\t\tthis.isAnimationObjectGroup = true;\n\n\t\tthis.uuid = MathUtils.generateUUID();\n\n\t\t// cached objects followed by the active ones\n\t\tthis._objects = Array.prototype.slice.call( arguments );\n\n\t\tthis.nCachedObjects_ = 0; // threshold\n\t\t// note: read by PropertyBinding.Composite\n\n\t\tconst indices = {};\n\t\tthis._indicesByUUID = indices; // for bookkeeping\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tindices[ arguments[ i ].uuid ] = i;\n\n\t\t}\n\n\t\tthis._paths = []; // inside: string\n\t\tthis._parsedPaths = []; // inside: { we don't care, here }\n\t\tthis._bindings = []; // inside: Array< PropertyBinding >\n\t\tthis._bindingsIndicesByPath = {}; // inside: indices in these arrays\n\n\t\tconst scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tobjects: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._objects.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn this.total - scope.nCachedObjects_;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tget bindingsPerObject() {\n\n\t\t\t\treturn scope._bindings.length;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tadd() {\n\n\t\tconst objects = this._objects,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tpaths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tlet knownObject = undefined,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_;\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tconst object = arguments[ i ],\n\t\t\t\tuuid = object.uuid;\n\t\t\tlet index = indicesByUUID[ uuid ];\n\n\t\t\tif ( index === undefined ) {\n\n\t\t\t\t// unknown object -> add it to the ACTIVE region\n\n\t\t\t\tindex = nObjects ++;\n\t\t\t\tindicesByUUID[ uuid ] = index;\n\t\t\t\tobjects.push( object );\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tbindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );\n\n\t\t\t\t}\n\n\t\t\t} else if ( index < nCachedObjects ) {\n\n\t\t\t\tknownObject = objects[ index ];\n\n\t\t\t\t// move existing object to the ACTIVE region\n\n\t\t\t\tconst firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\n\n\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\n\t\t\t\tobjects[ firstActiveIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tconst bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ];\n\n\t\t\t\t\tlet binding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\n\t\t\t\t\tif ( binding === undefined ) {\n\n\t\t\t\t\t\t// since we do not bother to create new bindings\n\t\t\t\t\t\t// for objects that are cached, the binding may\n\t\t\t\t\t\t// or may not exist\n\n\t\t\t\t\t\tbinding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t} else if ( objects[ index ] !== knownObject ) {\n\n\t\t\t\tconsole.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +\n\t\t\t\t\t'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );\n\n\t\t\t} // else the object is already where we want it to be\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t}\n\n\tremove() {\n\n\t\tconst objects = this._objects,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tlet nCachedObjects = this.nCachedObjects_;\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tconst object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\n\n\t\t\t\t// move existing object into the CACHED region\n\n\t\t\t\tconst lastCachedIndex = nCachedObjects ++,\n\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\n\n\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = firstActiveObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\n\t\t\t\tobjects[ lastCachedIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tconst bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\n\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = firstActive;\n\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t}\n\n\t// remove & forget\n\tuncache() {\n\n\t\tconst objects = this._objects,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tlet nCachedObjects = this.nCachedObjects_,\n\t\t\tnObjects = objects.length;\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tconst object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tdelete indicesByUUID[ uuid ];\n\n\t\t\t\tif ( index < nCachedObjects ) {\n\n\t\t\t\t\t// object is cached, shrink the CACHED region\n\n\t\t\t\t\tconst firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\n\t\t\t\t\t\tlastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\t// last cached object takes this object's place\n\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\t\t// last object goes to the activated slot and pop\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\n\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tconst bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// object is active, just swap with the last and pop\n\n\t\t\t\t\tconst lastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\tif ( lastIndex > 0 ) {\n\n\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobjects[ index ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tconst bindingsForPath = bindings[ j ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} // cached or active\n\n\t\t\t} // if object is known\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t}\n\n\t// Internal interface used by befriended PropertyBinding.Composite:\n\n\tsubscribe_( path, parsedPath ) {\n\n\t\t// returns an array of bindings for the given path that is changed\n\t\t// according to the contained objects in the group\n\n\t\tconst indicesByPath = this._bindingsIndicesByPath;\n\t\tlet index = indicesByPath[ path ];\n\t\tconst bindings = this._bindings;\n\n\t\tif ( index !== undefined ) return bindings[ index ];\n\n\t\tconst paths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tobjects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tbindingsForPath = new Array( nObjects );\n\n\t\tindex = bindings.length;\n\n\t\tindicesByPath[ path ] = index;\n\n\t\tpaths.push( path );\n\t\tparsedPaths.push( parsedPath );\n\t\tbindings.push( bindingsForPath );\n\n\t\tfor ( let i = nCachedObjects, n = objects.length; i !== n; ++ i ) {\n\n\t\t\tconst object = objects[ i ];\n\t\t\tbindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );\n\n\t\t}\n\n\t\treturn bindingsForPath;\n\n\t}\n\n\tunsubscribe_( path ) {\n\n\t\t// tells the group to forget about a property path and no longer\n\t\t// update the array previously obtained with 'subscribe_'\n\n\t\tconst indicesByPath = this._bindingsIndicesByPath,\n\t\t\tindex = indicesByPath[ path ];\n\n\t\tif ( index !== undefined ) {\n\n\t\t\tconst paths = this._paths,\n\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tlastBindingsIndex = bindings.length - 1,\n\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\n\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\n\n\t\t\tindicesByPath[ lastBindingsPath ] = index;\n\n\t\t\tbindings[ index ] = lastBindings;\n\t\t\tbindings.pop();\n\n\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\n\t\t\tparsedPaths.pop();\n\n\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\n\t\t\tpaths.pop();\n\n\t\t}\n\n\t}\n\n}\n\nexport { AnimationObjectGroup };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}