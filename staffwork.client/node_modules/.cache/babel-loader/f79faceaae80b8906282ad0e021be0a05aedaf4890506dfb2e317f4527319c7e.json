{"ast":null,"code":"import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nclass PlaneGeometry extends BufferGeometry {\n  constructor() {\n    let width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    let height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    let widthSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    let heightSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    super();\n    this.type = 'PlaneGeometry';\n    this.parameters = {\n      width: width,\n      height: height,\n      widthSegments: widthSegments,\n      heightSegments: heightSegments\n    };\n    const width_half = width / 2;\n    const height_half = height / 2;\n    const gridX = Math.floor(widthSegments);\n    const gridY = Math.floor(heightSegments);\n    const gridX1 = gridX + 1;\n    const gridY1 = gridY + 1;\n    const segment_width = width / gridX;\n    const segment_height = height / gridY;\n\n    //\n\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n    for (let iy = 0; iy < gridY1; iy++) {\n      const y = iy * segment_height - height_half;\n      for (let ix = 0; ix < gridX1; ix++) {\n        const x = ix * segment_width - width_half;\n        vertices.push(x, -y, 0);\n        normals.push(0, 0, 1);\n        uvs.push(ix / gridX);\n        uvs.push(1 - iy / gridY);\n      }\n    }\n    for (let iy = 0; iy < gridY; iy++) {\n      for (let ix = 0; ix < gridX; ix++) {\n        const a = ix + gridX1 * iy;\n        const b = ix + gridX1 * (iy + 1);\n        const c = ix + 1 + gridX1 * (iy + 1);\n        const d = ix + 1 + gridX1 * iy;\n        indices.push(a, b, d);\n        indices.push(b, c, d);\n      }\n    }\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n  }\n  static fromJSON(data) {\n    return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);\n  }\n}\nexport { PlaneGeometry };","map":{"version":3,"names":["BufferGeometry","Float32BufferAttribute","PlaneGeometry","constructor","width","height","widthSegments","heightSegments","type","parameters","width_half","height_half","gridX","Math","floor","gridY","gridX1","gridY1","segment_width","segment_height","indices","vertices","normals","uvs","iy","y","ix","x","push","a","b","c","d","setIndex","setAttribute","fromJSON","data"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/geometries/PlaneGeometry.js"],"sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\n\nclass PlaneGeometry extends BufferGeometry {\n\n\tconstructor( width = 1, height = 1, widthSegments = 1, heightSegments = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'PlaneGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments\n\t\t};\n\n\t\tconst width_half = width / 2;\n\t\tconst height_half = height / 2;\n\n\t\tconst gridX = Math.floor( widthSegments );\n\t\tconst gridY = Math.floor( heightSegments );\n\n\t\tconst gridX1 = gridX + 1;\n\t\tconst gridY1 = gridY + 1;\n\n\t\tconst segment_width = width / gridX;\n\t\tconst segment_height = height / gridY;\n\n\t\t//\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\tfor ( let iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\tconst y = iy * segment_height - height_half;\n\n\t\t\tfor ( let ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\tconst x = ix * segment_width - width_half;\n\n\t\t\t\tvertices.push( x, - y, 0 );\n\n\t\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\t\tuvs.push( ix / gridX );\n\t\t\t\tuvs.push( 1 - ( iy / gridY ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\tfor ( let ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\tconst a = ix + gridX1 * iy;\n\t\t\t\tconst b = ix + gridX1 * ( iy + 1 );\n\t\t\t\tconst c = ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\tconst d = ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new PlaneGeometry( data.width, data.height, data.widthSegments, data.heightSegments );\n\n\t}\n\n}\n\nexport { PlaneGeometry };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}