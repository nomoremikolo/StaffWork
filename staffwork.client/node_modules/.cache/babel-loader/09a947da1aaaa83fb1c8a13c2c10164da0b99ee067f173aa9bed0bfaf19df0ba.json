{"ast":null,"code":"import { Color } from '../../math/Color.js';\nimport { Path } from './Path.js';\nimport { Shape } from './Shape.js';\nimport { ShapeUtils } from '../ShapeUtils.js';\nclass ShapePath {\n  constructor() {\n    this.type = 'ShapePath';\n    this.color = new Color();\n    this.subPaths = [];\n    this.currentPath = null;\n  }\n  moveTo(x, y) {\n    this.currentPath = new Path();\n    this.subPaths.push(this.currentPath);\n    this.currentPath.moveTo(x, y);\n    return this;\n  }\n  lineTo(x, y) {\n    this.currentPath.lineTo(x, y);\n    return this;\n  }\n  quadraticCurveTo(aCPx, aCPy, aX, aY) {\n    this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);\n    return this;\n  }\n  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {\n    this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);\n    return this;\n  }\n  splineThru(pts) {\n    this.currentPath.splineThru(pts);\n    return this;\n  }\n  toShapes(isCCW) {\n    function toShapesNoHoles(inSubpaths) {\n      const shapes = [];\n      for (let i = 0, l = inSubpaths.length; i < l; i++) {\n        const tmpPath = inSubpaths[i];\n        const tmpShape = new Shape();\n        tmpShape.curves = tmpPath.curves;\n        shapes.push(tmpShape);\n      }\n      return shapes;\n    }\n    function isPointInsidePolygon(inPt, inPolygon) {\n      const polyLen = inPolygon.length;\n\n      // inPt on polygon contour => immediate success    or\n      // toggling of inside/outside at every single! intersection point of an edge\n      //  with the horizontal line through inPt, left of inPt\n      //  not counting lowerY endpoints of edges and whole edges on that line\n      let inside = false;\n      for (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {\n        let edgeLowPt = inPolygon[p];\n        let edgeHighPt = inPolygon[q];\n        let edgeDx = edgeHighPt.x - edgeLowPt.x;\n        let edgeDy = edgeHighPt.y - edgeLowPt.y;\n        if (Math.abs(edgeDy) > Number.EPSILON) {\n          // not parallel\n          if (edgeDy < 0) {\n            edgeLowPt = inPolygon[q];\n            edgeDx = -edgeDx;\n            edgeHighPt = inPolygon[p];\n            edgeDy = -edgeDy;\n          }\n          if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;\n          if (inPt.y === edgeLowPt.y) {\n            if (inPt.x === edgeLowPt.x) return true; // inPt is on contour ?\n            // continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n          } else {\n            const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);\n            if (perpEdge === 0) return true; // inPt is on contour ?\n            if (perpEdge < 0) continue;\n            inside = !inside; // true intersection left of inPt\n          }\n        } else {\n          // parallel or collinear\n          if (inPt.y !== edgeLowPt.y) continue; // parallel\n          // edge lies on the same horizontal line as inPt\n          if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true; // inPt: Point on contour !\n          // continue;\n        }\n      }\n\n      return inside;\n    }\n    const isClockWise = ShapeUtils.isClockWise;\n    const subPaths = this.subPaths;\n    if (subPaths.length === 0) return [];\n    let solid, tmpPath, tmpShape;\n    const shapes = [];\n    if (subPaths.length === 1) {\n      tmpPath = subPaths[0];\n      tmpShape = new Shape();\n      tmpShape.curves = tmpPath.curves;\n      shapes.push(tmpShape);\n      return shapes;\n    }\n    let holesFirst = !isClockWise(subPaths[0].getPoints());\n    holesFirst = isCCW ? !holesFirst : holesFirst;\n\n    // console.log(\"Holes first\", holesFirst);\n\n    const betterShapeHoles = [];\n    const newShapes = [];\n    let newShapeHoles = [];\n    let mainIdx = 0;\n    let tmpPoints;\n    newShapes[mainIdx] = undefined;\n    newShapeHoles[mainIdx] = [];\n    for (let i = 0, l = subPaths.length; i < l; i++) {\n      tmpPath = subPaths[i];\n      tmpPoints = tmpPath.getPoints();\n      solid = isClockWise(tmpPoints);\n      solid = isCCW ? !solid : solid;\n      if (solid) {\n        if (!holesFirst && newShapes[mainIdx]) mainIdx++;\n        newShapes[mainIdx] = {\n          s: new Shape(),\n          p: tmpPoints\n        };\n        newShapes[mainIdx].s.curves = tmpPath.curves;\n        if (holesFirst) mainIdx++;\n        newShapeHoles[mainIdx] = [];\n\n        //console.log('cw', i);\n      } else {\n        newShapeHoles[mainIdx].push({\n          h: tmpPath,\n          p: tmpPoints[0]\n        });\n\n        //console.log('ccw', i);\n      }\n    }\n\n    // only Holes? -> probably all Shapes with wrong orientation\n    if (!newShapes[0]) return toShapesNoHoles(subPaths);\n    if (newShapes.length > 1) {\n      let ambiguous = false;\n      let toChange = 0;\n      for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {\n        betterShapeHoles[sIdx] = [];\n      }\n      for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {\n        const sho = newShapeHoles[sIdx];\n        for (let hIdx = 0; hIdx < sho.length; hIdx++) {\n          const ho = sho[hIdx];\n          let hole_unassigned = true;\n          for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {\n            if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {\n              if (sIdx !== s2Idx) toChange++;\n              if (hole_unassigned) {\n                hole_unassigned = false;\n                betterShapeHoles[s2Idx].push(ho);\n              } else {\n                ambiguous = true;\n              }\n            }\n          }\n          if (hole_unassigned) {\n            betterShapeHoles[sIdx].push(ho);\n          }\n        }\n      }\n      if (toChange > 0 && ambiguous === false) {\n        newShapeHoles = betterShapeHoles;\n      }\n    }\n    let tmpHoles;\n    for (let i = 0, il = newShapes.length; i < il; i++) {\n      tmpShape = newShapes[i].s;\n      shapes.push(tmpShape);\n      tmpHoles = newShapeHoles[i];\n      for (let j = 0, jl = tmpHoles.length; j < jl; j++) {\n        tmpShape.holes.push(tmpHoles[j].h);\n      }\n    }\n\n    //console.log(\"shape\", shapes);\n\n    return shapes;\n  }\n}\nexport { ShapePath };","map":{"version":3,"names":["Color","Path","Shape","ShapeUtils","ShapePath","constructor","type","color","subPaths","currentPath","moveTo","x","y","push","lineTo","quadraticCurveTo","aCPx","aCPy","aX","aY","bezierCurveTo","aCP1x","aCP1y","aCP2x","aCP2y","splineThru","pts","toShapes","isCCW","toShapesNoHoles","inSubpaths","shapes","i","l","length","tmpPath","tmpShape","curves","isPointInsidePolygon","inPt","inPolygon","polyLen","inside","p","q","edgeLowPt","edgeHighPt","edgeDx","edgeDy","Math","abs","Number","EPSILON","perpEdge","isClockWise","solid","holesFirst","getPoints","betterShapeHoles","newShapes","newShapeHoles","mainIdx","tmpPoints","undefined","s","h","ambiguous","toChange","sIdx","sLen","sho","hIdx","ho","hole_unassigned","s2Idx","tmpHoles","il","j","jl","holes"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/extras/core/ShapePath.js"],"sourcesContent":["import { Color } from '../../math/Color.js';\nimport { Path } from './Path.js';\nimport { Shape } from './Shape.js';\nimport { ShapeUtils } from '../ShapeUtils.js';\n\nclass ShapePath {\n\n\tconstructor() {\n\n\t\tthis.type = 'ShapePath';\n\n\t\tthis.color = new Color();\n\n\t\tthis.subPaths = [];\n\t\tthis.currentPath = null;\n\n\t}\n\n\tmoveTo( x, y ) {\n\n\t\tthis.currentPath = new Path();\n\t\tthis.subPaths.push( this.currentPath );\n\t\tthis.currentPath.moveTo( x, y );\n\n\t\treturn this;\n\n\t}\n\n\tlineTo( x, y ) {\n\n\t\tthis.currentPath.lineTo( x, y );\n\n\t\treturn this;\n\n\t}\n\n\tquadraticCurveTo( aCPx, aCPy, aX, aY ) {\n\n\t\tthis.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\tbezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\tthis.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\tsplineThru( pts ) {\n\n\t\tthis.currentPath.splineThru( pts );\n\n\t\treturn this;\n\n\t}\n\n\ttoShapes( isCCW ) {\n\n\t\tfunction toShapesNoHoles( inSubpaths ) {\n\n\t\t\tconst shapes = [];\n\n\t\t\tfor ( let i = 0, l = inSubpaths.length; i < l; i ++ ) {\n\n\t\t\t\tconst tmpPath = inSubpaths[ i ];\n\n\t\t\t\tconst tmpShape = new Shape();\n\t\t\t\ttmpShape.curves = tmpPath.curves;\n\n\t\t\t\tshapes.push( tmpShape );\n\n\t\t\t}\n\n\t\t\treturn shapes;\n\n\t\t}\n\n\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\n\n\t\t\tconst polyLen = inPolygon.length;\n\n\t\t\t// inPt on polygon contour => immediate success    or\n\t\t\t// toggling of inside/outside at every single! intersection point of an edge\n\t\t\t//  with the horizontal line through inPt, left of inPt\n\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\n\t\t\tlet inside = false;\n\t\t\tfor ( let p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\n\n\t\t\t\tlet edgeLowPt = inPolygon[ p ];\n\t\t\t\tlet edgeHighPt = inPolygon[ q ];\n\n\t\t\t\tlet edgeDx = edgeHighPt.x - edgeLowPt.x;\n\t\t\t\tlet edgeDy = edgeHighPt.y - edgeLowPt.y;\n\n\t\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\n\n\t\t\t\t\t// not parallel\n\t\t\t\t\tif ( edgeDy < 0 ) {\n\n\t\t\t\t\t\tedgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;\n\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\n\n\t\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\n\n\t\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\n\t\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\n\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// parallel or collinear\n\t\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\n\t\t\t\t\t// edge lies on the same horizontal line as inPt\n\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\n\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\n\t\t\t\t\t// continue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn\tinside;\n\n\t\t}\n\n\t\tconst isClockWise = ShapeUtils.isClockWise;\n\n\t\tconst subPaths = this.subPaths;\n\t\tif ( subPaths.length === 0 ) return [];\n\n\t\tlet solid, tmpPath, tmpShape;\n\t\tconst shapes = [];\n\n\t\tif ( subPaths.length === 1 ) {\n\n\t\t\ttmpPath = subPaths[ 0 ];\n\t\t\ttmpShape = new Shape();\n\t\t\ttmpShape.curves = tmpPath.curves;\n\t\t\tshapes.push( tmpShape );\n\t\t\treturn shapes;\n\n\t\t}\n\n\t\tlet holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\n\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\n\n\t\t// console.log(\"Holes first\", holesFirst);\n\n\t\tconst betterShapeHoles = [];\n\t\tconst newShapes = [];\n\t\tlet newShapeHoles = [];\n\t\tlet mainIdx = 0;\n\t\tlet tmpPoints;\n\n\t\tnewShapes[ mainIdx ] = undefined;\n\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\tfor ( let i = 0, l = subPaths.length; i < l; i ++ ) {\n\n\t\t\ttmpPath = subPaths[ i ];\n\t\t\ttmpPoints = tmpPath.getPoints();\n\t\t\tsolid = isClockWise( tmpPoints );\n\t\t\tsolid = isCCW ? ! solid : solid;\n\n\t\t\tif ( solid ) {\n\n\t\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\tmainIdx ++;\n\n\t\t\t\tnewShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };\n\t\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\n\n\t\t\t\tif ( holesFirst )\tmainIdx ++;\n\t\t\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\t\t\t//console.log('cw', i);\n\n\t\t\t} else {\n\n\t\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\n\n\t\t\t\t//console.log('ccw', i);\n\n\t\t\t}\n\n\t\t}\n\n\t\t// only Holes? -> probably all Shapes with wrong orientation\n\t\tif ( ! newShapes[ 0 ] )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\tif ( newShapes.length > 1 ) {\n\n\t\t\tlet ambiguous = false;\n\t\t\tlet toChange = 0;\n\n\t\t\tfor ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\tbetterShapeHoles[ sIdx ] = [];\n\n\t\t\t}\n\n\t\t\tfor ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\tconst sho = newShapeHoles[ sIdx ];\n\n\t\t\t\tfor ( let hIdx = 0; hIdx < sho.length; hIdx ++ ) {\n\n\t\t\t\t\tconst ho = sho[ hIdx ];\n\t\t\t\t\tlet hole_unassigned = true;\n\n\t\t\t\t\tfor ( let s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\n\n\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\n\n\t\t\t\t\t\t\tif ( sIdx !== s2Idx )\ttoChange ++;\n\n\t\t\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\t\t\thole_unassigned = false;\n\t\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tambiguous = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( toChange > 0 && ambiguous === false ) {\n\n\t\t\t\tnewShapeHoles = betterShapeHoles;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet tmpHoles;\n\n\t\tfor ( let i = 0, il = newShapes.length; i < il; i ++ ) {\n\n\t\t\ttmpShape = newShapes[ i ].s;\n\t\t\tshapes.push( tmpShape );\n\t\t\ttmpHoles = newShapeHoles[ i ];\n\n\t\t\tfor ( let j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\n\n\t\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//console.log(\"shape\", shapes);\n\n\t\treturn shapes;\n\n\t}\n\n}\n\n\nexport { ShapePath };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}