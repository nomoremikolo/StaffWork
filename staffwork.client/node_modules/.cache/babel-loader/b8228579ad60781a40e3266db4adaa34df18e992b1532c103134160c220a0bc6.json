{"ast":null,"code":"import NodeUniform from './NodeUniform.js';\nimport NodeAttribute from './NodeAttribute.js';\nimport NodeVarying from './NodeVarying.js';\nimport NodeVar from './NodeVar.js';\nimport NodeCode from './NodeCode.js';\nimport NodeKeywords from './NodeKeywords.js';\nimport { NodeUpdateType } from './constants.js';\nimport { REVISION, LinearEncoding, Color, Vector2, Vector3, Vector4 } from 'three';\nexport const defaultShaderStages = ['fragment', 'vertex'];\nexport const shaderStages = [...defaultShaderStages, 'compute'];\nexport const vector = ['x', 'y', 'z', 'w'];\nconst typeFromLength = new Map();\ntypeFromLength.set(2, 'vec2');\ntypeFromLength.set(3, 'vec3');\ntypeFromLength.set(4, 'vec4');\ntypeFromLength.set(9, 'mat3');\ntypeFromLength.set(16, 'mat4');\nconst toFloat = value => {\n  value = Number(value);\n  return value + (value % 1 ? '' : '.0');\n};\nclass NodeBuilder {\n  constructor(object, renderer, parser) {\n    this.object = object;\n    this.material = object.material || null;\n    this.geometry = object.geometry || null;\n    this.renderer = renderer;\n    this.parser = parser;\n    this.nodes = [];\n    this.updateNodes = [];\n    this.hashNodes = {};\n    this.scene = null;\n    this.lightsNode = null;\n    this.fogNode = null;\n    this.vertexShader = null;\n    this.fragmentShader = null;\n    this.computeShader = null;\n    this.flowNodes = {\n      vertex: [],\n      fragment: [],\n      compute: []\n    };\n    this.flowCode = {\n      vertex: '',\n      fragment: '',\n      compute: []\n    };\n    this.uniforms = {\n      vertex: [],\n      fragment: [],\n      compute: [],\n      index: 0\n    };\n    this.codes = {\n      vertex: [],\n      fragment: [],\n      compute: []\n    };\n    this.attributes = [];\n    this.varyings = [];\n    this.vars = {\n      vertex: [],\n      fragment: [],\n      compute: []\n    };\n    this.flow = {\n      code: ''\n    };\n    this.stack = [];\n    this.context = {\n      keywords: new NodeKeywords(),\n      material: object.material\n    };\n    this.nodesData = new WeakMap();\n    this.flowsData = new WeakMap();\n    this.shaderStage = null;\n    this.buildStage = null;\n  }\n  get node() {\n    return this.stack[this.stack.length - 1];\n  }\n  addStack(node) {\n    /*\n    if ( this.stack.indexOf( node ) !== - 1 ) {\n    \t\tconsole.warn( 'Recursive node: ', node );\n    \t}\n    */\n\n    this.stack.push(node);\n  }\n  removeStack(node) {\n    const lastStack = this.stack.pop();\n    if (lastStack !== node) {\n      throw new Error('NodeBuilder: Invalid node stack!');\n    }\n  }\n  setHashNode(node, hash) {\n    this.hashNodes[hash] = node;\n  }\n  addNode(node) {\n    if (this.nodes.indexOf(node) === -1) {\n      const updateType = node.getUpdateType(this);\n      if (updateType !== NodeUpdateType.NONE) {\n        this.updateNodes.push(node);\n      }\n      this.nodes.push(node);\n      this.setHashNode(node, node.getHash(this));\n    }\n  }\n  getMethod(method) {\n    return method;\n  }\n  getNodeFromHash(hash) {\n    return this.hashNodes[hash];\n  }\n  addFlow(shaderStage, node) {\n    this.flowNodes[shaderStage].push(node);\n    return node;\n  }\n  setContext(context) {\n    this.context = context;\n  }\n  getContext() {\n    return this.context;\n  }\n  isAvailable( /*name*/\n  ) {\n    return false;\n  }\n  getInstanceIndex() {\n    console.warn('Abstract function.');\n  }\n  getFrontFacing() {\n    console.warn('Abstract function.');\n  }\n  getFragCoord() {\n    console.warn('Abstract function.');\n  }\n  isFlipY() {\n    return false;\n  }\n  getTexture( /* textureProperty, uvSnippet */\n  ) {\n    console.warn('Abstract function.');\n  }\n  getTextureLevel( /* textureProperty, uvSnippet, levelSnippet */\n  ) {\n    console.warn('Abstract function.');\n  }\n  getCubeTexture( /* textureProperty, uvSnippet */\n  ) {\n    console.warn('Abstract function.');\n  }\n  getCubeTextureLevel( /* textureProperty, uvSnippet, levelSnippet */\n  ) {\n    console.warn('Abstract function.');\n  }\n\n  // @TODO: rename to .generateConst()\n  getConst(type) {\n    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (value === null) {\n      if (type === 'float' || type === 'int' || type === 'uint') value = 0;else if (type === 'bool') value = false;else if (type === 'color') value = new Color();else if (type === 'vec2') value = new Vector2();else if (type === 'vec3') value = new Vector3();else if (type === 'vec4') value = new Vector4();\n    }\n    if (type === 'float') return toFloat(value);\n    if (type === 'int') return `${Math.round(value)}`;\n    if (type === 'uint') return value >= 0 ? `${Math.round(value)}u` : '0u';\n    if (type === 'bool') return value ? 'true' : 'false';\n    if (type === 'color') return `${this.getType('vec3')}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;\n    const typeLength = this.getTypeLength(type);\n    const componentType = this.getComponentType(type);\n    const getConst = value => this.getConst(componentType, value);\n    if (typeLength === 2) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)} )`;\n    } else if (typeLength === 3) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)} )`;\n    } else if (typeLength === 4) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)}, ${getConst(value.w)} )`;\n    } else if (typeLength > 4) {\n      return `${this.getType(type)}()`;\n    }\n    throw new Error(`NodeBuilder: Type '${type}' not found in generate constant attempt.`);\n  }\n  getType(type) {\n    return type;\n  }\n  generateMethod(method) {\n    return method;\n  }\n  hasGeometryAttribute(name) {\n    return this.geometry?.getAttribute(name) !== undefined;\n  }\n  getAttribute(name, type) {\n    const attributes = this.attributes;\n\n    // find attribute\n\n    for (const attribute of attributes) {\n      if (attribute.name === name) {\n        return attribute;\n      }\n    }\n\n    // create a new if no exist\n\n    const attribute = new NodeAttribute(name, type);\n    attributes.push(attribute);\n    return attribute;\n  }\n  getPropertyName(node /*, shaderStage*/) {\n    return node.name;\n  }\n  isVector(type) {\n    return /vec\\d/.test(type);\n  }\n  isMatrix(type) {\n    return /mat\\d/.test(type);\n  }\n  isReference(type) {\n    return type === 'void' || type === 'property' || type === 'sampler' || type === 'texture' || type === 'cubeTexture';\n  }\n  isShaderStage(shaderStage) {\n    return this.shaderStage === shaderStage;\n  }\n  getTextureEncodingFromMap(map) {\n    let encoding;\n    if (map && map.isTexture) {\n      encoding = map.encoding;\n    } else if (map && map.isWebGLRenderTarget) {\n      encoding = map.texture.encoding;\n    } else {\n      encoding = LinearEncoding;\n    }\n    return encoding;\n  }\n  getComponentType(type) {\n    type = this.getVectorType(type);\n    if (type === 'float' || type === 'bool' || type === 'int' || type === 'uint') return type;\n    const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type);\n    if (componentType === null) return null;\n    if (componentType[1] === 'b') return 'bool';\n    if (componentType[1] === 'i') return 'int';\n    if (componentType[1] === 'u') return 'uint';\n    return 'float';\n  }\n  getVectorType(type) {\n    if (type === 'color') return 'vec3';\n    if (type === 'texture') return 'vec4';\n    return type;\n  }\n  getTypeFromLength(length) {\n    let componentType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'float';\n    if (length === 1) return componentType;\n    const baseType = typeFromLength.get(length);\n    const prefix = componentType === 'float' ? '' : componentType[0];\n    return prefix + baseType;\n  }\n  getTypeLength(type) {\n    const vecType = this.getVectorType(type);\n    const vecNum = /vec([2-4])/.exec(vecType);\n    if (vecNum !== null) return Number(vecNum[1]);\n    if (vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint') return 1;\n    if (/mat3/.test(type) === true) return 9;\n    if (/mat4/.test(type) === true) return 16;\n    return 0;\n  }\n  getVectorFromMatrix(type) {\n    return type.replace('mat', 'vec');\n  }\n  changeComponentType(type, newComponentType) {\n    return this.getTypeFromLength(this.getTypeLength(type), newComponentType);\n  }\n  getIntegerType(type) {\n    const componentType = this.getComponentType(type);\n    if (componentType === 'int' || componentType === 'uint') return type;\n    return this.changeComponentType(type, 'int');\n  }\n  getDataFromNode(node) {\n    let shaderStage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.shaderStage;\n    let nodeData = this.nodesData.get(node);\n    if (nodeData === undefined) {\n      nodeData = {\n        vertex: {},\n        fragment: {},\n        compute: {}\n      };\n      this.nodesData.set(node, nodeData);\n    }\n    return shaderStage !== null ? nodeData[shaderStage] : nodeData;\n  }\n  getNodeProperties(node) {\n    let shaderStage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.shaderStage;\n    const nodeData = this.getDataFromNode(this, shaderStage);\n    const constructHash = node.getConstructHash(this);\n    nodeData.properties = nodeData.properties || {};\n    nodeData.properties[constructHash] = nodeData.properties[constructHash] || {\n      outputNode: null\n    };\n    return nodeData.properties[constructHash];\n  }\n  getUniformFromNode(node, shaderStage, type) {\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    let nodeUniform = nodeData.uniform;\n    if (nodeUniform === undefined) {\n      const index = this.uniforms.index++;\n      nodeUniform = new NodeUniform('nodeUniform' + index, type, node);\n      this.uniforms[shaderStage].push(nodeUniform);\n      nodeData.uniform = nodeUniform;\n    }\n    return nodeUniform;\n  }\n  getVarFromNode(node, type) {\n    let shaderStage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.shaderStage;\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    let nodeVar = nodeData.variable;\n    if (nodeVar === undefined) {\n      const vars = this.vars[shaderStage];\n      const index = vars.length;\n      nodeVar = new NodeVar('nodeVar' + index, type);\n      vars.push(nodeVar);\n      nodeData.variable = nodeVar;\n    }\n    return nodeVar;\n  }\n  getVaryingFromNode(node, type) {\n    const nodeData = this.getDataFromNode(node, null);\n    let nodeVarying = nodeData.varying;\n    if (nodeVarying === undefined) {\n      const varyings = this.varyings;\n      const index = varyings.length;\n      nodeVarying = new NodeVarying('nodeVarying' + index, type);\n      varyings.push(nodeVarying);\n      nodeData.varying = nodeVarying;\n    }\n    return nodeVarying;\n  }\n  getCodeFromNode(node, type) {\n    let shaderStage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.shaderStage;\n    const nodeData = this.getDataFromNode(node);\n    let nodeCode = nodeData.code;\n    if (nodeCode === undefined) {\n      const codes = this.codes[shaderStage];\n      const index = codes.length;\n      nodeCode = new NodeCode('nodeCode' + index, type);\n      codes.push(nodeCode);\n      nodeData.code = nodeCode;\n    }\n    return nodeCode;\n  }\n  addFlowCode(code) {\n    this.flow.code += code;\n  }\n  getFlowData(node /*, shaderStage*/) {\n    return this.flowsData.get(node);\n  }\n  flowNode(node) {\n    const output = node.getNodeType(this);\n    const flowData = this.flowChildNode(node, output);\n    this.flowsData.set(node, flowData);\n    return flowData;\n  }\n  flowChildNode(node) {\n    let output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const previousFlow = this.flow;\n    const flow = {\n      code: ''\n    };\n    this.flow = flow;\n    flow.result = node.build(this, output);\n    this.flow = previousFlow;\n    return flow;\n  }\n  flowNodeFromShaderStage(shaderStage, node) {\n    let output = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let propertyName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    const previousShaderStage = this.shaderStage;\n    this.setShaderStage(shaderStage);\n    const flowData = this.flowChildNode(node, output);\n    if (propertyName !== null) {\n      flowData.code += `${propertyName} = ${flowData.result};\\n\\t`;\n    }\n    this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;\n    this.setShaderStage(previousShaderStage);\n    return flowData;\n  }\n  getAttributes( /*shaderStage*/\n  ) {\n    console.warn('Abstract function.');\n  }\n  getVaryings( /*shaderStage*/\n  ) {\n    console.warn('Abstract function.');\n  }\n  getVars(shaderStage) {\n    let snippet = '';\n    const vars = this.vars[shaderStage];\n    for (const variable of vars) {\n      snippet += `${variable.type} ${variable.name}; `;\n    }\n    return snippet;\n  }\n  getUniforms( /*shaderStage*/\n  ) {\n    console.warn('Abstract function.');\n  }\n  getCodes(shaderStage) {\n    const codes = this.codes[shaderStage];\n    let code = '';\n    for (const nodeCode of codes) {\n      code += nodeCode.code + '\\n';\n    }\n    return code;\n  }\n  getHash() {\n    return this.vertexShader + this.fragmentShader + this.computeShader;\n  }\n  setShaderStage(shaderStage) {\n    this.shaderStage = shaderStage;\n  }\n  getShaderStage() {\n    return this.shaderStage;\n  }\n  setBuildStage(buildStage) {\n    this.buildStage = buildStage;\n  }\n  getBuildStage() {\n    return this.buildStage;\n  }\n  buildCode() {\n    console.warn('Abstract function.');\n  }\n  build() {\n    // stage 1: generate shader node\n\n    this.setBuildStage('construct');\n    for (const shaderStage of shaderStages) {\n      this.setShaderStage(shaderStage);\n      const flowNodes = this.flowNodes[shaderStage];\n      for (const node of flowNodes) {\n        node.build(this);\n      }\n    }\n\n    // stage 2: analyze nodes to possible optimization and validation\n\n    this.setBuildStage('analyze');\n    for (const shaderStage of shaderStages) {\n      this.setShaderStage(shaderStage);\n      const flowNodes = this.flowNodes[shaderStage];\n      for (const node of flowNodes) {\n        node.build(this);\n      }\n    }\n\n    // stage 3: pre-build vertex code used in fragment shader\n\n    this.setBuildStage('generate');\n    if (this.context.vertex && this.context.vertex.isNode) {\n      this.flowNodeFromShaderStage('vertex', this.context.vertex);\n    }\n\n    // stage 4: generate shader\n\n    this.setBuildStage('generate');\n    for (const shaderStage of shaderStages) {\n      this.setShaderStage(shaderStage);\n      const flowNodes = this.flowNodes[shaderStage];\n      for (const node of flowNodes) {\n        this.flowNode(node);\n      }\n    }\n    this.setBuildStage(null);\n    this.setShaderStage(null);\n\n    // stage 5: build code for a specific output\n\n    this.buildCode();\n    return this;\n  }\n  format(snippet, fromType, toType) {\n    fromType = this.getVectorType(fromType);\n    toType = this.getVectorType(toType);\n    if (fromType === toType || toType === null || this.isReference(toType)) {\n      return snippet;\n    }\n    const fromTypeLength = this.getTypeLength(fromType);\n    const toTypeLength = this.getTypeLength(toType);\n    if (fromTypeLength > 4) {\n      // fromType is matrix-like\n\n      // @TODO: ignore for now\n\n      return snippet;\n    }\n    if (toTypeLength > 4 || toTypeLength === 0) {\n      // toType is matrix-like or unknown\n\n      // @TODO: ignore for now\n\n      return snippet;\n    }\n    if (fromTypeLength === toTypeLength) {\n      return `${this.getType(toType)}( ${snippet} )`;\n    }\n    if (fromTypeLength > toTypeLength) {\n      return this.format(`${snippet}.${'xyz'.slice(0, toTypeLength)}`, this.getTypeFromLength(toTypeLength), toType);\n    }\n    if (toTypeLength === 4) {\n      // toType is vec4-like\n\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec3')}, 1.0 )`;\n    }\n    if (fromTypeLength === 2) {\n      // fromType is vec2-like and toType is vec3-like\n\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec2')}, 0.0 )`;\n    }\n    return `${this.getType(toType)}( ${snippet} )`; // fromType is float-like\n  }\n\n  getSignature() {\n    return `// Three.js r${REVISION} - NodeMaterial System\\n`;\n  }\n}\nexport default NodeBuilder;","map":{"version":3,"names":["NodeUniform","NodeAttribute","NodeVarying","NodeVar","NodeCode","NodeKeywords","NodeUpdateType","REVISION","LinearEncoding","Color","Vector2","Vector3","Vector4","defaultShaderStages","shaderStages","vector","typeFromLength","Map","set","toFloat","value","Number","NodeBuilder","constructor","object","renderer","parser","material","geometry","nodes","updateNodes","hashNodes","scene","lightsNode","fogNode","vertexShader","fragmentShader","computeShader","flowNodes","vertex","fragment","compute","flowCode","uniforms","index","codes","attributes","varyings","vars","flow","code","stack","context","keywords","nodesData","WeakMap","flowsData","shaderStage","buildStage","node","length","addStack","push","removeStack","lastStack","pop","Error","setHashNode","hash","addNode","indexOf","updateType","getUpdateType","NONE","getHash","getMethod","method","getNodeFromHash","addFlow","setContext","getContext","isAvailable","getInstanceIndex","console","warn","getFrontFacing","getFragCoord","isFlipY","getTexture","getTextureLevel","getCubeTexture","getCubeTextureLevel","getConst","type","Math","round","getType","r","g","b","typeLength","getTypeLength","componentType","getComponentType","x","y","z","w","generateMethod","hasGeometryAttribute","name","getAttribute","undefined","attribute","getPropertyName","isVector","test","isMatrix","isReference","isShaderStage","getTextureEncodingFromMap","map","encoding","isTexture","isWebGLRenderTarget","texture","getVectorType","exec","getTypeFromLength","baseType","get","prefix","vecType","vecNum","getVectorFromMatrix","replace","changeComponentType","newComponentType","getIntegerType","getDataFromNode","nodeData","getNodeProperties","constructHash","getConstructHash","properties","outputNode","getUniformFromNode","nodeUniform","uniform","getVarFromNode","nodeVar","variable","getVaryingFromNode","nodeVarying","varying","getCodeFromNode","nodeCode","addFlowCode","getFlowData","flowNode","output","getNodeType","flowData","flowChildNode","previousFlow","result","build","flowNodeFromShaderStage","propertyName","previousShaderStage","setShaderStage","getAttributes","getVaryings","getVars","snippet","getUniforms","getCodes","getShaderStage","setBuildStage","getBuildStage","buildCode","isNode","format","fromType","toType","fromTypeLength","toTypeLength","slice","getSignature"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/examples/jsm/nodes/core/NodeBuilder.js"],"sourcesContent":["import NodeUniform from './NodeUniform.js';\nimport NodeAttribute from './NodeAttribute.js';\nimport NodeVarying from './NodeVarying.js';\nimport NodeVar from './NodeVar.js';\nimport NodeCode from './NodeCode.js';\nimport NodeKeywords from './NodeKeywords.js';\nimport { NodeUpdateType } from './constants.js';\n\nimport { REVISION, LinearEncoding, Color, Vector2, Vector3, Vector4 } from 'three';\n\nexport const defaultShaderStages = [ 'fragment', 'vertex' ];\nexport const shaderStages = [ ...defaultShaderStages, 'compute' ];\nexport const vector = [ 'x', 'y', 'z', 'w' ];\n\nconst typeFromLength = new Map();\ntypeFromLength.set( 2, 'vec2' );\ntypeFromLength.set( 3, 'vec3' );\ntypeFromLength.set( 4, 'vec4' );\ntypeFromLength.set( 9, 'mat3' );\ntypeFromLength.set( 16, 'mat4' );\n\nconst toFloat = ( value ) => {\n\n\tvalue = Number( value );\n\n\treturn value + ( value % 1 ? '' : '.0' );\n\n};\n\nclass NodeBuilder {\n\n\tconstructor( object, renderer, parser ) {\n\n\t\tthis.object = object;\n\t\tthis.material = object.material || null;\n\t\tthis.geometry = object.geometry || null;\n\t\tthis.renderer = renderer;\n\t\tthis.parser = parser;\n\n\t\tthis.nodes = [];\n\t\tthis.updateNodes = [];\n\t\tthis.hashNodes = {};\n\n\t\tthis.scene = null;\n\t\tthis.lightsNode = null;\n\t\tthis.fogNode = null;\n\n\t\tthis.vertexShader = null;\n\t\tthis.fragmentShader = null;\n\t\tthis.computeShader = null;\n\n\t\tthis.flowNodes = { vertex: [], fragment: [], compute: [] };\n\t\tthis.flowCode = { vertex: '', fragment: '', compute: [] };\n\t\tthis.uniforms = { vertex: [], fragment: [], compute: [], index: 0 };\n\t\tthis.codes = { vertex: [], fragment: [], compute: [] };\n\t\tthis.attributes = [];\n\t\tthis.varyings = [];\n\t\tthis.vars = { vertex: [], fragment: [], compute: [] };\n\t\tthis.flow = { code: '' };\n\t\tthis.stack = [];\n\n\t\tthis.context = {\n\t\t\tkeywords: new NodeKeywords(),\n\t\t\tmaterial: object.material\n\t\t};\n\n\t\tthis.nodesData = new WeakMap();\n\t\tthis.flowsData = new WeakMap();\n\n\t\tthis.shaderStage = null;\n\t\tthis.buildStage = null;\n\n\t}\n\n\tget node() {\n\n\t\treturn this.stack[ this.stack.length - 1 ];\n\n\t}\n\n\taddStack( node ) {\n\n\t\t/*\n\t\tif ( this.stack.indexOf( node ) !== - 1 ) {\n\n\t\t\tconsole.warn( 'Recursive node: ', node );\n\n\t\t}\n\t\t*/\n\n\t\tthis.stack.push( node );\n\n\t}\n\n\tremoveStack( node ) {\n\n\t\tconst lastStack = this.stack.pop();\n\n\t\tif ( lastStack !== node ) {\n\n\t\t\tthrow new Error( 'NodeBuilder: Invalid node stack!' );\n\n\t\t}\n\n\t}\n\n\tsetHashNode( node, hash ) {\n\n\t\tthis.hashNodes[ hash ] = node;\n\n\t}\n\n\taddNode( node ) {\n\n\t\tif ( this.nodes.indexOf( node ) === - 1 ) {\n\n\t\t\tconst updateType = node.getUpdateType( this );\n\n\t\t\tif ( updateType !== NodeUpdateType.NONE ) {\n\n\t\t\t\tthis.updateNodes.push( node );\n\n\t\t\t}\n\n\t\t\tthis.nodes.push( node );\n\n\t\t\tthis.setHashNode( node, node.getHash( this ) );\n\n\t\t}\n\n\t}\n\n\tgetMethod( method ) {\n\n\t\treturn method;\n\n\t}\n\n\tgetNodeFromHash( hash ) {\n\n\t\treturn this.hashNodes[ hash ];\n\n\t}\n\n\taddFlow( shaderStage, node ) {\n\n\t\tthis.flowNodes[ shaderStage ].push( node );\n\n\t\treturn node;\n\n\t}\n\n\tsetContext( context ) {\n\n\t\tthis.context = context;\n\n\t}\n\n\tgetContext() {\n\n\t\treturn this.context;\n\n\t}\n\n\tisAvailable( /*name*/ ) {\n\n\t\treturn false;\n\n\t}\n\n\tgetInstanceIndex() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetFrontFacing() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetFragCoord() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tisFlipY() {\n\n\t\treturn false;\n\n\t}\n\n\tgetTexture( /* textureProperty, uvSnippet */ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetTextureLevel( /* textureProperty, uvSnippet, levelSnippet */ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetCubeTexture( /* textureProperty, uvSnippet */ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetCubeTextureLevel( /* textureProperty, uvSnippet, levelSnippet */ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t// @TODO: rename to .generateConst()\n\tgetConst( type, value = null ) {\n\n\t\tif ( value === null ) {\n\n\t\t\tif ( type === 'float' || type === 'int' || type === 'uint' ) value = 0;\n\t\t\telse if ( type === 'bool' ) value = false;\n\t\t\telse if ( type === 'color' ) value = new Color();\n\t\t\telse if ( type === 'vec2' ) value = new Vector2();\n\t\t\telse if ( type === 'vec3' ) value = new Vector3();\n\t\t\telse if ( type === 'vec4' ) value = new Vector4();\n\n\t\t}\n\n\t\tif ( type === 'float' ) return toFloat( value );\n\t\tif ( type === 'int' ) return `${ Math.round( value ) }`;\n\t\tif ( type === 'uint' ) return value >= 0 ? `${ Math.round( value ) }u` : '0u';\n\t\tif ( type === 'bool' ) return value ? 'true' : 'false';\n\t\tif ( type === 'color' ) return `${ this.getType( 'vec3' ) }( ${ toFloat( value.r ) }, ${ toFloat( value.g ) }, ${ toFloat( value.b ) } )`;\n\n\t\tconst typeLength = this.getTypeLength( type );\n\n\t\tconst componentType = this.getComponentType( type );\n\n\t\tconst getConst = value => this.getConst( componentType, value );\n\n\t\tif ( typeLength === 2 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ getConst( value.x ) }, ${ getConst( value.y ) } )`;\n\n\t\t} else if ( typeLength === 3 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ getConst( value.x ) }, ${ getConst( value.y ) }, ${ getConst( value.z ) } )`;\n\n\t\t} else if ( typeLength === 4 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ getConst( value.x ) }, ${ getConst( value.y ) }, ${ getConst( value.z ) }, ${ getConst( value.w ) } )`;\n\n\t\t} else if ( typeLength > 4 ) {\n\n\t\t\treturn `${ this.getType( type ) }()`;\n\n\t\t}\n\n\t\tthrow new Error( `NodeBuilder: Type '${type}' not found in generate constant attempt.` );\n\n\t}\n\n\tgetType( type ) {\n\n\t\treturn type;\n\n\t}\n\n\tgenerateMethod( method ) {\n\n\t\treturn method;\n\n\t}\n\n\thasGeometryAttribute( name ) {\n\n\t\treturn this.geometry?.getAttribute( name ) !== undefined;\n\n\t}\n\n\tgetAttribute( name, type ) {\n\n\t\tconst attributes = this.attributes;\n\n\t\t// find attribute\n\n\t\tfor ( const attribute of attributes ) {\n\n\t\t\tif ( attribute.name === name ) {\n\n\t\t\t\treturn attribute;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// create a new if no exist\n\n\t\tconst attribute = new NodeAttribute( name, type );\n\n\t\tattributes.push( attribute );\n\n\t\treturn attribute;\n\n\t}\n\n\tgetPropertyName( node/*, shaderStage*/ ) {\n\n\t\treturn node.name;\n\n\t}\n\n\tisVector( type ) {\n\n\t\treturn /vec\\d/.test( type );\n\n\t}\n\n\tisMatrix( type ) {\n\n\t\treturn /mat\\d/.test( type );\n\n\t}\n\n\tisReference( type ) {\n\n\t\treturn type === 'void' || type === 'property' || type === 'sampler' || type === 'texture' || type === 'cubeTexture';\n\n\t}\n\n\tisShaderStage( shaderStage ) {\n\n\t\treturn this.shaderStage === shaderStage;\n\n\t}\n\n\tgetTextureEncodingFromMap( map ) {\n\n\t\tlet encoding;\n\n\t\tif ( map && map.isTexture ) {\n\n\t\t\tencoding = map.encoding;\n\n\t\t} else if ( map && map.isWebGLRenderTarget ) {\n\n\t\t\tencoding = map.texture.encoding;\n\n\t\t} else {\n\n\t\t\tencoding = LinearEncoding;\n\n\t\t}\n\n\t\treturn encoding;\n\n\t}\n\n\tgetComponentType( type ) {\n\n\t\ttype = this.getVectorType( type );\n\n\t\tif ( type === 'float' || type === 'bool' || type === 'int' || type === 'uint' ) return type;\n\n\t\tconst componentType = /(b|i|u|)(vec|mat)([2-4])/.exec( type );\n\n\t\tif ( componentType === null ) return null;\n\n\t\tif ( componentType[ 1 ] === 'b' ) return 'bool';\n\t\tif ( componentType[ 1 ] === 'i' ) return 'int';\n\t\tif ( componentType[ 1 ] === 'u' ) return 'uint';\n\n\t\treturn 'float';\n\n\t}\n\n\tgetVectorType( type ) {\n\n\t\tif ( type === 'color' ) return 'vec3';\n\t\tif ( type === 'texture' ) return 'vec4';\n\n\t\treturn type;\n\n\t}\n\n\tgetTypeFromLength( length, componentType = 'float' ) {\n\n\t\tif ( length === 1 ) return componentType;\n\t\tconst baseType = typeFromLength.get( length );\n\t\tconst prefix = componentType === 'float' ? '' : componentType[ 0 ];\n\t\treturn prefix + baseType;\n\n\t}\n\n\tgetTypeLength( type ) {\n\n\t\tconst vecType = this.getVectorType( type );\n\t\tconst vecNum = /vec([2-4])/.exec( vecType );\n\n\t\tif ( vecNum !== null ) return Number( vecNum[ 1 ] );\n\t\tif ( vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint' ) return 1;\n\t\tif ( /mat3/.test( type ) === true ) return 9;\n\t\tif ( /mat4/.test( type ) === true ) return 16;\n\n\t\treturn 0;\n\n\t}\n\n\tgetVectorFromMatrix( type ) {\n\n\t\treturn type.replace( 'mat', 'vec' );\n\n\t}\n\n\tchangeComponentType( type, newComponentType ) {\n\n\t\treturn this.getTypeFromLength( this.getTypeLength( type ), newComponentType );\n\n\t}\n\n\tgetIntegerType( type ) {\n\n\t\tconst componentType = this.getComponentType( type );\n\n\t\tif ( componentType === 'int' || componentType === 'uint' ) return type;\n\n\t\treturn this.changeComponentType( type, 'int' );\n\n\t}\n\n\tgetDataFromNode( node, shaderStage = this.shaderStage ) {\n\n\t\tlet nodeData = this.nodesData.get( node );\n\n\t\tif ( nodeData === undefined ) {\n\n\t\t\tnodeData = { vertex: {}, fragment: {}, compute: {} };\n\n\t\t\tthis.nodesData.set( node, nodeData );\n\n\t\t}\n\n\t\treturn shaderStage !== null ? nodeData[ shaderStage ] : nodeData;\n\n\t}\n\n\tgetNodeProperties( node, shaderStage = this.shaderStage ) {\n\n\t\tconst nodeData = this.getDataFromNode( this, shaderStage );\n\t\tconst constructHash = node.getConstructHash( this );\n\n\t\tnodeData.properties = nodeData.properties || {};\n\t\tnodeData.properties[ constructHash ] = nodeData.properties[ constructHash ] || { outputNode: null };\n\n\t\treturn nodeData.properties[ constructHash ];\n\n\t}\n\n\tgetUniformFromNode( node, shaderStage, type ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\tlet nodeUniform = nodeData.uniform;\n\n\t\tif ( nodeUniform === undefined ) {\n\n\t\t\tconst index = this.uniforms.index ++;\n\n\t\t\tnodeUniform = new NodeUniform( 'nodeUniform' + index, type, node );\n\n\t\t\tthis.uniforms[ shaderStage ].push( nodeUniform );\n\n\t\t\tnodeData.uniform = nodeUniform;\n\n\t\t}\n\n\t\treturn nodeUniform;\n\n\t}\n\n\tgetVarFromNode( node, type, shaderStage = this.shaderStage ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\tlet nodeVar = nodeData.variable;\n\n\t\tif ( nodeVar === undefined ) {\n\n\t\t\tconst vars = this.vars[ shaderStage ];\n\t\t\tconst index = vars.length;\n\n\t\t\tnodeVar = new NodeVar( 'nodeVar' + index, type );\n\n\t\t\tvars.push( nodeVar );\n\n\t\t\tnodeData.variable = nodeVar;\n\n\t\t}\n\n\t\treturn nodeVar;\n\n\t}\n\n\tgetVaryingFromNode( node, type ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, null );\n\n\t\tlet nodeVarying = nodeData.varying;\n\n\t\tif ( nodeVarying === undefined ) {\n\n\t\t\tconst varyings = this.varyings;\n\t\t\tconst index = varyings.length;\n\n\t\t\tnodeVarying = new NodeVarying( 'nodeVarying' + index, type );\n\n\t\t\tvaryings.push( nodeVarying );\n\n\t\t\tnodeData.varying = nodeVarying;\n\n\t\t}\n\n\t\treturn nodeVarying;\n\n\t}\n\n\tgetCodeFromNode( node, type, shaderStage = this.shaderStage ) {\n\n\t\tconst nodeData = this.getDataFromNode( node );\n\n\t\tlet nodeCode = nodeData.code;\n\n\t\tif ( nodeCode === undefined ) {\n\n\t\t\tconst codes = this.codes[ shaderStage ];\n\t\t\tconst index = codes.length;\n\n\t\t\tnodeCode = new NodeCode( 'nodeCode' + index, type );\n\n\t\t\tcodes.push( nodeCode );\n\n\t\t\tnodeData.code = nodeCode;\n\n\t\t}\n\n\t\treturn nodeCode;\n\n\t}\n\n\taddFlowCode( code ) {\n\n\t\tthis.flow.code += code;\n\n\t}\n\n\tgetFlowData( node/*, shaderStage*/ ) {\n\n\t\treturn this.flowsData.get( node );\n\n\t}\n\n\tflowNode( node ) {\n\n\t\tconst output = node.getNodeType( this );\n\n\t\tconst flowData = this.flowChildNode( node, output );\n\n\t\tthis.flowsData.set( node, flowData );\n\n\t\treturn flowData;\n\n\t}\n\n\tflowChildNode( node, output = null ) {\n\n\t\tconst previousFlow = this.flow;\n\n\t\tconst flow = {\n\t\t\tcode: '',\n\t\t};\n\n\t\tthis.flow = flow;\n\n\t\tflow.result = node.build( this, output );\n\n\t\tthis.flow = previousFlow;\n\n\t\treturn flow;\n\n\t}\n\n\tflowNodeFromShaderStage( shaderStage, node, output = null, propertyName = null ) {\n\n\t\tconst previousShaderStage = this.shaderStage;\n\n\t\tthis.setShaderStage( shaderStage );\n\n\t\tconst flowData = this.flowChildNode( node, output );\n\n\t\tif ( propertyName !== null ) {\n\n\t\t\tflowData.code += `${propertyName} = ${flowData.result};\\n\\t`;\n\n\t\t}\n\n\t\tthis.flowCode[ shaderStage ] = this.flowCode[ shaderStage ] + flowData.code;\n\n\t\tthis.setShaderStage( previousShaderStage );\n\n\t\treturn flowData;\n\n\t}\n\n\tgetAttributes( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetVaryings( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetVars( shaderStage ) {\n\n\t\tlet snippet = '';\n\n\t\tconst vars = this.vars[ shaderStage ];\n\n\t\tfor ( const variable of vars ) {\n\n\t\t\tsnippet += `${variable.type} ${variable.name}; `;\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tgetUniforms( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetCodes( shaderStage ) {\n\n\t\tconst codes = this.codes[ shaderStage ];\n\n\t\tlet code = '';\n\n\t\tfor ( const nodeCode of codes ) {\n\n\t\t\tcode += nodeCode.code + '\\n';\n\n\t\t}\n\n\t\treturn code;\n\n\t}\n\n\tgetHash() {\n\n\t\treturn this.vertexShader + this.fragmentShader + this.computeShader;\n\n\t}\n\n\tsetShaderStage( shaderStage ) {\n\n\t\tthis.shaderStage = shaderStage;\n\n\t}\n\n\tgetShaderStage() {\n\n\t\treturn this.shaderStage;\n\n\t}\n\n\tsetBuildStage( buildStage ) {\n\n\t\tthis.buildStage = buildStage;\n\n\t}\n\n\tgetBuildStage() {\n\n\t\treturn this.buildStage;\n\n\t}\n\n\tbuildCode() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tbuild() {\n\n\t\t// stage 1: generate shader node\n\n\t\tthis.setBuildStage( 'construct' );\n\n\t\tfor ( const shaderStage of shaderStages ) {\n\n\t\t\tthis.setShaderStage( shaderStage );\n\n\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\n\n\t\t\tfor ( const node of flowNodes ) {\n\n\t\t\t\tnode.build( this );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// stage 2: analyze nodes to possible optimization and validation\n\n\t\tthis.setBuildStage( 'analyze' );\n\n\t\tfor ( const shaderStage of shaderStages ) {\n\n\t\t\tthis.setShaderStage( shaderStage );\n\n\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\n\n\t\t\tfor ( const node of flowNodes ) {\n\n\t\t\t\tnode.build( this );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// stage 3: pre-build vertex code used in fragment shader\n\n\t\tthis.setBuildStage( 'generate' );\n\n\t\tif ( this.context.vertex && this.context.vertex.isNode ) {\n\n\t\t\tthis.flowNodeFromShaderStage( 'vertex', this.context.vertex );\n\n\t\t}\n\n\t\t// stage 4: generate shader\n\n\t\tthis.setBuildStage( 'generate' );\n\n\t\tfor ( const shaderStage of shaderStages ) {\n\n\t\t\tthis.setShaderStage( shaderStage );\n\n\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\n\n\t\t\tfor ( const node of flowNodes ) {\n\n\t\t\t\tthis.flowNode( node );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setBuildStage( null );\n\t\tthis.setShaderStage( null );\n\n\t\t// stage 5: build code for a specific output\n\n\t\tthis.buildCode();\n\n\t\treturn this;\n\n\t}\n\n\tformat( snippet, fromType, toType ) {\n\n\t\tfromType = this.getVectorType( fromType );\n\t\ttoType = this.getVectorType( toType );\n\n\t\tif ( fromType === toType || toType === null || this.isReference( toType ) ) {\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tconst fromTypeLength = this.getTypeLength( fromType );\n\t\tconst toTypeLength = this.getTypeLength( toType );\n\n\t\tif ( fromTypeLength > 4 ) { // fromType is matrix-like\n\n\t\t\t// @TODO: ignore for now\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tif ( toTypeLength > 4 || toTypeLength === 0 ) { // toType is matrix-like or unknown\n\n\t\t\t// @TODO: ignore for now\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tif ( fromTypeLength === toTypeLength ) {\n\n\t\t\treturn `${ this.getType( toType ) }( ${ snippet } )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength > toTypeLength ) {\n\n\t\t\treturn this.format( `${ snippet }.${ 'xyz'.slice( 0, toTypeLength ) }`, this.getTypeFromLength( toTypeLength ), toType );\n\n\t\t}\n\n\t\tif ( toTypeLength === 4 ) { // toType is vec4-like\n\n\t\t\treturn `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec3' ) }, 1.0 )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength === 2 ) { // fromType is vec2-like and toType is vec3-like\n\n\t\t\treturn `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec2' ) }, 0.0 )`;\n\n\t\t}\n\n\t\treturn `${ this.getType( toType ) }( ${ snippet } )`; // fromType is float-like\n\n\t}\n\n\tgetSignature() {\n\n\t\treturn `// Three.js r${ REVISION } - NodeMaterial System\\n`;\n\n\t}\n\n}\n\nexport default NodeBuilder;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}