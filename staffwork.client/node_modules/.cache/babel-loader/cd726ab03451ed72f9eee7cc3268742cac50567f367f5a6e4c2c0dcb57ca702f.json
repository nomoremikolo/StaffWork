{"ast":null,"code":"import * as AnimationUtils from './AnimationUtils.js';\nimport { KeyframeTrack } from './KeyframeTrack.js';\nimport { BooleanKeyframeTrack } from './tracks/BooleanKeyframeTrack.js';\nimport { ColorKeyframeTrack } from './tracks/ColorKeyframeTrack.js';\nimport { NumberKeyframeTrack } from './tracks/NumberKeyframeTrack.js';\nimport { QuaternionKeyframeTrack } from './tracks/QuaternionKeyframeTrack.js';\nimport { StringKeyframeTrack } from './tracks/StringKeyframeTrack.js';\nimport { VectorKeyframeTrack } from './tracks/VectorKeyframeTrack.js';\nimport * as MathUtils from '../math/MathUtils.js';\nimport { NormalAnimationBlendMode } from '../constants.js';\nclass AnimationClip {\n  constructor(name) {\n    let duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n    let tracks = arguments.length > 2 ? arguments[2] : undefined;\n    let blendMode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : NormalAnimationBlendMode;\n    this.name = name;\n    this.tracks = tracks;\n    this.duration = duration;\n    this.blendMode = blendMode;\n    this.uuid = MathUtils.generateUUID();\n\n    // this means it should figure out its duration by scanning the tracks\n    if (this.duration < 0) {\n      this.resetDuration();\n    }\n  }\n  static parse(json) {\n    const tracks = [],\n      jsonTracks = json.tracks,\n      frameTime = 1.0 / (json.fps || 1.0);\n    for (let i = 0, n = jsonTracks.length; i !== n; ++i) {\n      tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));\n    }\n    const clip = new this(json.name, json.duration, tracks, json.blendMode);\n    clip.uuid = json.uuid;\n    return clip;\n  }\n  static toJSON(clip) {\n    const tracks = [],\n      clipTracks = clip.tracks;\n    const json = {\n      'name': clip.name,\n      'duration': clip.duration,\n      'tracks': tracks,\n      'uuid': clip.uuid,\n      'blendMode': clip.blendMode\n    };\n    for (let i = 0, n = clipTracks.length; i !== n; ++i) {\n      tracks.push(KeyframeTrack.toJSON(clipTracks[i]));\n    }\n    return json;\n  }\n  static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {\n    const numMorphTargets = morphTargetSequence.length;\n    const tracks = [];\n    for (let i = 0; i < numMorphTargets; i++) {\n      let times = [];\n      let values = [];\n      times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);\n      values.push(0, 1, 0);\n      const order = AnimationUtils.getKeyframeOrder(times);\n      times = AnimationUtils.sortedArray(times, 1, order);\n      values = AnimationUtils.sortedArray(values, 1, order);\n\n      // if there is a key at the first frame, duplicate it as the\n      // last frame as well for perfect loop.\n      if (!noLoop && times[0] === 0) {\n        times.push(numMorphTargets);\n        values.push(values[0]);\n      }\n      tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1.0 / fps));\n    }\n    return new this(name, -1, tracks);\n  }\n  static findByName(objectOrClipArray, name) {\n    let clipArray = objectOrClipArray;\n    if (!Array.isArray(objectOrClipArray)) {\n      const o = objectOrClipArray;\n      clipArray = o.geometry && o.geometry.animations || o.animations;\n    }\n    for (let i = 0; i < clipArray.length; i++) {\n      if (clipArray[i].name === name) {\n        return clipArray[i];\n      }\n    }\n    return null;\n  }\n  static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {\n    const animationToMorphTargets = {};\n\n    // tested with https://regex101.com/ on trick sequences\n    // such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n    const pattern = /^([\\w-]*?)([\\d]+)$/;\n\n    // sort morph target names into animation groups based\n    // patterns like Walk_001, Walk_002, Run_001, Run_002\n    for (let i = 0, il = morphTargets.length; i < il; i++) {\n      const morphTarget = morphTargets[i];\n      const parts = morphTarget.name.match(pattern);\n      if (parts && parts.length > 1) {\n        const name = parts[1];\n        let animationMorphTargets = animationToMorphTargets[name];\n        if (!animationMorphTargets) {\n          animationToMorphTargets[name] = animationMorphTargets = [];\n        }\n        animationMorphTargets.push(morphTarget);\n      }\n    }\n    const clips = [];\n    for (const name in animationToMorphTargets) {\n      clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));\n    }\n    return clips;\n  }\n\n  // parse the animation.hierarchy format\n  static parseAnimation(animation, bones) {\n    if (!animation) {\n      console.error('THREE.AnimationClip: No animation in JSONLoader data.');\n      return null;\n    }\n    const addNonemptyTrack = function (trackType, trackName, animationKeys, propertyName, destTracks) {\n      // only return track if there are actually keys.\n      if (animationKeys.length !== 0) {\n        const times = [];\n        const values = [];\n        AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);\n\n        // empty keys are filtered out, so check again\n        if (times.length !== 0) {\n          destTracks.push(new trackType(trackName, times, values));\n        }\n      }\n    };\n    const tracks = [];\n    const clipName = animation.name || 'default';\n    const fps = animation.fps || 30;\n    const blendMode = animation.blendMode;\n\n    // automatic length determination in AnimationClip.\n    let duration = animation.length || -1;\n    const hierarchyTracks = animation.hierarchy || [];\n    for (let h = 0; h < hierarchyTracks.length; h++) {\n      const animationKeys = hierarchyTracks[h].keys;\n\n      // skip empty tracks\n      if (!animationKeys || animationKeys.length === 0) continue;\n\n      // process morph targets\n      if (animationKeys[0].morphTargets) {\n        // figure out all morph targets used in this track\n        const morphTargetNames = {};\n        let k;\n        for (k = 0; k < animationKeys.length; k++) {\n          if (animationKeys[k].morphTargets) {\n            for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {\n              morphTargetNames[animationKeys[k].morphTargets[m]] = -1;\n            }\n          }\n        }\n\n        // create a track for each morph target with all zero\n        // morphTargetInfluences except for the keys in which\n        // the morphTarget is named.\n        for (const morphTargetName in morphTargetNames) {\n          const times = [];\n          const values = [];\n          for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {\n            const animationKey = animationKeys[k];\n            times.push(animationKey.time);\n            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);\n          }\n          tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));\n        }\n        duration = morphTargetNames.length * fps;\n      } else {\n        // ...assume skeletal animation\n\n        const boneName = '.bones[' + bones[h].name + ']';\n        addNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);\n        addNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);\n        addNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);\n      }\n    }\n    if (tracks.length === 0) {\n      return null;\n    }\n    const clip = new this(clipName, duration, tracks, blendMode);\n    return clip;\n  }\n  resetDuration() {\n    const tracks = this.tracks;\n    let duration = 0;\n    for (let i = 0, n = tracks.length; i !== n; ++i) {\n      const track = this.tracks[i];\n      duration = Math.max(duration, track.times[track.times.length - 1]);\n    }\n    this.duration = duration;\n    return this;\n  }\n  trim() {\n    for (let i = 0; i < this.tracks.length; i++) {\n      this.tracks[i].trim(0, this.duration);\n    }\n    return this;\n  }\n  validate() {\n    let valid = true;\n    for (let i = 0; i < this.tracks.length; i++) {\n      valid = valid && this.tracks[i].validate();\n    }\n    return valid;\n  }\n  optimize() {\n    for (let i = 0; i < this.tracks.length; i++) {\n      this.tracks[i].optimize();\n    }\n    return this;\n  }\n  clone() {\n    const tracks = [];\n    for (let i = 0; i < this.tracks.length; i++) {\n      tracks.push(this.tracks[i].clone());\n    }\n    return new this.constructor(this.name, this.duration, tracks, this.blendMode);\n  }\n  toJSON() {\n    return this.constructor.toJSON(this);\n  }\n}\nfunction getTrackTypeForValueTypeName(typeName) {\n  switch (typeName.toLowerCase()) {\n    case 'scalar':\n    case 'double':\n    case 'float':\n    case 'number':\n    case 'integer':\n      return NumberKeyframeTrack;\n    case 'vector':\n    case 'vector2':\n    case 'vector3':\n    case 'vector4':\n      return VectorKeyframeTrack;\n    case 'color':\n      return ColorKeyframeTrack;\n    case 'quaternion':\n      return QuaternionKeyframeTrack;\n    case 'bool':\n    case 'boolean':\n      return BooleanKeyframeTrack;\n    case 'string':\n      return StringKeyframeTrack;\n  }\n  throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);\n}\nfunction parseKeyframeTrack(json) {\n  if (json.type === undefined) {\n    throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');\n  }\n  const trackType = getTrackTypeForValueTypeName(json.type);\n  if (json.times === undefined) {\n    const times = [],\n      values = [];\n    AnimationUtils.flattenJSON(json.keys, times, values, 'value');\n    json.times = times;\n    json.values = values;\n  }\n\n  // derived classes can define a static parse method\n  if (trackType.parse !== undefined) {\n    return trackType.parse(json);\n  } else {\n    // by default, we assume a constructor compatible with the base\n    return new trackType(json.name, json.times, json.values, json.interpolation);\n  }\n}\nexport { AnimationClip };","map":{"version":3,"names":["AnimationUtils","KeyframeTrack","BooleanKeyframeTrack","ColorKeyframeTrack","NumberKeyframeTrack","QuaternionKeyframeTrack","StringKeyframeTrack","VectorKeyframeTrack","MathUtils","NormalAnimationBlendMode","AnimationClip","constructor","name","duration","tracks","blendMode","uuid","generateUUID","resetDuration","parse","json","jsonTracks","frameTime","fps","i","n","length","push","parseKeyframeTrack","scale","clip","toJSON","clipTracks","CreateFromMorphTargetSequence","morphTargetSequence","noLoop","numMorphTargets","times","values","order","getKeyframeOrder","sortedArray","findByName","objectOrClipArray","clipArray","Array","isArray","o","geometry","animations","CreateClipsFromMorphTargetSequences","morphTargets","animationToMorphTargets","pattern","il","morphTarget","parts","match","animationMorphTargets","clips","parseAnimation","animation","bones","console","error","addNonemptyTrack","trackType","trackName","animationKeys","propertyName","destTracks","flattenJSON","clipName","hierarchyTracks","hierarchy","h","keys","morphTargetNames","k","m","morphTargetName","animationKey","time","boneName","track","Math","max","trim","validate","valid","optimize","clone","getTrackTypeForValueTypeName","typeName","toLowerCase","Error","type","undefined","interpolation"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/animation/AnimationClip.js"],"sourcesContent":["import * as AnimationUtils from './AnimationUtils.js';\nimport { KeyframeTrack } from './KeyframeTrack.js';\nimport { BooleanKeyframeTrack } from './tracks/BooleanKeyframeTrack.js';\nimport { ColorKeyframeTrack } from './tracks/ColorKeyframeTrack.js';\nimport { NumberKeyframeTrack } from './tracks/NumberKeyframeTrack.js';\nimport { QuaternionKeyframeTrack } from './tracks/QuaternionKeyframeTrack.js';\nimport { StringKeyframeTrack } from './tracks/StringKeyframeTrack.js';\nimport { VectorKeyframeTrack } from './tracks/VectorKeyframeTrack.js';\nimport * as MathUtils from '../math/MathUtils.js';\nimport { NormalAnimationBlendMode } from '../constants.js';\n\nclass AnimationClip {\n\n\tconstructor( name, duration = - 1, tracks, blendMode = NormalAnimationBlendMode ) {\n\n\t\tthis.name = name;\n\t\tthis.tracks = tracks;\n\t\tthis.duration = duration;\n\t\tthis.blendMode = blendMode;\n\n\t\tthis.uuid = MathUtils.generateUUID();\n\n\t\t// this means it should figure out its duration by scanning the tracks\n\t\tif ( this.duration < 0 ) {\n\n\t\t\tthis.resetDuration();\n\n\t\t}\n\n\t}\n\n\n\tstatic parse( json ) {\n\n\t\tconst tracks = [],\n\t\t\tjsonTracks = json.tracks,\n\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\n\n\t\tfor ( let i = 0, n = jsonTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );\n\n\t\t}\n\n\t\tconst clip = new this( json.name, json.duration, tracks, json.blendMode );\n\t\tclip.uuid = json.uuid;\n\n\t\treturn clip;\n\n\t}\n\n\tstatic toJSON( clip ) {\n\n\t\tconst tracks = [],\n\t\t\tclipTracks = clip.tracks;\n\n\t\tconst json = {\n\n\t\t\t'name': clip.name,\n\t\t\t'duration': clip.duration,\n\t\t\t'tracks': tracks,\n\t\t\t'uuid': clip.uuid,\n\t\t\t'blendMode': clip.blendMode\n\n\t\t};\n\n\t\tfor ( let i = 0, n = clipTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );\n\n\t\t}\n\n\t\treturn json;\n\n\t}\n\n\tstatic CreateFromMorphTargetSequence( name, morphTargetSequence, fps, noLoop ) {\n\n\t\tconst numMorphTargets = morphTargetSequence.length;\n\t\tconst tracks = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; i ++ ) {\n\n\t\t\tlet times = [];\n\t\t\tlet values = [];\n\n\t\t\ttimes.push(\n\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\n\t\t\t\ti,\n\t\t\t\t( i + 1 ) % numMorphTargets );\n\n\t\t\tvalues.push( 0, 1, 0 );\n\n\t\t\tconst order = AnimationUtils.getKeyframeOrder( times );\n\t\t\ttimes = AnimationUtils.sortedArray( times, 1, order );\n\t\t\tvalues = AnimationUtils.sortedArray( values, 1, order );\n\n\t\t\t// if there is a key at the first frame, duplicate it as the\n\t\t\t// last frame as well for perfect loop.\n\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\n\n\t\t\t\ttimes.push( numMorphTargets );\n\t\t\t\tvalues.push( values[ 0 ] );\n\n\t\t\t}\n\n\t\t\ttracks.push(\n\t\t\t\tnew NumberKeyframeTrack(\n\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\n\t\t\t\t\ttimes, values\n\t\t\t\t).scale( 1.0 / fps ) );\n\n\t\t}\n\n\t\treturn new this( name, - 1, tracks );\n\n\t}\n\n\tstatic findByName( objectOrClipArray, name ) {\n\n\t\tlet clipArray = objectOrClipArray;\n\n\t\tif ( ! Array.isArray( objectOrClipArray ) ) {\n\n\t\t\tconst o = objectOrClipArray;\n\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < clipArray.length; i ++ ) {\n\n\t\t\tif ( clipArray[ i ].name === name ) {\n\n\t\t\t\treturn clipArray[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tstatic CreateClipsFromMorphTargetSequences( morphTargets, fps, noLoop ) {\n\n\t\tconst animationToMorphTargets = {};\n\n\t\t// tested with https://regex101.com/ on trick sequences\n\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\t\tconst pattern = /^([\\w-]*?)([\\d]+)$/;\n\n\t\t// sort morph target names into animation groups based\n\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\n\t\tfor ( let i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n\t\t\tconst morphTarget = morphTargets[ i ];\n\t\t\tconst parts = morphTarget.name.match( pattern );\n\n\t\t\tif ( parts && parts.length > 1 ) {\n\n\t\t\t\tconst name = parts[ 1 ];\n\n\t\t\t\tlet animationMorphTargets = animationToMorphTargets[ name ];\n\n\t\t\t\tif ( ! animationMorphTargets ) {\n\n\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\n\n\t\t\t\t}\n\n\t\t\t\tanimationMorphTargets.push( morphTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst clips = [];\n\n\t\tfor ( const name in animationToMorphTargets ) {\n\n\t\t\tclips.push( this.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\n\n\t\t}\n\n\t\treturn clips;\n\n\t}\n\n\t// parse the animation.hierarchy format\n\tstatic parseAnimation( animation, bones ) {\n\n\t\tif ( ! animation ) {\n\n\t\t\tconsole.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {\n\n\t\t\t// only return track if there are actually keys.\n\t\t\tif ( animationKeys.length !== 0 ) {\n\n\t\t\t\tconst times = [];\n\t\t\t\tconst values = [];\n\n\t\t\t\tAnimationUtils.flattenJSON( animationKeys, times, values, propertyName );\n\n\t\t\t\t// empty keys are filtered out, so check again\n\t\t\t\tif ( times.length !== 0 ) {\n\n\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tconst tracks = [];\n\n\t\tconst clipName = animation.name || 'default';\n\t\tconst fps = animation.fps || 30;\n\t\tconst blendMode = animation.blendMode;\n\n\t\t// automatic length determination in AnimationClip.\n\t\tlet duration = animation.length || - 1;\n\n\t\tconst hierarchyTracks = animation.hierarchy || [];\n\n\t\tfor ( let h = 0; h < hierarchyTracks.length; h ++ ) {\n\n\t\t\tconst animationKeys = hierarchyTracks[ h ].keys;\n\n\t\t\t// skip empty tracks\n\t\t\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\n\n\t\t\t// process morph targets\n\t\t\tif ( animationKeys[ 0 ].morphTargets ) {\n\n\t\t\t\t// figure out all morph targets used in this track\n\t\t\t\tconst morphTargetNames = {};\n\n\t\t\t\tlet k;\n\n\t\t\t\tfor ( k = 0; k < animationKeys.length; k ++ ) {\n\n\t\t\t\t\tif ( animationKeys[ k ].morphTargets ) {\n\n\t\t\t\t\t\tfor ( let m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {\n\n\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// create a track for each morph target with all zero\n\t\t\t\t// morphTargetInfluences except for the keys in which\n\t\t\t\t// the morphTarget is named.\n\t\t\t\tfor ( const morphTargetName in morphTargetNames ) {\n\n\t\t\t\t\tconst times = [];\n\t\t\t\t\tconst values = [];\n\n\t\t\t\t\tfor ( let m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {\n\n\t\t\t\t\t\tconst animationKey = animationKeys[ k ];\n\n\t\t\t\t\t\ttimes.push( animationKey.time );\n\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\n\n\t\t\t\t}\n\n\t\t\t\tduration = morphTargetNames.length * fps;\n\n\t\t\t} else {\n\n\t\t\t\t// ...assume skeletal animation\n\n\t\t\t\tconst boneName = '.bones[' + bones[ h ].name + ']';\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tVectorKeyframeTrack, boneName + '.position',\n\t\t\t\t\tanimationKeys, 'pos', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tQuaternionKeyframeTrack, boneName + '.quaternion',\n\t\t\t\t\tanimationKeys, 'rot', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tVectorKeyframeTrack, boneName + '.scale',\n\t\t\t\t\tanimationKeys, 'scl', tracks );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tracks.length === 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst clip = new this( clipName, duration, tracks, blendMode );\n\n\t\treturn clip;\n\n\t}\n\n\tresetDuration() {\n\n\t\tconst tracks = this.tracks;\n\t\tlet duration = 0;\n\n\t\tfor ( let i = 0, n = tracks.length; i !== n; ++ i ) {\n\n\t\t\tconst track = this.tracks[ i ];\n\n\t\t\tduration = Math.max( duration, track.times[ track.times.length - 1 ] );\n\n\t\t}\n\n\t\tthis.duration = duration;\n\n\t\treturn this;\n\n\t}\n\n\ttrim() {\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].trim( 0, this.duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tvalidate() {\n\n\t\tlet valid = true;\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tvalid = valid && this.tracks[ i ].validate();\n\n\t\t}\n\n\t\treturn valid;\n\n\t}\n\n\toptimize() {\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].optimize();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\tconst tracks = [];\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\ttracks.push( this.tracks[ i ].clone() );\n\n\t\t}\n\n\t\treturn new this.constructor( this.name, this.duration, tracks, this.blendMode );\n\n\t}\n\n\ttoJSON() {\n\n\t\treturn this.constructor.toJSON( this );\n\n\t}\n\n}\n\nfunction getTrackTypeForValueTypeName( typeName ) {\n\n\tswitch ( typeName.toLowerCase() ) {\n\n\t\tcase 'scalar':\n\t\tcase 'double':\n\t\tcase 'float':\n\t\tcase 'number':\n\t\tcase 'integer':\n\n\t\t\treturn NumberKeyframeTrack;\n\n\t\tcase 'vector':\n\t\tcase 'vector2':\n\t\tcase 'vector3':\n\t\tcase 'vector4':\n\n\t\t\treturn VectorKeyframeTrack;\n\n\t\tcase 'color':\n\n\t\t\treturn ColorKeyframeTrack;\n\n\t\tcase 'quaternion':\n\n\t\t\treturn QuaternionKeyframeTrack;\n\n\t\tcase 'bool':\n\t\tcase 'boolean':\n\n\t\t\treturn BooleanKeyframeTrack;\n\n\t\tcase 'string':\n\n\t\t\treturn StringKeyframeTrack;\n\n\t}\n\n\tthrow new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );\n\n}\n\nfunction parseKeyframeTrack( json ) {\n\n\tif ( json.type === undefined ) {\n\n\t\tthrow new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );\n\n\t}\n\n\tconst trackType = getTrackTypeForValueTypeName( json.type );\n\n\tif ( json.times === undefined ) {\n\n\t\tconst times = [], values = [];\n\n\t\tAnimationUtils.flattenJSON( json.keys, times, values, 'value' );\n\n\t\tjson.times = times;\n\t\tjson.values = values;\n\n\t}\n\n\t// derived classes can define a static parse method\n\tif ( trackType.parse !== undefined ) {\n\n\t\treturn trackType.parse( json );\n\n\t} else {\n\n\t\t// by default, we assume a constructor compatible with the base\n\t\treturn new trackType( json.name, json.times, json.values, json.interpolation );\n\n\t}\n\n}\n\nexport { AnimationClip };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}