{"ast":null,"code":"// Characters [].:/ are reserved for track binding syntax.\nconst _RESERVED_CHARS_RE = '\\\\[\\\\]\\\\.:\\\\/';\nconst _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g');\n\n// Attempts to allow node names from any language. ES5's `\\w` regexp matches\n// only latin characters, and the unicode \\p{L} is not yet supported. So\n// instead, we exclude reserved characters and match everything else.\nconst _wordChar = '[^' + _RESERVED_CHARS_RE + ']';\nconst _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\\\.', '') + ']';\n\n// Parent directories, delimited by '/' or ':'. Currently unused, but must\n// be matched to parse the rest of the track name.\nconst _directoryRe = /*@__PURE__*/ /((?:WC+[\\/:])*)/.source.replace('WC', _wordChar);\n\n// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.\nconst _nodeRe = /*@__PURE__*/ /(WCOD+)?/.source.replace('WCOD', _wordCharOrDot);\n\n// Object on target node, and accessor. May not contain reserved\n// characters. Accessor may contain any character except closing bracket.\nconst _objectRe = /*@__PURE__*/ /(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace('WC', _wordChar);\n\n// Property and accessor. May not contain reserved characters. Accessor may\n// contain any non-bracket characters.\nconst _propertyRe = /*@__PURE__*/ /\\.(WC+)(?:\\[(.+)\\])?/.source.replace('WC', _wordChar);\nconst _trackRe = new RegExp('' + '^' + _directoryRe + _nodeRe + _objectRe + _propertyRe + '$');\nconst _supportedObjectNames = ['material', 'materials', 'bones', 'map'];\nclass Composite {\n  constructor(targetGroup, path, optionalParsedPath) {\n    const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);\n    this._targetGroup = targetGroup;\n    this._bindings = targetGroup.subscribe_(path, parsedPath);\n  }\n  getValue(array, offset) {\n    this.bind(); // bind all binding\n\n    const firstValidIndex = this._targetGroup.nCachedObjects_,\n      binding = this._bindings[firstValidIndex];\n\n    // and only call .getValue on the first\n    if (binding !== undefined) binding.getValue(array, offset);\n  }\n  setValue(array, offset) {\n    const bindings = this._bindings;\n    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {\n      bindings[i].setValue(array, offset);\n    }\n  }\n  bind() {\n    const bindings = this._bindings;\n    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {\n      bindings[i].bind();\n    }\n  }\n  unbind() {\n    const bindings = this._bindings;\n    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {\n      bindings[i].unbind();\n    }\n  }\n}\n\n// Note: This class uses a State pattern on a per-method basis:\n// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n// prototype version of these methods with one that represents\n// the bound state. When the property is not found, the methods\n// become no-ops.\nclass PropertyBinding {\n  constructor(rootNode, path, parsedPath) {\n    this.path = path;\n    this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);\n    this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;\n    this.rootNode = rootNode;\n\n    // initial state of these methods that calls 'bind'\n    this.getValue = this._getValue_unbound;\n    this.setValue = this._setValue_unbound;\n  }\n  static create(root, path, parsedPath) {\n    if (!(root && root.isAnimationObjectGroup)) {\n      return new PropertyBinding(root, path, parsedPath);\n    } else {\n      return new PropertyBinding.Composite(root, path, parsedPath);\n    }\n  }\n\n  /**\n   * Replaces spaces with underscores and removes unsupported characters from\n   * node names, to ensure compatibility with parseTrackName().\n   *\n   * @param {string} name Node name to be sanitized.\n   * @return {string}\n   */\n  static sanitizeNodeName(name) {\n    return name.replace(/\\s/g, '_').replace(_reservedRe, '');\n  }\n  static parseTrackName(trackName) {\n    const matches = _trackRe.exec(trackName);\n    if (matches === null) {\n      throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);\n    }\n    const results = {\n      // directoryName: matches[ 1 ], // (tschw) currently unused\n      nodeName: matches[2],\n      objectName: matches[3],\n      objectIndex: matches[4],\n      propertyName: matches[5],\n      // required\n      propertyIndex: matches[6]\n    };\n    const lastDot = results.nodeName && results.nodeName.lastIndexOf('.');\n    if (lastDot !== undefined && lastDot !== -1) {\n      const objectName = results.nodeName.substring(lastDot + 1);\n\n      // Object names must be checked against an allowlist. Otherwise, there\n      // is no way to parse 'foo.bar.baz': 'baz' must be a property, but\n      // 'bar' could be the objectName, or part of a nodeName (which can\n      // include '.' characters).\n      if (_supportedObjectNames.indexOf(objectName) !== -1) {\n        results.nodeName = results.nodeName.substring(0, lastDot);\n        results.objectName = objectName;\n      }\n    }\n    if (results.propertyName === null || results.propertyName.length === 0) {\n      throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);\n    }\n    return results;\n  }\n  static findNode(root, nodeName) {\n    if (nodeName === undefined || nodeName === '' || nodeName === '.' || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {\n      return root;\n    }\n\n    // search into skeleton bones.\n    if (root.skeleton) {\n      const bone = root.skeleton.getBoneByName(nodeName);\n      if (bone !== undefined) {\n        return bone;\n      }\n    }\n\n    // search into node subtree.\n    if (root.children) {\n      const searchNodeSubtree = function (children) {\n        for (let i = 0; i < children.length; i++) {\n          const childNode = children[i];\n          if (childNode.name === nodeName || childNode.uuid === nodeName) {\n            return childNode;\n          }\n          const result = searchNodeSubtree(childNode.children);\n          if (result) return result;\n        }\n        return null;\n      };\n      const subTreeNode = searchNodeSubtree(root.children);\n      if (subTreeNode) {\n        return subTreeNode;\n      }\n    }\n    return null;\n  }\n\n  // these are used to \"bind\" a nonexistent property\n  _getValue_unavailable() {}\n  _setValue_unavailable() {}\n\n  // Getters\n\n  _getValue_direct(buffer, offset) {\n    buffer[offset] = this.targetObject[this.propertyName];\n  }\n  _getValue_array(buffer, offset) {\n    const source = this.resolvedProperty;\n    for (let i = 0, n = source.length; i !== n; ++i) {\n      buffer[offset++] = source[i];\n    }\n  }\n  _getValue_arrayElement(buffer, offset) {\n    buffer[offset] = this.resolvedProperty[this.propertyIndex];\n  }\n  _getValue_toArray(buffer, offset) {\n    this.resolvedProperty.toArray(buffer, offset);\n  }\n\n  // Direct\n\n  _setValue_direct(buffer, offset) {\n    this.targetObject[this.propertyName] = buffer[offset];\n  }\n  _setValue_direct_setNeedsUpdate(buffer, offset) {\n    this.targetObject[this.propertyName] = buffer[offset];\n    this.targetObject.needsUpdate = true;\n  }\n  _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {\n    this.targetObject[this.propertyName] = buffer[offset];\n    this.targetObject.matrixWorldNeedsUpdate = true;\n  }\n\n  // EntireArray\n\n  _setValue_array(buffer, offset) {\n    const dest = this.resolvedProperty;\n    for (let i = 0, n = dest.length; i !== n; ++i) {\n      dest[i] = buffer[offset++];\n    }\n  }\n  _setValue_array_setNeedsUpdate(buffer, offset) {\n    const dest = this.resolvedProperty;\n    for (let i = 0, n = dest.length; i !== n; ++i) {\n      dest[i] = buffer[offset++];\n    }\n    this.targetObject.needsUpdate = true;\n  }\n  _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {\n    const dest = this.resolvedProperty;\n    for (let i = 0, n = dest.length; i !== n; ++i) {\n      dest[i] = buffer[offset++];\n    }\n    this.targetObject.matrixWorldNeedsUpdate = true;\n  }\n\n  // ArrayElement\n\n  _setValue_arrayElement(buffer, offset) {\n    this.resolvedProperty[this.propertyIndex] = buffer[offset];\n  }\n  _setValue_arrayElement_setNeedsUpdate(buffer, offset) {\n    this.resolvedProperty[this.propertyIndex] = buffer[offset];\n    this.targetObject.needsUpdate = true;\n  }\n  _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {\n    this.resolvedProperty[this.propertyIndex] = buffer[offset];\n    this.targetObject.matrixWorldNeedsUpdate = true;\n  }\n\n  // HasToFromArray\n\n  _setValue_fromArray(buffer, offset) {\n    this.resolvedProperty.fromArray(buffer, offset);\n  }\n  _setValue_fromArray_setNeedsUpdate(buffer, offset) {\n    this.resolvedProperty.fromArray(buffer, offset);\n    this.targetObject.needsUpdate = true;\n  }\n  _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {\n    this.resolvedProperty.fromArray(buffer, offset);\n    this.targetObject.matrixWorldNeedsUpdate = true;\n  }\n  _getValue_unbound(targetArray, offset) {\n    this.bind();\n    this.getValue(targetArray, offset);\n  }\n  _setValue_unbound(sourceArray, offset) {\n    this.bind();\n    this.setValue(sourceArray, offset);\n  }\n\n  // create getter / setter pair for a property in the scene graph\n  bind() {\n    let targetObject = this.node;\n    const parsedPath = this.parsedPath;\n    const objectName = parsedPath.objectName;\n    const propertyName = parsedPath.propertyName;\n    let propertyIndex = parsedPath.propertyIndex;\n    if (!targetObject) {\n      targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;\n      this.node = targetObject;\n    }\n\n    // set fail state so we can just 'return' on error\n    this.getValue = this._getValue_unavailable;\n    this.setValue = this._setValue_unavailable;\n\n    // ensure there is a value node\n    if (!targetObject) {\n      console.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\\'t found.');\n      return;\n    }\n    if (objectName) {\n      let objectIndex = parsedPath.objectIndex;\n\n      // special cases were we need to reach deeper into the hierarchy to get the face materials....\n      switch (objectName) {\n        case 'materials':\n          if (!targetObject.material) {\n            console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);\n            return;\n          }\n          if (!targetObject.material.materials) {\n            console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);\n            return;\n          }\n          targetObject = targetObject.material.materials;\n          break;\n        case 'bones':\n          if (!targetObject.skeleton) {\n            console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);\n            return;\n          }\n\n          // potential future optimization: skip this if propertyIndex is already an integer\n          // and convert the integer string to a true integer.\n\n          targetObject = targetObject.skeleton.bones;\n\n          // support resolving morphTarget names into indices.\n          for (let i = 0; i < targetObject.length; i++) {\n            if (targetObject[i].name === objectIndex) {\n              objectIndex = i;\n              break;\n            }\n          }\n          break;\n        case 'map':\n          if ('map' in targetObject) {\n            targetObject = targetObject.map;\n            break;\n          }\n          if (!targetObject.material) {\n            console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);\n            return;\n          }\n          if (!targetObject.material.map) {\n            console.error('THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.', this);\n            return;\n          }\n          targetObject = targetObject.material.map;\n          break;\n        default:\n          if (targetObject[objectName] === undefined) {\n            console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);\n            return;\n          }\n          targetObject = targetObject[objectName];\n      }\n      if (objectIndex !== undefined) {\n        if (targetObject[objectIndex] === undefined) {\n          console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);\n          return;\n        }\n        targetObject = targetObject[objectIndex];\n      }\n    }\n\n    // resolve property\n    const nodeProperty = targetObject[propertyName];\n    if (nodeProperty === undefined) {\n      const nodeName = parsedPath.nodeName;\n      console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\\'t found.', targetObject);\n      return;\n    }\n\n    // determine versioning scheme\n    let versioning = this.Versioning.None;\n    this.targetObject = targetObject;\n    if (targetObject.needsUpdate !== undefined) {\n      // material\n\n      versioning = this.Versioning.NeedsUpdate;\n    } else if (targetObject.matrixWorldNeedsUpdate !== undefined) {\n      // node transform\n\n      versioning = this.Versioning.MatrixWorldNeedsUpdate;\n    }\n\n    // determine how the property gets bound\n    let bindingType = this.BindingType.Direct;\n    if (propertyIndex !== undefined) {\n      // access a sub element of the property array (only primitives are supported right now)\n\n      if (propertyName === 'morphTargetInfluences') {\n        // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\n        // support resolving morphTarget names into indices.\n        if (!targetObject.geometry) {\n          console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);\n          return;\n        }\n        if (!targetObject.geometry.morphAttributes) {\n          console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);\n          return;\n        }\n        if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) {\n          propertyIndex = targetObject.morphTargetDictionary[propertyIndex];\n        }\n      }\n      bindingType = this.BindingType.ArrayElement;\n      this.resolvedProperty = nodeProperty;\n      this.propertyIndex = propertyIndex;\n    } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {\n      // must use copy for Object3D.Euler/Quaternion\n\n      bindingType = this.BindingType.HasFromToArray;\n      this.resolvedProperty = nodeProperty;\n    } else if (Array.isArray(nodeProperty)) {\n      bindingType = this.BindingType.EntireArray;\n      this.resolvedProperty = nodeProperty;\n    } else {\n      this.propertyName = propertyName;\n    }\n\n    // select getter / setter\n    this.getValue = this.GetterByBindingType[bindingType];\n    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];\n  }\n  unbind() {\n    this.node = null;\n\n    // back to the prototype version of getValue / setValue\n    // note: avoiding to mutate the shape of 'this' via 'delete'\n    this.getValue = this._getValue_unbound;\n    this.setValue = this._setValue_unbound;\n  }\n}\nPropertyBinding.Composite = Composite;\nPropertyBinding.prototype.BindingType = {\n  Direct: 0,\n  EntireArray: 1,\n  ArrayElement: 2,\n  HasFromToArray: 3\n};\nPropertyBinding.prototype.Versioning = {\n  None: 0,\n  NeedsUpdate: 1,\n  MatrixWorldNeedsUpdate: 2\n};\nPropertyBinding.prototype.GetterByBindingType = [PropertyBinding.prototype._getValue_direct, PropertyBinding.prototype._getValue_array, PropertyBinding.prototype._getValue_arrayElement, PropertyBinding.prototype._getValue_toArray];\nPropertyBinding.prototype.SetterByBindingTypeAndVersioning = [[\n// Direct\nPropertyBinding.prototype._setValue_direct, PropertyBinding.prototype._setValue_direct_setNeedsUpdate, PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [\n// EntireArray\n\nPropertyBinding.prototype._setValue_array, PropertyBinding.prototype._setValue_array_setNeedsUpdate, PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate], [\n// ArrayElement\nPropertyBinding.prototype._setValue_arrayElement, PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate, PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [\n// HasToFromArray\nPropertyBinding.prototype._setValue_fromArray, PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate, PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];\nexport { PropertyBinding };","map":{"version":3,"names":["_RESERVED_CHARS_RE","_reservedRe","RegExp","_wordChar","_wordCharOrDot","replace","_directoryRe","source","_nodeRe","_objectRe","_propertyRe","_trackRe","_supportedObjectNames","Composite","constructor","targetGroup","path","optionalParsedPath","parsedPath","PropertyBinding","parseTrackName","_targetGroup","_bindings","subscribe_","getValue","array","offset","bind","firstValidIndex","nCachedObjects_","binding","undefined","setValue","bindings","i","n","length","unbind","rootNode","node","findNode","nodeName","_getValue_unbound","_setValue_unbound","create","root","isAnimationObjectGroup","sanitizeNodeName","name","trackName","matches","exec","Error","results","objectName","objectIndex","propertyName","propertyIndex","lastDot","lastIndexOf","substring","indexOf","uuid","skeleton","bone","getBoneByName","children","searchNodeSubtree","childNode","result","subTreeNode","_getValue_unavailable","_setValue_unavailable","_getValue_direct","buffer","targetObject","_getValue_array","resolvedProperty","_getValue_arrayElement","_getValue_toArray","toArray","_setValue_direct","_setValue_direct_setNeedsUpdate","needsUpdate","_setValue_direct_setMatrixWorldNeedsUpdate","matrixWorldNeedsUpdate","_setValue_array","dest","_setValue_array_setNeedsUpdate","_setValue_array_setMatrixWorldNeedsUpdate","_setValue_arrayElement","_setValue_arrayElement_setNeedsUpdate","_setValue_arrayElement_setMatrixWorldNeedsUpdate","_setValue_fromArray","fromArray","_setValue_fromArray_setNeedsUpdate","_setValue_fromArray_setMatrixWorldNeedsUpdate","targetArray","sourceArray","console","error","material","materials","bones","map","nodeProperty","versioning","Versioning","None","NeedsUpdate","MatrixWorldNeedsUpdate","bindingType","BindingType","Direct","geometry","morphAttributes","morphTargetDictionary","ArrayElement","HasFromToArray","Array","isArray","EntireArray","GetterByBindingType","SetterByBindingTypeAndVersioning","prototype"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/animation/PropertyBinding.js"],"sourcesContent":["// Characters [].:/ are reserved for track binding syntax.\nconst _RESERVED_CHARS_RE = '\\\\[\\\\]\\\\.:\\\\/';\nconst _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );\n\n// Attempts to allow node names from any language. ES5's `\\w` regexp matches\n// only latin characters, and the unicode \\p{L} is not yet supported. So\n// instead, we exclude reserved characters and match everything else.\nconst _wordChar = '[^' + _RESERVED_CHARS_RE + ']';\nconst _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\\\.', '' ) + ']';\n\n// Parent directories, delimited by '/' or ':'. Currently unused, but must\n// be matched to parse the rest of the track name.\nconst _directoryRe = /*@__PURE__*/ /((?:WC+[\\/:])*)/.source.replace( 'WC', _wordChar );\n\n// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.\nconst _nodeRe = /*@__PURE__*/ /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );\n\n// Object on target node, and accessor. May not contain reserved\n// characters. Accessor may contain any character except closing bracket.\nconst _objectRe = /*@__PURE__*/ /(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace( 'WC', _wordChar );\n\n// Property and accessor. May not contain reserved characters. Accessor may\n// contain any non-bracket characters.\nconst _propertyRe = /*@__PURE__*/ /\\.(WC+)(?:\\[(.+)\\])?/.source.replace( 'WC', _wordChar );\n\nconst _trackRe = new RegExp( ''\n\t+ '^'\n\t+ _directoryRe\n\t+ _nodeRe\n\t+ _objectRe\n\t+ _propertyRe\n\t+ '$'\n);\n\nconst _supportedObjectNames = [ 'material', 'materials', 'bones', 'map' ];\n\nclass Composite {\n\n\tconstructor( targetGroup, path, optionalParsedPath ) {\n\n\t\tconst parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );\n\n\t\tthis._targetGroup = targetGroup;\n\t\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\n\n\t}\n\n\tgetValue( array, offset ) {\n\n\t\tthis.bind(); // bind all binding\n\n\t\tconst firstValidIndex = this._targetGroup.nCachedObjects_,\n\t\t\tbinding = this._bindings[ firstValidIndex ];\n\n\t\t// and only call .getValue on the first\n\t\tif ( binding !== undefined ) binding.getValue( array, offset );\n\n\t}\n\n\tsetValue( array, offset ) {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].setValue( array, offset );\n\n\t\t}\n\n\t}\n\n\tbind() {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].bind();\n\n\t\t}\n\n\t}\n\n\tunbind() {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].unbind();\n\n\t\t}\n\n\t}\n\n}\n\n// Note: This class uses a State pattern on a per-method basis:\n// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n// prototype version of these methods with one that represents\n// the bound state. When the property is not found, the methods\n// become no-ops.\nclass PropertyBinding {\n\n\tconstructor( rootNode, path, parsedPath ) {\n\n\t\tthis.path = path;\n\t\tthis.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );\n\n\t\tthis.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;\n\n\t\tthis.rootNode = rootNode;\n\n\t\t// initial state of these methods that calls 'bind'\n\t\tthis.getValue = this._getValue_unbound;\n\t\tthis.setValue = this._setValue_unbound;\n\n\t}\n\n\n\tstatic create( root, path, parsedPath ) {\n\n\t\tif ( ! ( root && root.isAnimationObjectGroup ) ) {\n\n\t\t\treturn new PropertyBinding( root, path, parsedPath );\n\n\t\t} else {\n\n\t\t\treturn new PropertyBinding.Composite( root, path, parsedPath );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Replaces spaces with underscores and removes unsupported characters from\n\t * node names, to ensure compatibility with parseTrackName().\n\t *\n\t * @param {string} name Node name to be sanitized.\n\t * @return {string}\n\t */\n\tstatic sanitizeNodeName( name ) {\n\n\t\treturn name.replace( /\\s/g, '_' ).replace( _reservedRe, '' );\n\n\t}\n\n\tstatic parseTrackName( trackName ) {\n\n\t\tconst matches = _trackRe.exec( trackName );\n\n\t\tif ( matches === null ) {\n\n\t\t\tthrow new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );\n\n\t\t}\n\n\t\tconst results = {\n\t\t\t// directoryName: matches[ 1 ], // (tschw) currently unused\n\t\t\tnodeName: matches[ 2 ],\n\t\t\tobjectName: matches[ 3 ],\n\t\t\tobjectIndex: matches[ 4 ],\n\t\t\tpropertyName: matches[ 5 ], // required\n\t\t\tpropertyIndex: matches[ 6 ]\n\t\t};\n\n\t\tconst lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );\n\n\t\tif ( lastDot !== undefined && lastDot !== - 1 ) {\n\n\t\t\tconst objectName = results.nodeName.substring( lastDot + 1 );\n\n\t\t\t// Object names must be checked against an allowlist. Otherwise, there\n\t\t\t// is no way to parse 'foo.bar.baz': 'baz' must be a property, but\n\t\t\t// 'bar' could be the objectName, or part of a nodeName (which can\n\t\t\t// include '.' characters).\n\t\t\tif ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {\n\n\t\t\t\tresults.nodeName = results.nodeName.substring( 0, lastDot );\n\t\t\t\tresults.objectName = objectName;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\n\n\t\t\tthrow new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );\n\n\t\t}\n\n\t\treturn results;\n\n\t}\n\n\tstatic findNode( root, nodeName ) {\n\n\t\tif ( nodeName === undefined || nodeName === '' || nodeName === '.' || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {\n\n\t\t\treturn root;\n\n\t\t}\n\n\t\t// search into skeleton bones.\n\t\tif ( root.skeleton ) {\n\n\t\t\tconst bone = root.skeleton.getBoneByName( nodeName );\n\n\t\t\tif ( bone !== undefined ) {\n\n\t\t\t\treturn bone;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// search into node subtree.\n\t\tif ( root.children ) {\n\n\t\t\tconst searchNodeSubtree = function ( children ) {\n\n\t\t\t\tfor ( let i = 0; i < children.length; i ++ ) {\n\n\t\t\t\t\tconst childNode = children[ i ];\n\n\t\t\t\t\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\n\n\t\t\t\t\t\treturn childNode;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = searchNodeSubtree( childNode.children );\n\n\t\t\t\t\tif ( result ) return result;\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t};\n\n\t\t\tconst subTreeNode = searchNodeSubtree( root.children );\n\n\t\t\tif ( subTreeNode ) {\n\n\t\t\t\treturn subTreeNode;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t// these are used to \"bind\" a nonexistent property\n\t_getValue_unavailable() {}\n\t_setValue_unavailable() {}\n\n\t// Getters\n\n\t_getValue_direct( buffer, offset ) {\n\n\t\tbuffer[ offset ] = this.targetObject[ this.propertyName ];\n\n\t}\n\n\t_getValue_array( buffer, offset ) {\n\n\t\tconst source = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = source.length; i !== n; ++ i ) {\n\n\t\t\tbuffer[ offset ++ ] = source[ i ];\n\n\t\t}\n\n\t}\n\n\t_getValue_arrayElement( buffer, offset ) {\n\n\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\n\n\t}\n\n\t_getValue_toArray( buffer, offset ) {\n\n\t\tthis.resolvedProperty.toArray( buffer, offset );\n\n\t}\n\n\t// Direct\n\n\t_setValue_direct( buffer, offset ) {\n\n\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\n\t}\n\n\t_setValue_direct_setNeedsUpdate( buffer, offset ) {\n\n\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t// EntireArray\n\n\t_setValue_array( buffer, offset ) {\n\n\t\tconst dest = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t}\n\n\t}\n\n\t_setValue_array_setNeedsUpdate( buffer, offset ) {\n\n\t\tconst dest = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t}\n\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tconst dest = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t}\n\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t// ArrayElement\n\n\t_setValue_arrayElement( buffer, offset ) {\n\n\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\n\t}\n\n\t_setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t// HasToFromArray\n\n\t_setValue_fromArray( buffer, offset ) {\n\n\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\n\t}\n\n\t_setValue_fromArray_setNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t_getValue_unbound( targetArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.getValue( targetArray, offset );\n\n\t}\n\n\t_setValue_unbound( sourceArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.setValue( sourceArray, offset );\n\n\t}\n\n\t// create getter / setter pair for a property in the scene graph\n\tbind() {\n\n\t\tlet targetObject = this.node;\n\t\tconst parsedPath = this.parsedPath;\n\n\t\tconst objectName = parsedPath.objectName;\n\t\tconst propertyName = parsedPath.propertyName;\n\t\tlet propertyIndex = parsedPath.propertyIndex;\n\n\t\tif ( ! targetObject ) {\n\n\t\t\ttargetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;\n\n\t\t\tthis.node = targetObject;\n\n\t\t}\n\n\t\t// set fail state so we can just 'return' on error\n\t\tthis.getValue = this._getValue_unavailable;\n\t\tthis.setValue = this._setValue_unavailable;\n\n\t\t// ensure there is a value node\n\t\tif ( ! targetObject ) {\n\n\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\\'t found.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( objectName ) {\n\n\t\t\tlet objectIndex = parsedPath.objectIndex;\n\n\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\n\t\t\tswitch ( objectName ) {\n\n\t\t\t\tcase 'materials':\n\n\t\t\t\t\tif ( ! targetObject.material ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material.materials ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject.material.materials;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bones':\n\n\t\t\t\t\tif ( ! targetObject.skeleton ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\n\t\t\t\t\t// and convert the integer string to a true integer.\n\n\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\n\n\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\tfor ( let i = 0; i < targetObject.length; i ++ ) {\n\n\t\t\t\t\t\tif ( targetObject[ i ].name === objectIndex ) {\n\n\t\t\t\t\t\t\tobjectIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map':\n\n\t\t\t\t\tif ( 'map' in targetObject ) {\n\n\t\t\t\t\t\ttargetObject = targetObject.map;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material.map ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject.material.map;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject[ objectName ];\n\n\t\t\t}\n\n\n\t\t\tif ( objectIndex !== undefined ) {\n\n\t\t\t\tif ( targetObject[ objectIndex ] === undefined ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\ttargetObject = targetObject[ objectIndex ];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// resolve property\n\t\tconst nodeProperty = targetObject[ propertyName ];\n\n\t\tif ( nodeProperty === undefined ) {\n\n\t\t\tconst nodeName = parsedPath.nodeName;\n\n\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +\n\t\t\t\t'.' + propertyName + ' but it wasn\\'t found.', targetObject );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// determine versioning scheme\n\t\tlet versioning = this.Versioning.None;\n\n\t\tthis.targetObject = targetObject;\n\n\t\tif ( targetObject.needsUpdate !== undefined ) { // material\n\n\t\t\tversioning = this.Versioning.NeedsUpdate;\n\n\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\n\n\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\n\n\t\t}\n\n\t\t// determine how the property gets bound\n\t\tlet bindingType = this.BindingType.Direct;\n\n\t\tif ( propertyIndex !== undefined ) {\n\n\t\t\t// access a sub element of the property array (only primitives are supported right now)\n\n\t\t\tif ( propertyName === 'morphTargetInfluences' ) {\n\n\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\n\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\tif ( ! targetObject.geometry ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! targetObject.geometry.morphAttributes ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {\n\n\t\t\t\t\tpropertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbindingType = this.BindingType.ArrayElement;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\tthis.propertyIndex = propertyIndex;\n\n\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\n\n\t\t\t// must use copy for Object3D.Euler/Quaternion\n\n\t\t\tbindingType = this.BindingType.HasFromToArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else if ( Array.isArray( nodeProperty ) ) {\n\n\t\t\tbindingType = this.BindingType.EntireArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else {\n\n\t\t\tthis.propertyName = propertyName;\n\n\t\t}\n\n\t\t// select getter / setter\n\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\n\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\n\n\t}\n\n\tunbind() {\n\n\t\tthis.node = null;\n\n\t\t// back to the prototype version of getValue / setValue\n\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\n\t\tthis.getValue = this._getValue_unbound;\n\t\tthis.setValue = this._setValue_unbound;\n\n\t}\n\n}\n\nPropertyBinding.Composite = Composite;\n\nPropertyBinding.prototype.BindingType = {\n\tDirect: 0,\n\tEntireArray: 1,\n\tArrayElement: 2,\n\tHasFromToArray: 3\n};\n\nPropertyBinding.prototype.Versioning = {\n\tNone: 0,\n\tNeedsUpdate: 1,\n\tMatrixWorldNeedsUpdate: 2\n};\n\nPropertyBinding.prototype.GetterByBindingType = [\n\n\tPropertyBinding.prototype._getValue_direct,\n\tPropertyBinding.prototype._getValue_array,\n\tPropertyBinding.prototype._getValue_arrayElement,\n\tPropertyBinding.prototype._getValue_toArray,\n\n];\n\nPropertyBinding.prototype.SetterByBindingTypeAndVersioning = [\n\n\t[\n\t\t// Direct\n\t\tPropertyBinding.prototype._setValue_direct,\n\t\tPropertyBinding.prototype._setValue_direct_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate,\n\n\t], [\n\n\t\t// EntireArray\n\n\t\tPropertyBinding.prototype._setValue_array,\n\t\tPropertyBinding.prototype._setValue_array_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate,\n\n\t], [\n\n\t\t// ArrayElement\n\t\tPropertyBinding.prototype._setValue_arrayElement,\n\t\tPropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,\n\n\t], [\n\n\t\t// HasToFromArray\n\t\tPropertyBinding.prototype._setValue_fromArray,\n\t\tPropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,\n\n\t]\n\n];\n\n\nexport { PropertyBinding };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}