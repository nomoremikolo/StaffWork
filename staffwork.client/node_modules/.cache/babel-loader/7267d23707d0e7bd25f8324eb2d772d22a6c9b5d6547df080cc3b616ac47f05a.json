{"ast":null,"code":"import Node from '../core/Node.js';\nimport AttributeNode from '../core/AttributeNode.js';\nimport VaryingNode from '../core/VaryingNode.js';\nimport ModelNode from '../accessors/ModelNode.js';\nimport MathNode from '../math/MathNode.js';\nimport OperatorNode from '../math/OperatorNode.js';\nclass PositionNode extends Node {\n  static GEOMETRY = 'geometry';\n  static LOCAL = 'local';\n  static WORLD = 'world';\n  static WORLD_DIRECTION = 'worldDirection';\n  static VIEW = 'view';\n  static VIEW_DIRECTION = 'viewDirection';\n  constructor() {\n    let scope = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : PositionNode.LOCAL;\n    super('vec3');\n    this.scope = scope;\n  }\n  getHash( /*builder*/\n  ) {\n    return `position-${this.scope}`;\n  }\n  generate(builder) {\n    const scope = this.scope;\n    let outputNode = null;\n    if (scope === PositionNode.GEOMETRY) {\n      outputNode = new AttributeNode('position', 'vec3');\n    } else if (scope === PositionNode.LOCAL) {\n      outputNode = new VaryingNode(new PositionNode(PositionNode.GEOMETRY));\n    } else if (scope === PositionNode.WORLD) {\n      const vertexPositionNode = new MathNode(MathNode.TRANSFORM_DIRECTION, new ModelNode(ModelNode.WORLD_MATRIX), new PositionNode(PositionNode.LOCAL));\n      outputNode = new VaryingNode(vertexPositionNode);\n    } else if (scope === PositionNode.VIEW) {\n      const vertexPositionNode = new OperatorNode('*', new ModelNode(ModelNode.VIEW_MATRIX), new PositionNode(PositionNode.LOCAL));\n      outputNode = new VaryingNode(vertexPositionNode);\n    } else if (scope === PositionNode.VIEW_DIRECTION) {\n      const vertexPositionNode = new MathNode(MathNode.NEGATE, new PositionNode(PositionNode.VIEW));\n      outputNode = new MathNode(MathNode.NORMALIZE, new VaryingNode(vertexPositionNode));\n    } else if (scope === PositionNode.WORLD_DIRECTION) {\n      const vertexPositionNode = new MathNode(MathNode.NEGATE, new PositionNode(PositionNode.WORLD));\n      outputNode = new MathNode(MathNode.NORMALIZE, new VaryingNode(vertexPositionNode));\n    }\n    return outputNode.build(builder, this.getNodeType(builder));\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.scope = this.scope;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.scope = data.scope;\n  }\n}\nexport default PositionNode;","map":{"version":3,"names":["Node","AttributeNode","VaryingNode","ModelNode","MathNode","OperatorNode","PositionNode","GEOMETRY","LOCAL","WORLD","WORLD_DIRECTION","VIEW","VIEW_DIRECTION","constructor","scope","getHash","generate","builder","outputNode","vertexPositionNode","TRANSFORM_DIRECTION","WORLD_MATRIX","VIEW_MATRIX","NEGATE","NORMALIZE","build","getNodeType","serialize","data","deserialize"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/examples/jsm/nodes/accessors/PositionNode.js"],"sourcesContent":["import Node from '../core/Node.js';\nimport AttributeNode from '../core/AttributeNode.js';\nimport VaryingNode from '../core/VaryingNode.js';\nimport ModelNode from '../accessors/ModelNode.js';\nimport MathNode from '../math/MathNode.js';\nimport OperatorNode from '../math/OperatorNode.js';\n\nclass PositionNode extends Node {\n\n\tstatic GEOMETRY = 'geometry';\n\tstatic LOCAL = 'local';\n\tstatic WORLD = 'world';\n\tstatic WORLD_DIRECTION = 'worldDirection';\n\tstatic VIEW = 'view';\n\tstatic VIEW_DIRECTION = 'viewDirection';\n\n\tconstructor( scope = PositionNode.LOCAL ) {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.scope = scope;\n\n\t}\n\n\tgetHash( /*builder*/ ) {\n\n\t\treturn `position-${this.scope}`;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst scope = this.scope;\n\n\t\tlet outputNode = null;\n\n\t\tif ( scope === PositionNode.GEOMETRY ) {\n\n\t\t\toutputNode = new AttributeNode( 'position', 'vec3' );\n\n\t\t} else if ( scope === PositionNode.LOCAL ) {\n\n\t\t\toutputNode = new VaryingNode( new PositionNode( PositionNode.GEOMETRY ) );\n\n\t\t} else if ( scope === PositionNode.WORLD ) {\n\n\t\t\tconst vertexPositionNode = new MathNode( MathNode.TRANSFORM_DIRECTION, new ModelNode( ModelNode.WORLD_MATRIX ), new PositionNode( PositionNode.LOCAL ) );\n\t\t\toutputNode = new VaryingNode( vertexPositionNode );\n\n\t\t} else if ( scope === PositionNode.VIEW ) {\n\n\t\t\tconst vertexPositionNode = new OperatorNode( '*', new ModelNode( ModelNode.VIEW_MATRIX ), new PositionNode( PositionNode.LOCAL ) );\n\t\t\toutputNode = new VaryingNode( vertexPositionNode );\n\n\t\t} else if ( scope === PositionNode.VIEW_DIRECTION ) {\n\n\t\t\tconst vertexPositionNode = new MathNode( MathNode.NEGATE, new PositionNode( PositionNode.VIEW ) );\n\t\t\toutputNode = new MathNode( MathNode.NORMALIZE, new VaryingNode( vertexPositionNode ) );\n\n\t\t} else if ( scope === PositionNode.WORLD_DIRECTION ) {\n\n\t\t\tconst vertexPositionNode = new MathNode( MathNode.NEGATE, new PositionNode( PositionNode.WORLD ) );\n\t\t\toutputNode = new MathNode( MathNode.NORMALIZE, new VaryingNode( vertexPositionNode ) );\n\n\t\t}\n\n\t\treturn outputNode.build( builder, this.getNodeType( builder ) );\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.scope = this.scope;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.scope = data.scope;\n\n\t}\n\n}\n\nexport default PositionNode;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}