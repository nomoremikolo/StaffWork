{"ast":null,"code":"import TempNode from '../core/TempNode.js';\nimport { ShaderNode, vec3, mat3, add, sub, mul, max, div, float, mix, cos, sin, atan2, sqrt, luminance } from '../shadernode/ShaderNodeBaseElements.js';\nconst saturationNode = new ShaderNode(_ref => {\n  let {\n    color,\n    adjustment\n  } = _ref;\n  return mix(luminance(color), color, adjustment);\n});\nconst vibranceNode = new ShaderNode(_ref2 => {\n  let {\n    color,\n    adjustment\n  } = _ref2;\n  const average = div(add(color.r, color.g, color.b), 3.0);\n  const mx = max(color.r, max(color.g, color.b));\n  const amt = mul(sub(mx, average), mul(-3.0, adjustment));\n  return mix(color.rgb, vec3(mx), amt);\n});\nconst hueNode = new ShaderNode(_ref3 => {\n  let {\n    color,\n    adjustment\n  } = _ref3;\n  const RGBtoYIQ = mat3(0.299, 0.587, 0.114, 0.595716, -0.274453, -0.321263, 0.211456, -0.522591, 0.311135);\n  const YIQtoRGB = mat3(1.0, 0.9563, 0.6210, 1.0, -0.2721, -0.6474, 1.0, -1.107, 1.7046);\n  const yiq = mul(RGBtoYIQ, color);\n  const hue = add(atan2(yiq.z, yiq.y), adjustment);\n  const chroma = sqrt(add(mul(yiq.z, yiq.z), mul(yiq.y, yiq.y)));\n  return mul(YIQtoRGB, vec3(yiq.x, mul(chroma, cos(hue)), mul(chroma, sin(hue))));\n});\nclass ColorAdjustmentNode extends TempNode {\n  static SATURATION = 'saturation';\n  static VIBRANCE = 'vibrance';\n  static HUE = 'hue';\n  constructor(method, colorNode) {\n    let adjustmentNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : float(1);\n    super('vec3');\n    this.method = method;\n    this.colorNode = colorNode;\n    this.adjustmentNode = adjustmentNode;\n  }\n  construct() {\n    const {\n      method,\n      colorNode,\n      adjustmentNode\n    } = this;\n    const callParams = {\n      color: colorNode,\n      adjustment: adjustmentNode\n    };\n    let outputNode = null;\n    if (method === ColorAdjustmentNode.SATURATION) {\n      outputNode = saturationNode.call(callParams);\n    } else if (method === ColorAdjustmentNode.VIBRANCE) {\n      outputNode = vibranceNode.call(callParams);\n    } else if (method === ColorAdjustmentNode.HUE) {\n      outputNode = hueNode.call(callParams);\n    } else {\n      console.error(`${this.type}: Method \"${this.method}\" not supported!`);\n    }\n    return outputNode;\n  }\n}\nexport default ColorAdjustmentNode;","map":{"version":3,"names":["TempNode","ShaderNode","vec3","mat3","add","sub","mul","max","div","float","mix","cos","sin","atan2","sqrt","luminance","saturationNode","color","adjustment","vibranceNode","average","r","g","b","mx","amt","rgb","hueNode","RGBtoYIQ","YIQtoRGB","yiq","hue","z","y","chroma","x","ColorAdjustmentNode","SATURATION","VIBRANCE","HUE","constructor","method","colorNode","adjustmentNode","construct","callParams","outputNode","call","console","error","type"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/examples/jsm/nodes/display/ColorAdjustmentNode.js"],"sourcesContent":["import TempNode from '../core/TempNode.js';\nimport { ShaderNode, vec3, mat3, add, sub, mul, max, div, float, mix, cos, sin, atan2, sqrt, luminance } from '../shadernode/ShaderNodeBaseElements.js';\n\nconst saturationNode = new ShaderNode( ( { color, adjustment } ) => {\n\n\treturn mix( luminance( color ), color, adjustment );\n\n} );\n\nconst vibranceNode = new ShaderNode( ( { color, adjustment } ) => {\n\n\tconst average = div( add( color.r, color.g, color.b ), 3.0 );\n\n\tconst mx = max( color.r, max( color.g, color.b ) );\n\tconst amt = mul( sub( mx, average ), mul( - 3.0, adjustment ) );\n\n\treturn mix( color.rgb, vec3( mx ), amt );\n\n} );\n\nconst hueNode = new ShaderNode( ( { color, adjustment } ) => {\n\n\tconst RGBtoYIQ = mat3( 0.299, 0.587, 0.114, 0.595716, - 0.274453, - 0.321263, 0.211456, - 0.522591, 0.311135 );\n\tconst YIQtoRGB = mat3( 1.0, 0.9563, 0.6210, 1.0, - 0.2721, - 0.6474, 1.0, - 1.107, 1.7046 );\n\n\tconst yiq = mul( RGBtoYIQ, color );\n\n\tconst hue = add( atan2( yiq.z, yiq.y ), adjustment );\n\tconst chroma = sqrt( add( mul( yiq.z, yiq.z ), mul( yiq.y, yiq.y ) ) );\n\n\treturn mul( YIQtoRGB, vec3( yiq.x, mul( chroma, cos( hue ) ), mul( chroma, sin( hue ) ) ) );\n\n} );\n\nclass ColorAdjustmentNode extends TempNode {\n\n\tstatic SATURATION = 'saturation';\n\tstatic VIBRANCE = 'vibrance';\n\tstatic HUE = 'hue';\n\n\tconstructor( method, colorNode, adjustmentNode = float( 1 ) ) {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.method = method;\n\n\t\tthis.colorNode = colorNode;\n\t\tthis.adjustmentNode = adjustmentNode;\n\n\t}\n\n\tconstruct() {\n\n\t\tconst { method, colorNode, adjustmentNode } = this;\n\n\t\tconst callParams = { color: colorNode, adjustment: adjustmentNode };\n\n\t\tlet outputNode = null;\n\n\t\tif ( method === ColorAdjustmentNode.SATURATION ) {\n\n\t\t\toutputNode = saturationNode.call( callParams );\n\n\t\t} else if ( method === ColorAdjustmentNode.VIBRANCE ) {\n\n\t\t\toutputNode = vibranceNode.call( callParams );\n\n\t\t} else if ( method === ColorAdjustmentNode.HUE ) {\n\n\t\t\toutputNode = hueNode.call( callParams );\n\n\t\t} else {\n\n\t\t\tconsole.error( `${ this.type }: Method \"${ this.method }\" not supported!` );\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\nexport default ColorAdjustmentNode;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}