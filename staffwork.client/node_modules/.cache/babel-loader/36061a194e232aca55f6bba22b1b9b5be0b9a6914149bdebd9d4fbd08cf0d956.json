{"ast":null,"code":"/**\n * Port from https://github.com/mapbox/earcut (v2.2.4)\n */\n\nconst Earcut = {\n  triangulate: function (data, holeIndices) {\n    let dim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\n    const hasHoles = holeIndices && holeIndices.length;\n    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n    let outerNode = linkedList(data, 0, outerLen, dim, true);\n    const triangles = [];\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n    let minX, minY, maxX, maxY, x, y, invSize;\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n      minX = maxX = data[0];\n      minY = maxY = data[1];\n      for (let i = dim; i < outerLen; i += dim) {\n        x = data[i];\n        y = data[i + 1];\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n      }\n\n      // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n      invSize = Math.max(maxX - minX, maxY - minY);\n      invSize = invSize !== 0 ? 32767 / invSize : 0;\n    }\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n    return triangles;\n  }\n};\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n  let i, last;\n  if (clockwise === signedArea(data, start, end, dim) > 0) {\n    for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n  } else {\n    for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n  }\n  if (last && equals(last, last.next)) {\n    removeNode(last);\n    last = last.next;\n  }\n  return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n  if (!start) return start;\n  if (!end) end = start;\n  let p = start,\n    again;\n  do {\n    again = false;\n    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n      removeNode(p);\n      p = end = p.prev;\n      if (p === p.next) break;\n      again = true;\n    } else {\n      p = p.next;\n    }\n  } while (again || p !== end);\n  return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n  if (!ear) return;\n\n  // interlink polygon nodes in z-order\n  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n  let stop = ear,\n    prev,\n    next;\n\n  // iterate through ears, slicing them one by one\n  while (ear.prev !== ear.next) {\n    prev = ear.prev;\n    next = ear.next;\n    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n      // cut off the triangle\n      triangles.push(prev.i / dim | 0);\n      triangles.push(ear.i / dim | 0);\n      triangles.push(next.i / dim | 0);\n      removeNode(ear);\n\n      // skipping the next vertex leads to less sliver triangles\n      ear = next.next;\n      stop = next.next;\n      continue;\n    }\n    ear = next;\n\n    // if we looped through the whole remaining polygon and can't find any more ears\n    if (ear === stop) {\n      // try filtering points and slicing again\n      if (!pass) {\n        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n        // if this didn't work, try curing all small self-intersections locally\n      } else if (pass === 1) {\n        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n        // as a last resort, try splitting the remaining polygon into two\n      } else if (pass === 2) {\n        splitEarcut(ear, triangles, dim, minX, minY, invSize);\n      }\n      break;\n    }\n  }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n  const a = ear.prev,\n    b = ear,\n    c = ear.next;\n  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n  // now make sure we don't have other points inside the potential ear\n  const ax = a.x,\n    bx = b.x,\n    cx = c.x,\n    ay = a.y,\n    by = b.y,\n    cy = c.y;\n\n  // triangle bbox; min & max are calculated like this for speed\n  const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx,\n    y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy,\n    x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx,\n    y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;\n  let p = c.next;\n  while (p !== a) {\n    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n    p = p.next;\n  }\n  return true;\n}\nfunction isEarHashed(ear, minX, minY, invSize) {\n  const a = ear.prev,\n    b = ear,\n    c = ear.next;\n  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n  const ax = a.x,\n    bx = b.x,\n    cx = c.x,\n    ay = a.y,\n    by = b.y,\n    cy = c.y;\n\n  // triangle bbox; min & max are calculated like this for speed\n  const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx,\n    y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy,\n    x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx,\n    y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;\n\n  // z-order range for the current triangle bbox;\n  const minZ = zOrder(x0, y0, minX, minY, invSize),\n    maxZ = zOrder(x1, y1, minX, minY, invSize);\n  let p = ear.prevZ,\n    n = ear.nextZ;\n\n  // look for points inside the triangle in both directions\n  while (p && p.z >= minZ && n && n.z <= maxZ) {\n    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n    p = p.prevZ;\n    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n    n = n.nextZ;\n  }\n\n  // look for remaining points in decreasing z-order\n  while (p && p.z >= minZ) {\n    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n    p = p.prevZ;\n  }\n\n  // look for remaining points in increasing z-order\n  while (n && n.z <= maxZ) {\n    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n    n = n.nextZ;\n  }\n  return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n  let p = start;\n  do {\n    const a = p.prev,\n      b = p.next.next;\n    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n      triangles.push(a.i / dim | 0);\n      triangles.push(p.i / dim | 0);\n      triangles.push(b.i / dim | 0);\n\n      // remove two nodes involved\n      removeNode(p);\n      removeNode(p.next);\n      p = start = b;\n    }\n    p = p.next;\n  } while (p !== start);\n  return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n  // look for a valid diagonal that divides the polygon into two\n  let a = start;\n  do {\n    let b = a.next.next;\n    while (b !== a.prev) {\n      if (a.i !== b.i && isValidDiagonal(a, b)) {\n        // split the polygon in two by the diagonal\n        let c = splitPolygon(a, b);\n\n        // filter colinear points around the cuts\n        a = filterPoints(a, a.next);\n        c = filterPoints(c, c.next);\n\n        // run earcut on each half\n        earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n        earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n        return;\n      }\n      b = b.next;\n    }\n    a = a.next;\n  } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n  const queue = [];\n  let i, len, start, end, list;\n  for (i = 0, len = holeIndices.length; i < len; i++) {\n    start = holeIndices[i] * dim;\n    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n    list = linkedList(data, start, end, dim, false);\n    if (list === list.next) list.steiner = true;\n    queue.push(getLeftmost(list));\n  }\n  queue.sort(compareX);\n\n  // process holes from left to right\n  for (i = 0; i < queue.length; i++) {\n    outerNode = eliminateHole(queue[i], outerNode);\n  }\n  return outerNode;\n}\nfunction compareX(a, b) {\n  return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and link it\nfunction eliminateHole(hole, outerNode) {\n  const bridge = findHoleBridge(hole, outerNode);\n  if (!bridge) {\n    return outerNode;\n  }\n  const bridgeReverse = splitPolygon(bridge, hole);\n\n  // filter collinear points around the cuts\n  filterPoints(bridgeReverse, bridgeReverse.next);\n  return filterPoints(bridge, bridge.next);\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n  let p = outerNode,\n    qx = -Infinity,\n    m;\n  const hx = hole.x,\n    hy = hole.y;\n\n  // find a segment intersected by a ray from the hole's leftmost point to the left;\n  // segment's endpoint with lesser x will be potential connection point\n  do {\n    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n      const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n      if (x <= hx && x > qx) {\n        qx = x;\n        m = p.x < p.next.x ? p : p.next;\n        if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n      }\n    }\n\n    p = p.next;\n  } while (p !== outerNode);\n  if (!m) return null;\n\n  // look for points inside the triangle of hole point, segment intersection and endpoint;\n  // if there are no points found, we have a valid connection;\n  // otherwise choose the point of the minimum angle with the ray as connection point\n\n  const stop = m,\n    mx = m.x,\n    my = m.y;\n  let tanMin = Infinity,\n    tan;\n  p = m;\n  do {\n    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n      tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {\n        m = p;\n        tanMin = tan;\n      }\n    }\n    p = p.next;\n  } while (p !== stop);\n  return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n  let p = start;\n  do {\n    if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n    p.prevZ = p.prev;\n    p.nextZ = p.next;\n    p = p.next;\n  } while (p !== start);\n  p.prevZ.nextZ = null;\n  p.prevZ = null;\n  sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n  let i,\n    p,\n    q,\n    e,\n    tail,\n    numMerges,\n    pSize,\n    qSize,\n    inSize = 1;\n  do {\n    p = list;\n    list = null;\n    tail = null;\n    numMerges = 0;\n    while (p) {\n      numMerges++;\n      q = p;\n      pSize = 0;\n      for (i = 0; i < inSize; i++) {\n        pSize++;\n        q = q.nextZ;\n        if (!q) break;\n      }\n      qSize = inSize;\n      while (pSize > 0 || qSize > 0 && q) {\n        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n          e = p;\n          p = p.nextZ;\n          pSize--;\n        } else {\n          e = q;\n          q = q.nextZ;\n          qSize--;\n        }\n        if (tail) tail.nextZ = e;else list = e;\n        e.prevZ = tail;\n        tail = e;\n      }\n      p = q;\n    }\n    tail.nextZ = null;\n    inSize *= 2;\n  } while (numMerges > 1);\n  return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n  // coords are transformed into non-negative 15-bit integer range\n  x = (x - minX) * invSize | 0;\n  y = (y - minY) * invSize | 0;\n  x = (x | x << 8) & 0x00FF00FF;\n  x = (x | x << 4) & 0x0F0F0F0F;\n  x = (x | x << 2) & 0x33333333;\n  x = (x | x << 1) & 0x55555555;\n  y = (y | y << 8) & 0x00FF00FF;\n  y = (y | y << 4) & 0x0F0F0F0F;\n  y = (y | y << 2) & 0x33333333;\n  y = (y | y << 1) & 0x55555555;\n  return x | y << 1;\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n  let p = start,\n    leftmost = start;\n  do {\n    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;\n    p = p.next;\n  } while (p !== start);\n  return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n  return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (\n  // dones't intersect other edges\n  locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (\n  // locally visible\n  area(a.prev, a, b.prev) || area(a, b.prev, b)) ||\n  // does not create opposite-facing sectors\n  equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n  return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n  const o1 = sign(area(p1, q1, p2));\n  const o2 = sign(area(p1, q1, q2));\n  const o3 = sign(area(p2, q2, p1));\n  const o4 = sign(area(p2, q2, q1));\n  if (o1 !== o2 && o3 !== o4) return true; // general case\n\n  if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n  if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n  if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n  if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n  return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\nfunction sign(num) {\n  return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n  let p = a;\n  do {\n    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;\n    p = p.next;\n  } while (p !== a);\n  return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n  let p = a,\n    inside = false;\n  const px = (a.x + b.x) / 2,\n    py = (a.y + b.y) / 2;\n  do {\n    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;\n    p = p.next;\n  } while (p !== a);\n  return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n  const a2 = new Node(a.i, a.x, a.y),\n    b2 = new Node(b.i, b.x, b.y),\n    an = a.next,\n    bp = b.prev;\n  a.next = b;\n  b.prev = a;\n  a2.next = an;\n  an.prev = a2;\n  b2.next = a2;\n  a2.prev = b2;\n  bp.next = b2;\n  b2.prev = bp;\n  return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n  const p = new Node(i, x, y);\n  if (!last) {\n    p.prev = p;\n    p.next = p;\n  } else {\n    p.next = last.next;\n    p.prev = last;\n    last.next.prev = p;\n    last.next = p;\n  }\n  return p;\n}\nfunction removeNode(p) {\n  p.next.prev = p.prev;\n  p.prev.next = p.next;\n  if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n  if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\nfunction Node(i, x, y) {\n  // vertex index in coordinates array\n  this.i = i;\n\n  // vertex coordinates\n  this.x = x;\n  this.y = y;\n\n  // previous and next vertex nodes in a polygon ring\n  this.prev = null;\n  this.next = null;\n\n  // z-order curve value\n  this.z = 0;\n\n  // previous and next nodes in z-order\n  this.prevZ = null;\n  this.nextZ = null;\n\n  // indicates whether this is a steiner point\n  this.steiner = false;\n}\nfunction signedArea(data, start, end, dim) {\n  let sum = 0;\n  for (let i = start, j = end - dim; i < end; i += dim) {\n    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n    j = i;\n  }\n  return sum;\n}\nexport { Earcut };","map":{"version":3,"names":["Earcut","triangulate","data","holeIndices","dim","hasHoles","length","outerLen","outerNode","linkedList","triangles","next","prev","minX","minY","maxX","maxY","x","y","invSize","eliminateHoles","i","Math","max","earcutLinked","start","end","clockwise","last","signedArea","insertNode","equals","removeNode","filterPoints","p","again","steiner","area","ear","pass","indexCurve","stop","isEarHashed","isEar","push","cureLocalIntersections","splitEarcut","a","b","c","ax","bx","cx","ay","by","cy","x0","y0","x1","y1","pointInTriangle","minZ","zOrder","maxZ","prevZ","n","nextZ","z","intersects","locallyInside","isValidDiagonal","splitPolygon","queue","len","list","getLeftmost","sort","compareX","eliminateHole","hole","bridge","findHoleBridge","bridgeReverse","qx","Infinity","m","hx","hy","mx","my","tanMin","tan","abs","sectorContainsSector","sortLinked","q","e","tail","numMerges","pSize","qSize","inSize","leftmost","px","py","intersectsPolygon","middleInside","r","p1","p2","q1","q2","o1","sign","o2","o3","o4","onSegment","min","num","inside","a2","Node","b2","an","bp","sum","j"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/extras/Earcut.js"],"sourcesContent":["/**\n * Port from https://github.com/mapbox/earcut (v2.2.4)\n */\n\nconst Earcut = {\n\n\ttriangulate: function ( data, holeIndices, dim = 2 ) {\n\n\t\tconst hasHoles = holeIndices && holeIndices.length;\n\t\tconst outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length;\n\t\tlet outerNode = linkedList( data, 0, outerLen, dim, true );\n\t\tconst triangles = [];\n\n\t\tif ( ! outerNode || outerNode.next === outerNode.prev ) return triangles;\n\n\t\tlet minX, minY, maxX, maxY, x, y, invSize;\n\n\t\tif ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );\n\n\t\t// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n\t\tif ( data.length > 80 * dim ) {\n\n\t\t\tminX = maxX = data[ 0 ];\n\t\t\tminY = maxY = data[ 1 ];\n\n\t\t\tfor ( let i = dim; i < outerLen; i += dim ) {\n\n\t\t\t\tx = data[ i ];\n\t\t\t\ty = data[ i + 1 ];\n\t\t\t\tif ( x < minX ) minX = x;\n\t\t\t\tif ( y < minY ) minY = y;\n\t\t\t\tif ( x > maxX ) maxX = x;\n\t\t\t\tif ( y > maxY ) maxY = y;\n\n\t\t\t}\n\n\t\t\t// minX, minY and invSize are later used to transform coords into integers for z-order calculation\n\t\t\tinvSize = Math.max( maxX - minX, maxY - minY );\n\t\t\tinvSize = invSize !== 0 ? 32767 / invSize : 0;\n\n\t\t}\n\n\t\tearcutLinked( outerNode, triangles, dim, minX, minY, invSize, 0 );\n\n\t\treturn triangles;\n\n\t}\n\n};\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList( data, start, end, dim, clockwise ) {\n\n\tlet i, last;\n\n\tif ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {\n\n\t\tfor ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\n\n\t} else {\n\n\t\tfor ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\n\n\t}\n\n\tif ( last && equals( last, last.next ) ) {\n\n\t\tremoveNode( last );\n\t\tlast = last.next;\n\n\t}\n\n\treturn last;\n\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints( start, end ) {\n\n\tif ( ! start ) return start;\n\tif ( ! end ) end = start;\n\n\tlet p = start,\n\t\tagain;\n\tdo {\n\n\t\tagain = false;\n\n\t\tif ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {\n\n\t\t\tremoveNode( p );\n\t\t\tp = end = p.prev;\n\t\t\tif ( p === p.next ) break;\n\t\t\tagain = true;\n\n\t\t} else {\n\n\t\t\tp = p.next;\n\n\t\t}\n\n\t} while ( again || p !== end );\n\n\treturn end;\n\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {\n\n\tif ( ! ear ) return;\n\n\t// interlink polygon nodes in z-order\n\tif ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );\n\n\tlet stop = ear,\n\t\tprev, next;\n\n\t// iterate through ears, slicing them one by one\n\twhile ( ear.prev !== ear.next ) {\n\n\t\tprev = ear.prev;\n\t\tnext = ear.next;\n\n\t\tif ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {\n\n\t\t\t// cut off the triangle\n\t\t\ttriangles.push( prev.i / dim | 0 );\n\t\t\ttriangles.push( ear.i / dim | 0 );\n\t\t\ttriangles.push( next.i / dim | 0 );\n\n\t\t\tremoveNode( ear );\n\n\t\t\t// skipping the next vertex leads to less sliver triangles\n\t\t\tear = next.next;\n\t\t\tstop = next.next;\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tear = next;\n\n\t\t// if we looped through the whole remaining polygon and can't find any more ears\n\t\tif ( ear === stop ) {\n\n\t\t\t// try filtering points and slicing again\n\t\t\tif ( ! pass ) {\n\n\t\t\t\tearcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );\n\n\t\t\t\t// if this didn't work, try curing all small self-intersections locally\n\n\t\t\t} else if ( pass === 1 ) {\n\n\t\t\t\tear = cureLocalIntersections( filterPoints( ear ), triangles, dim );\n\t\t\t\tearcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );\n\n\t\t\t\t// as a last resort, try splitting the remaining polygon into two\n\n\t\t\t} else if ( pass === 2 ) {\n\n\t\t\t\tsplitEarcut( ear, triangles, dim, minX, minY, invSize );\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar( ear ) {\n\n\tconst a = ear.prev,\n\t\tb = ear,\n\t\tc = ear.next;\n\n\tif ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\n\n\t// now make sure we don't have other points inside the potential ear\n\tconst ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n\t// triangle bbox; min & max are calculated like this for speed\n\tconst x0 = ax < bx ? ( ax < cx ? ax : cx ) : ( bx < cx ? bx : cx ),\n\t\ty0 = ay < by ? ( ay < cy ? ay : cy ) : ( by < cy ? by : cy ),\n\t\tx1 = ax > bx ? ( ax > cx ? ax : cx ) : ( bx > cx ? bx : cx ),\n\t\ty1 = ay > by ? ( ay > cy ? ay : cy ) : ( by > cy ? by : cy );\n\n\tlet p = c.next;\n\twhile ( p !== a ) {\n\n\t\tif ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&\n\t\t\tpointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) &&\n\t\t\tarea( p.prev, p, p.next ) >= 0 ) return false;\n\t\tp = p.next;\n\n\t}\n\n\treturn true;\n\n}\n\nfunction isEarHashed( ear, minX, minY, invSize ) {\n\n\tconst a = ear.prev,\n\t\tb = ear,\n\t\tc = ear.next;\n\n\tif ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\n\n\tconst ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n\t// triangle bbox; min & max are calculated like this for speed\n\tconst x0 = ax < bx ? ( ax < cx ? ax : cx ) : ( bx < cx ? bx : cx ),\n\t\ty0 = ay < by ? ( ay < cy ? ay : cy ) : ( by < cy ? by : cy ),\n\t\tx1 = ax > bx ? ( ax > cx ? ax : cx ) : ( bx > cx ? bx : cx ),\n\t\ty1 = ay > by ? ( ay > cy ? ay : cy ) : ( by > cy ? by : cy );\n\n\t// z-order range for the current triangle bbox;\n\tconst minZ = zOrder( x0, y0, minX, minY, invSize ),\n\t\tmaxZ = zOrder( x1, y1, minX, minY, invSize );\n\n\tlet p = ear.prevZ,\n\t\tn = ear.nextZ;\n\n\t// look for points inside the triangle in both directions\n\twhile ( p && p.z >= minZ && n && n.z <= maxZ ) {\n\n\t\tif ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n\t\t\tpointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) return false;\n\t\tp = p.prevZ;\n\n\t\tif ( n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n\t\t\tpointInTriangle( ax, ay, bx, by, cx, cy, n.x, n.y ) && area( n.prev, n, n.next ) >= 0 ) return false;\n\t\tn = n.nextZ;\n\n\t}\n\n\t// look for remaining points in decreasing z-order\n\twhile ( p && p.z >= minZ ) {\n\n\t\tif ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n\t\t\tpointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) return false;\n\t\tp = p.prevZ;\n\n\t}\n\n\t// look for remaining points in increasing z-order\n\twhile ( n && n.z <= maxZ ) {\n\n\t\tif ( n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n\t\t\tpointInTriangle( ax, ay, bx, by, cx, cy, n.x, n.y ) && area( n.prev, n, n.next ) >= 0 ) return false;\n\t\tn = n.nextZ;\n\n\t}\n\n\treturn true;\n\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections( start, triangles, dim ) {\n\n\tlet p = start;\n\tdo {\n\n\t\tconst a = p.prev,\n\t\t\tb = p.next.next;\n\n\t\tif ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {\n\n\t\t\ttriangles.push( a.i / dim | 0 );\n\t\t\ttriangles.push( p.i / dim | 0 );\n\t\t\ttriangles.push( b.i / dim | 0 );\n\n\t\t\t// remove two nodes involved\n\t\t\tremoveNode( p );\n\t\t\tremoveNode( p.next );\n\n\t\t\tp = start = b;\n\n\t\t}\n\n\t\tp = p.next;\n\n\t} while ( p !== start );\n\n\treturn filterPoints( p );\n\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut( start, triangles, dim, minX, minY, invSize ) {\n\n\t// look for a valid diagonal that divides the polygon into two\n\tlet a = start;\n\tdo {\n\n\t\tlet b = a.next.next;\n\t\twhile ( b !== a.prev ) {\n\n\t\t\tif ( a.i !== b.i && isValidDiagonal( a, b ) ) {\n\n\t\t\t\t// split the polygon in two by the diagonal\n\t\t\t\tlet c = splitPolygon( a, b );\n\n\t\t\t\t// filter colinear points around the cuts\n\t\t\t\ta = filterPoints( a, a.next );\n\t\t\t\tc = filterPoints( c, c.next );\n\n\t\t\t\t// run earcut on each half\n\t\t\t\tearcutLinked( a, triangles, dim, minX, minY, invSize, 0 );\n\t\t\t\tearcutLinked( c, triangles, dim, minX, minY, invSize, 0 );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tb = b.next;\n\n\t\t}\n\n\t\ta = a.next;\n\n\t} while ( a !== start );\n\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles( data, holeIndices, outerNode, dim ) {\n\n\tconst queue = [];\n\tlet i, len, start, end, list;\n\n\tfor ( i = 0, len = holeIndices.length; i < len; i ++ ) {\n\n\t\tstart = holeIndices[ i ] * dim;\n\t\tend = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;\n\t\tlist = linkedList( data, start, end, dim, false );\n\t\tif ( list === list.next ) list.steiner = true;\n\t\tqueue.push( getLeftmost( list ) );\n\n\t}\n\n\tqueue.sort( compareX );\n\n\t// process holes from left to right\n\tfor ( i = 0; i < queue.length; i ++ ) {\n\n\t\touterNode = eliminateHole( queue[ i ], outerNode );\n\n\t}\n\n\treturn outerNode;\n\n}\n\nfunction compareX( a, b ) {\n\n\treturn a.x - b.x;\n\n}\n\n// find a bridge between vertices that connects hole with an outer ring and link it\nfunction eliminateHole( hole, outerNode ) {\n\n\tconst bridge = findHoleBridge( hole, outerNode );\n\tif ( ! bridge ) {\n\n\t\treturn outerNode;\n\n\t}\n\n\tconst bridgeReverse = splitPolygon( bridge, hole );\n\n\t// filter collinear points around the cuts\n\tfilterPoints( bridgeReverse, bridgeReverse.next );\n\treturn filterPoints( bridge, bridge.next );\n\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge( hole, outerNode ) {\n\n\tlet p = outerNode,\n\t\tqx = - Infinity,\n\t\tm;\n\n\tconst hx = hole.x, hy = hole.y;\n\n\t// find a segment intersected by a ray from the hole's leftmost point to the left;\n\t// segment's endpoint with lesser x will be potential connection point\n\tdo {\n\n\t\tif ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {\n\n\t\t\tconst x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );\n\t\t\tif ( x <= hx && x > qx ) {\n\n\t\t\t\tqx = x;\n\t\t\t\tm = p.x < p.next.x ? p : p.next;\n\t\t\t\tif ( x === hx ) return m; // hole touches outer segment; pick leftmost endpoint\n\n\t\t\t}\n\n\t\t}\n\n\t\tp = p.next;\n\n\t} while ( p !== outerNode );\n\n\tif ( ! m ) return null;\n\n\t// look for points inside the triangle of hole point, segment intersection and endpoint;\n\t// if there are no points found, we have a valid connection;\n\t// otherwise choose the point of the minimum angle with the ray as connection point\n\n\tconst stop = m,\n\t\tmx = m.x,\n\t\tmy = m.y;\n\tlet tanMin = Infinity, tan;\n\n\tp = m;\n\n\tdo {\n\n\t\tif ( hx >= p.x && p.x >= mx && hx !== p.x &&\n\t\t\t\tpointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {\n\n\t\t\ttan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential\n\n\t\t\tif ( locallyInside( p, hole ) && ( tan < tanMin || ( tan === tanMin && ( p.x > m.x || ( p.x === m.x && sectorContainsSector( m, p ) ) ) ) ) ) {\n\n\t\t\t\tm = p;\n\t\t\t\ttanMin = tan;\n\n\t\t\t}\n\n\t\t}\n\n\t\tp = p.next;\n\n\t} while ( p !== stop );\n\n\treturn m;\n\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector( m, p ) {\n\n\treturn area( m.prev, m, p.prev ) < 0 && area( p.next, m, m.next ) < 0;\n\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve( start, minX, minY, invSize ) {\n\n\tlet p = start;\n\tdo {\n\n\t\tif ( p.z === 0 ) p.z = zOrder( p.x, p.y, minX, minY, invSize );\n\t\tp.prevZ = p.prev;\n\t\tp.nextZ = p.next;\n\t\tp = p.next;\n\n\t} while ( p !== start );\n\n\tp.prevZ.nextZ = null;\n\tp.prevZ = null;\n\n\tsortLinked( p );\n\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked( list ) {\n\n\tlet i, p, q, e, tail, numMerges, pSize, qSize,\n\t\tinSize = 1;\n\n\tdo {\n\n\t\tp = list;\n\t\tlist = null;\n\t\ttail = null;\n\t\tnumMerges = 0;\n\n\t\twhile ( p ) {\n\n\t\t\tnumMerges ++;\n\t\t\tq = p;\n\t\t\tpSize = 0;\n\t\t\tfor ( i = 0; i < inSize; i ++ ) {\n\n\t\t\t\tpSize ++;\n\t\t\t\tq = q.nextZ;\n\t\t\t\tif ( ! q ) break;\n\n\t\t\t}\n\n\t\t\tqSize = inSize;\n\n\t\t\twhile ( pSize > 0 || ( qSize > 0 && q ) ) {\n\n\t\t\t\tif ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {\n\n\t\t\t\t\te = p;\n\t\t\t\t\tp = p.nextZ;\n\t\t\t\t\tpSize --;\n\n\t\t\t\t} else {\n\n\t\t\t\t\te = q;\n\t\t\t\t\tq = q.nextZ;\n\t\t\t\t\tqSize --;\n\n\t\t\t\t}\n\n\t\t\t\tif ( tail ) tail.nextZ = e;\n\t\t\t\telse list = e;\n\n\t\t\t\te.prevZ = tail;\n\t\t\t\ttail = e;\n\n\t\t\t}\n\n\t\t\tp = q;\n\n\t\t}\n\n\t\ttail.nextZ = null;\n\t\tinSize *= 2;\n\n\t} while ( numMerges > 1 );\n\n\treturn list;\n\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder( x, y, minX, minY, invSize ) {\n\n\t// coords are transformed into non-negative 15-bit integer range\n\tx = ( x - minX ) * invSize | 0;\n\ty = ( y - minY ) * invSize | 0;\n\n\tx = ( x | ( x << 8 ) ) & 0x00FF00FF;\n\tx = ( x | ( x << 4 ) ) & 0x0F0F0F0F;\n\tx = ( x | ( x << 2 ) ) & 0x33333333;\n\tx = ( x | ( x << 1 ) ) & 0x55555555;\n\n\ty = ( y | ( y << 8 ) ) & 0x00FF00FF;\n\ty = ( y | ( y << 4 ) ) & 0x0F0F0F0F;\n\ty = ( y | ( y << 2 ) ) & 0x33333333;\n\ty = ( y | ( y << 1 ) ) & 0x55555555;\n\n\treturn x | ( y << 1 );\n\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost( start ) {\n\n\tlet p = start,\n\t\tleftmost = start;\n\tdo {\n\n\t\tif ( p.x < leftmost.x || ( p.x === leftmost.x && p.y < leftmost.y ) ) leftmost = p;\n\t\tp = p.next;\n\n\t} while ( p !== start );\n\n\treturn leftmost;\n\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {\n\n\treturn ( cx - px ) * ( ay - py ) >= ( ax - px ) * ( cy - py ) &&\n           ( ax - px ) * ( by - py ) >= ( bx - px ) * ( ay - py ) &&\n           ( bx - px ) * ( cy - py ) >= ( cx - px ) * ( by - py );\n\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal( a, b ) {\n\n\treturn a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) && // dones't intersect other edges\n           ( locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b ) && // locally visible\n            ( area( a.prev, a, b.prev ) || area( a, b.prev, b ) ) || // does not create opposite-facing sectors\n            equals( a, b ) && area( a.prev, a, a.next ) > 0 && area( b.prev, b, b.next ) > 0 ); // special zero-length case\n\n}\n\n// signed area of a triangle\nfunction area( p, q, r ) {\n\n\treturn ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );\n\n}\n\n// check if two points are equal\nfunction equals( p1, p2 ) {\n\n\treturn p1.x === p2.x && p1.y === p2.y;\n\n}\n\n// check if two segments intersect\nfunction intersects( p1, q1, p2, q2 ) {\n\n\tconst o1 = sign( area( p1, q1, p2 ) );\n\tconst o2 = sign( area( p1, q1, q2 ) );\n\tconst o3 = sign( area( p2, q2, p1 ) );\n\tconst o4 = sign( area( p2, q2, q1 ) );\n\n\tif ( o1 !== o2 && o3 !== o4 ) return true; // general case\n\n\tif ( o1 === 0 && onSegment( p1, p2, q1 ) ) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n\tif ( o2 === 0 && onSegment( p1, q2, q1 ) ) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n\tif ( o3 === 0 && onSegment( p2, p1, q2 ) ) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n\tif ( o4 === 0 && onSegment( p2, q1, q2 ) ) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n\treturn false;\n\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment( p, q, r ) {\n\n\treturn q.x <= Math.max( p.x, r.x ) && q.x >= Math.min( p.x, r.x ) && q.y <= Math.max( p.y, r.y ) && q.y >= Math.min( p.y, r.y );\n\n}\n\nfunction sign( num ) {\n\n\treturn num > 0 ? 1 : num < 0 ? - 1 : 0;\n\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon( a, b ) {\n\n\tlet p = a;\n\tdo {\n\n\t\tif ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n\t\t\tintersects( p, p.next, a, b ) ) return true;\n\t\tp = p.next;\n\n\t} while ( p !== a );\n\n\treturn false;\n\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside( a, b ) {\n\n\treturn area( a.prev, a, a.next ) < 0 ?\n\t\tarea( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :\n\t\tarea( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;\n\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside( a, b ) {\n\n\tlet p = a,\n\t\tinside = false;\n\tconst px = ( a.x + b.x ) / 2,\n\t\tpy = ( a.y + b.y ) / 2;\n\tdo {\n\n\t\tif ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&\n\t\t\t( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) )\n\t\t\tinside = ! inside;\n\t\tp = p.next;\n\n\t} while ( p !== a );\n\n\treturn inside;\n\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon( a, b ) {\n\n\tconst a2 = new Node( a.i, a.x, a.y ),\n\t\tb2 = new Node( b.i, b.x, b.y ),\n\t\tan = a.next,\n\t\tbp = b.prev;\n\n\ta.next = b;\n\tb.prev = a;\n\n\ta2.next = an;\n\tan.prev = a2;\n\n\tb2.next = a2;\n\ta2.prev = b2;\n\n\tbp.next = b2;\n\tb2.prev = bp;\n\n\treturn b2;\n\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode( i, x, y, last ) {\n\n\tconst p = new Node( i, x, y );\n\n\tif ( ! last ) {\n\n\t\tp.prev = p;\n\t\tp.next = p;\n\n\t} else {\n\n\t\tp.next = last.next;\n\t\tp.prev = last;\n\t\tlast.next.prev = p;\n\t\tlast.next = p;\n\n\t}\n\n\treturn p;\n\n}\n\nfunction removeNode( p ) {\n\n\tp.next.prev = p.prev;\n\tp.prev.next = p.next;\n\n\tif ( p.prevZ ) p.prevZ.nextZ = p.nextZ;\n\tif ( p.nextZ ) p.nextZ.prevZ = p.prevZ;\n\n}\n\nfunction Node( i, x, y ) {\n\n\t// vertex index in coordinates array\n\tthis.i = i;\n\n\t// vertex coordinates\n\tthis.x = x;\n\tthis.y = y;\n\n\t// previous and next vertex nodes in a polygon ring\n\tthis.prev = null;\n\tthis.next = null;\n\n\t// z-order curve value\n\tthis.z = 0;\n\n\t// previous and next nodes in z-order\n\tthis.prevZ = null;\n\tthis.nextZ = null;\n\n\t// indicates whether this is a steiner point\n\tthis.steiner = false;\n\n}\n\nfunction signedArea( data, start, end, dim ) {\n\n\tlet sum = 0;\n\tfor ( let i = start, j = end - dim; i < end; i += dim ) {\n\n\t\tsum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );\n\t\tj = i;\n\n\t}\n\n\treturn sum;\n\n}\n\nexport { Earcut };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}