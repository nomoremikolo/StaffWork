{"ast":null,"code":"import { Camera } from './Camera.js';\nimport * as MathUtils from '../math/MathUtils.js';\nclass PerspectiveCamera extends Camera {\n  constructor() {\n    let fov = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;\n    let aspect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    let near = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.1;\n    let far = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2000;\n    super();\n    this.isPerspectiveCamera = true;\n    this.type = 'PerspectiveCamera';\n    this.fov = fov;\n    this.zoom = 1;\n    this.near = near;\n    this.far = far;\n    this.focus = 10;\n    this.aspect = aspect;\n    this.view = null;\n    this.filmGauge = 35; // width of the film (default in millimeters)\n    this.filmOffset = 0; // horizontal film offset (same unit as gauge)\n\n    this.updateProjectionMatrix();\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.fov = source.fov;\n    this.zoom = source.zoom;\n    this.near = source.near;\n    this.far = source.far;\n    this.focus = source.focus;\n    this.aspect = source.aspect;\n    this.view = source.view === null ? null : Object.assign({}, source.view);\n    this.filmGauge = source.filmGauge;\n    this.filmOffset = source.filmOffset;\n    return this;\n  }\n\n  /**\n   * Sets the FOV by focal length in respect to the current .filmGauge.\n   *\n   * The default film gauge is 35, so that the focal length can be specified for\n   * a 35mm (full frame) camera.\n   *\n   * Values for focal length and film gauge must have the same unit.\n   */\n  setFocalLength(focalLength) {\n    /** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */\n    const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n    this.fov = MathUtils.RAD2DEG * 2 * Math.atan(vExtentSlope);\n    this.updateProjectionMatrix();\n  }\n\n  /**\n   * Calculates the focal length from the current .fov and .filmGauge.\n   */\n  getFocalLength() {\n    const vExtentSlope = Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov);\n    return 0.5 * this.getFilmHeight() / vExtentSlope;\n  }\n  getEffectiveFOV() {\n    return MathUtils.RAD2DEG * 2 * Math.atan(Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom);\n  }\n  getFilmWidth() {\n    // film not completely covered in portrait format (aspect < 1)\n    return this.filmGauge * Math.min(this.aspect, 1);\n  }\n  getFilmHeight() {\n    // film not completely covered in landscape format (aspect > 1)\n    return this.filmGauge / Math.max(this.aspect, 1);\n  }\n\n  /**\n   * Sets an offset in a larger frustum. This is useful for multi-window or\n   * multi-monitor/multi-machine setups.\n   *\n   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n   * the monitors are in grid like this\n   *\n   *   +---+---+---+\n   *   | A | B | C |\n   *   +---+---+---+\n   *   | D | E | F |\n   *   +---+---+---+\n   *\n   * then for each monitor you would call it like this\n   *\n   *   const w = 1920;\n   *   const h = 1080;\n   *   const fullWidth = w * 3;\n   *   const fullHeight = h * 2;\n   *\n   *   --A--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n   *   --B--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n   *   --C--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n   *   --D--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n   *   --E--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n   *   --F--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n   *\n   *   Note there is no reason monitors have to be the same size or in a grid.\n   */\n  setViewOffset(fullWidth, fullHeight, x, y, width, height) {\n    this.aspect = fullWidth / fullHeight;\n    if (this.view === null) {\n      this.view = {\n        enabled: true,\n        fullWidth: 1,\n        fullHeight: 1,\n        offsetX: 0,\n        offsetY: 0,\n        width: 1,\n        height: 1\n      };\n    }\n    this.view.enabled = true;\n    this.view.fullWidth = fullWidth;\n    this.view.fullHeight = fullHeight;\n    this.view.offsetX = x;\n    this.view.offsetY = y;\n    this.view.width = width;\n    this.view.height = height;\n    this.updateProjectionMatrix();\n  }\n  clearViewOffset() {\n    if (this.view !== null) {\n      this.view.enabled = false;\n    }\n    this.updateProjectionMatrix();\n  }\n  updateProjectionMatrix() {\n    const near = this.near;\n    let top = near * Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom;\n    let height = 2 * top;\n    let width = this.aspect * height;\n    let left = -0.5 * width;\n    const view = this.view;\n    if (this.view !== null && this.view.enabled) {\n      const fullWidth = view.fullWidth,\n        fullHeight = view.fullHeight;\n      left += view.offsetX * width / fullWidth;\n      top -= view.offsetY * height / fullHeight;\n      width *= view.width / fullWidth;\n      height *= view.height / fullHeight;\n    }\n    const skew = this.filmOffset;\n    if (skew !== 0) left += near * skew / this.getFilmWidth();\n    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);\n    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();\n  }\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n    data.object.fov = this.fov;\n    data.object.zoom = this.zoom;\n    data.object.near = this.near;\n    data.object.far = this.far;\n    data.object.focus = this.focus;\n    data.object.aspect = this.aspect;\n    if (this.view !== null) data.object.view = Object.assign({}, this.view);\n    data.object.filmGauge = this.filmGauge;\n    data.object.filmOffset = this.filmOffset;\n    return data;\n  }\n}\nexport { PerspectiveCamera };","map":{"version":3,"names":["Camera","MathUtils","PerspectiveCamera","constructor","fov","aspect","near","far","isPerspectiveCamera","type","zoom","focus","view","filmGauge","filmOffset","updateProjectionMatrix","copy","source","recursive","Object","assign","setFocalLength","focalLength","vExtentSlope","getFilmHeight","RAD2DEG","Math","atan","getFocalLength","tan","DEG2RAD","getEffectiveFOV","getFilmWidth","min","max","setViewOffset","fullWidth","fullHeight","x","y","width","height","enabled","offsetX","offsetY","clearViewOffset","top","left","skew","projectionMatrix","makePerspective","projectionMatrixInverse","invert","toJSON","meta","data","object"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/cameras/PerspectiveCamera.js"],"sourcesContent":["import { Camera } from './Camera.js';\nimport * as MathUtils from '../math/MathUtils.js';\n\nclass PerspectiveCamera extends Camera {\n\n\tconstructor( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {\n\n\t\tsuper();\n\n\t\tthis.isPerspectiveCamera = true;\n\n\t\tthis.type = 'PerspectiveCamera';\n\n\t\tthis.fov = fov;\n\t\tthis.zoom = 1;\n\n\t\tthis.near = near;\n\t\tthis.far = far;\n\t\tthis.focus = 10;\n\n\t\tthis.aspect = aspect;\n\t\tthis.view = null;\n\n\t\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\n\t\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.fov = source.fov;\n\t\tthis.zoom = source.zoom;\n\n\t\tthis.near = source.near;\n\t\tthis.far = source.far;\n\t\tthis.focus = source.focus;\n\n\t\tthis.aspect = source.aspect;\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\tthis.filmGauge = source.filmGauge;\n\t\tthis.filmOffset = source.filmOffset;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the FOV by focal length in respect to the current .filmGauge.\n\t *\n\t * The default film gauge is 35, so that the focal length can be specified for\n\t * a 35mm (full frame) camera.\n\t *\n\t * Values for focal length and film gauge must have the same unit.\n\t */\n\tsetFocalLength( focalLength ) {\n\n\t\t/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */\n\t\tconst vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n\n\t\tthis.fov = MathUtils.RAD2DEG * 2 * Math.atan( vExtentSlope );\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\t/**\n\t * Calculates the focal length from the current .fov and .filmGauge.\n\t */\n\tgetFocalLength() {\n\n\t\tconst vExtentSlope = Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov );\n\n\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\n\n\t}\n\n\tgetEffectiveFOV() {\n\n\t\treturn MathUtils.RAD2DEG * 2 * Math.atan(\n\t\t\tMath.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom );\n\n\t}\n\n\tgetFilmWidth() {\n\n\t\t// film not completely covered in portrait format (aspect < 1)\n\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\n\n\t}\n\n\tgetFilmHeight() {\n\n\t\t// film not completely covered in landscape format (aspect > 1)\n\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\n\n\t}\n\n\t/**\n\t * Sets an offset in a larger frustum. This is useful for multi-window or\n\t * multi-monitor/multi-machine setups.\n\t *\n\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n\t * the monitors are in grid like this\n\t *\n\t *   +---+---+---+\n\t *   | A | B | C |\n\t *   +---+---+---+\n\t *   | D | E | F |\n\t *   +---+---+---+\n\t *\n\t * then for each monitor you would call it like this\n\t *\n\t *   const w = 1920;\n\t *   const h = 1080;\n\t *   const fullWidth = w * 3;\n\t *   const fullHeight = h * 2;\n\t *\n\t *   --A--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n\t *   --B--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n\t *   --C--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n\t *   --D--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n\t *   --E--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n\t *   --F--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n\t *\n\t *   Note there is no reason monitors have to be the same size or in a grid.\n\t */\n\tsetViewOffset( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\tthis.aspect = fullWidth / fullHeight;\n\n\t\tif ( this.view === null ) {\n\n\t\t\tthis.view = {\n\t\t\t\tenabled: true,\n\t\t\t\tfullWidth: 1,\n\t\t\t\tfullHeight: 1,\n\t\t\t\toffsetX: 0,\n\t\t\t\toffsetY: 0,\n\t\t\t\twidth: 1,\n\t\t\t\theight: 1\n\t\t\t};\n\n\t\t}\n\n\t\tthis.view.enabled = true;\n\t\tthis.view.fullWidth = fullWidth;\n\t\tthis.view.fullHeight = fullHeight;\n\t\tthis.view.offsetX = x;\n\t\tthis.view.offsetY = y;\n\t\tthis.view.width = width;\n\t\tthis.view.height = height;\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tclearViewOffset() {\n\n\t\tif ( this.view !== null ) {\n\n\t\t\tthis.view.enabled = false;\n\n\t\t}\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tupdateProjectionMatrix() {\n\n\t\tconst near = this.near;\n\t\tlet top = near * Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom;\n\t\tlet height = 2 * top;\n\t\tlet width = this.aspect * height;\n\t\tlet left = - 0.5 * width;\n\t\tconst view = this.view;\n\n\t\tif ( this.view !== null && this.view.enabled ) {\n\n\t\t\tconst fullWidth = view.fullWidth,\n\t\t\t\tfullHeight = view.fullHeight;\n\n\t\t\tleft += view.offsetX * width / fullWidth;\n\t\t\ttop -= view.offsetY * height / fullHeight;\n\t\t\twidth *= view.width / fullWidth;\n\t\t\theight *= view.height / fullHeight;\n\n\t\t}\n\n\t\tconst skew = this.filmOffset;\n\t\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\n\n\t\tthis.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );\n\n\t\tthis.projectionMatrixInverse.copy( this.projectionMatrix ).invert();\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.fov = this.fov;\n\t\tdata.object.zoom = this.zoom;\n\n\t\tdata.object.near = this.near;\n\t\tdata.object.far = this.far;\n\t\tdata.object.focus = this.focus;\n\n\t\tdata.object.aspect = this.aspect;\n\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\tdata.object.filmGauge = this.filmGauge;\n\t\tdata.object.filmOffset = this.filmOffset;\n\n\t\treturn data;\n\n\t}\n\n}\n\nexport { PerspectiveCamera };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}