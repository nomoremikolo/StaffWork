{"ast":null,"code":"import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Vector3 } from '../math/Vector3.js';\nclass RingGeometry extends BufferGeometry {\n  constructor() {\n    let innerRadius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.5;\n    let outerRadius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    let thetaSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 8;\n    let phiSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    let thetaStart = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    let thetaLength = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Math.PI * 2;\n    super();\n    this.type = 'RingGeometry';\n    this.parameters = {\n      innerRadius: innerRadius,\n      outerRadius: outerRadius,\n      thetaSegments: thetaSegments,\n      phiSegments: phiSegments,\n      thetaStart: thetaStart,\n      thetaLength: thetaLength\n    };\n    thetaSegments = Math.max(3, thetaSegments);\n    phiSegments = Math.max(1, phiSegments);\n\n    // buffers\n\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n\n    // some helper variables\n\n    let radius = innerRadius;\n    const radiusStep = (outerRadius - innerRadius) / phiSegments;\n    const vertex = new Vector3();\n    const uv = new Vector2();\n\n    // generate vertices, normals and uvs\n\n    for (let j = 0; j <= phiSegments; j++) {\n      for (let i = 0; i <= thetaSegments; i++) {\n        // values are generate from the inside of the ring to the outside\n\n        const segment = thetaStart + i / thetaSegments * thetaLength;\n\n        // vertex\n\n        vertex.x = radius * Math.cos(segment);\n        vertex.y = radius * Math.sin(segment);\n        vertices.push(vertex.x, vertex.y, vertex.z);\n\n        // normal\n\n        normals.push(0, 0, 1);\n\n        // uv\n\n        uv.x = (vertex.x / outerRadius + 1) / 2;\n        uv.y = (vertex.y / outerRadius + 1) / 2;\n        uvs.push(uv.x, uv.y);\n      }\n\n      // increase the radius for next row of vertices\n\n      radius += radiusStep;\n    }\n\n    // indices\n\n    for (let j = 0; j < phiSegments; j++) {\n      const thetaSegmentLevel = j * (thetaSegments + 1);\n      for (let i = 0; i < thetaSegments; i++) {\n        const segment = i + thetaSegmentLevel;\n        const a = segment;\n        const b = segment + thetaSegments + 1;\n        const c = segment + thetaSegments + 2;\n        const d = segment + 1;\n\n        // faces\n\n        indices.push(a, b, d);\n        indices.push(b, c, d);\n      }\n    }\n\n    // build geometry\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n  }\n  static fromJSON(data) {\n    return new RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);\n  }\n}\nexport { RingGeometry };","map":{"version":3,"names":["BufferGeometry","Float32BufferAttribute","Vector2","Vector3","RingGeometry","constructor","innerRadius","outerRadius","thetaSegments","phiSegments","thetaStart","thetaLength","Math","PI","type","parameters","max","indices","vertices","normals","uvs","radius","radiusStep","vertex","uv","j","i","segment","x","cos","y","sin","push","z","thetaSegmentLevel","a","b","c","d","setIndex","setAttribute","fromJSON","data"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/geometries/RingGeometry.js"],"sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nclass RingGeometry extends BufferGeometry {\n\n\tconstructor( innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'RingGeometry';\n\n\t\tthis.parameters = {\n\t\t\tinnerRadius: innerRadius,\n\t\t\touterRadius: outerRadius,\n\t\t\tthetaSegments: thetaSegments,\n\t\t\tphiSegments: phiSegments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tthetaSegments = Math.max( 3, thetaSegments );\n\t\tphiSegments = Math.max( 1, phiSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// some helper variables\n\n\t\tlet radius = innerRadius;\n\t\tconst radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\n\t\tconst vertex = new Vector3();\n\t\tconst uv = new Vector2();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let j = 0; j <= phiSegments; j ++ ) {\n\n\t\t\tfor ( let i = 0; i <= thetaSegments; i ++ ) {\n\n\t\t\t\t// values are generate from the inside of the ring to the outside\n\n\t\t\t\tconst segment = thetaStart + i / thetaSegments * thetaLength;\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\t\tvertex.y = radius * Math.sin( segment );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\t\t// uv\n\n\t\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\n\t\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\n\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t}\n\n\t\t\t// increase the radius for next row of vertices\n\n\t\t\tradius += radiusStep;\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let j = 0; j < phiSegments; j ++ ) {\n\n\t\t\tconst thetaSegmentLevel = j * ( thetaSegments + 1 );\n\n\t\t\tfor ( let i = 0; i < thetaSegments; i ++ ) {\n\n\t\t\t\tconst segment = i + thetaSegmentLevel;\n\n\t\t\t\tconst a = segment;\n\t\t\t\tconst b = segment + thetaSegments + 1;\n\t\t\t\tconst c = segment + thetaSegments + 2;\n\t\t\t\tconst d = segment + 1;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new RingGeometry( data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\n\nexport { RingGeometry };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}