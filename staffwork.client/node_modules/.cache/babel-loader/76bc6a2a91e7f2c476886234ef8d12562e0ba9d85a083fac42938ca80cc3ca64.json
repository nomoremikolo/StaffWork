{"ast":null,"code":"/**\n * Creates extruded geometry from a path shape.\n *\n * parameters = {\n *\n *  curveSegments: <int>, // number of points on the curves\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n *  depth: <float>, // Depth to extrude the shape\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\n *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel\n *  bevelOffset: <float>, // how far from shape outline does bevel start\n *  bevelSegments: <int>, // number of bevel layers\n *\n *  extrudePath: <THREE.Curve> // curve to extrude shape along\n *\n *  UVGenerator: <Object> // object that provides UV generator functions\n *\n * }\n */\n\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport * as Curves from '../extras/curves/Curves.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Shape } from '../extras/core/Shape.js';\nimport { ShapeUtils } from '../extras/ShapeUtils.js';\nclass ExtrudeGeometry extends BufferGeometry {\n  constructor() {\n    let shapes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Shape([new Vector2(0.5, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]);\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    this.type = 'ExtrudeGeometry';\n    this.parameters = {\n      shapes: shapes,\n      options: options\n    };\n    shapes = Array.isArray(shapes) ? shapes : [shapes];\n    const scope = this;\n    const verticesArray = [];\n    const uvArray = [];\n    for (let i = 0, l = shapes.length; i < l; i++) {\n      const shape = shapes[i];\n      addShape(shape);\n    }\n\n    // build geometry\n\n    this.setAttribute('position', new Float32BufferAttribute(verticesArray, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));\n    this.computeVertexNormals();\n\n    // functions\n\n    function addShape(shape) {\n      const placeholder = [];\n\n      // options\n\n      const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n      const steps = options.steps !== undefined ? options.steps : 1;\n      const depth = options.depth !== undefined ? options.depth : 1;\n      let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;\n      let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 0.2;\n      let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 0.1;\n      let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;\n      let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n      const extrudePath = options.extrudePath;\n      const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;\n\n      //\n\n      let extrudePts,\n        extrudeByPath = false;\n      let splineTube, binormal, normal, position2;\n      if (extrudePath) {\n        extrudePts = extrudePath.getSpacedPoints(steps);\n        extrudeByPath = true;\n        bevelEnabled = false; // bevels not supported for path extrusion\n\n        // SETUP TNB variables\n\n        // TODO1 - have a .isClosed in spline?\n\n        splineTube = extrudePath.computeFrenetFrames(steps, false);\n\n        // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n        binormal = new Vector3();\n        normal = new Vector3();\n        position2 = new Vector3();\n      }\n\n      // Safeguards if bevels are not enabled\n\n      if (!bevelEnabled) {\n        bevelSegments = 0;\n        bevelThickness = 0;\n        bevelSize = 0;\n        bevelOffset = 0;\n      }\n\n      // Variables initialization\n\n      const shapePoints = shape.extractPoints(curveSegments);\n      let vertices = shapePoints.shape;\n      const holes = shapePoints.holes;\n      const reverse = !ShapeUtils.isClockWise(vertices);\n      if (reverse) {\n        vertices = vertices.reverse();\n\n        // Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n        for (let h = 0, hl = holes.length; h < hl; h++) {\n          const ahole = holes[h];\n          if (ShapeUtils.isClockWise(ahole)) {\n            holes[h] = ahole.reverse();\n          }\n        }\n      }\n      const faces = ShapeUtils.triangulateShape(vertices, holes);\n\n      /* Vertices */\n\n      const contour = vertices; // vertices has all points but contour has only points of circumference\n\n      for (let h = 0, hl = holes.length; h < hl; h++) {\n        const ahole = holes[h];\n        vertices = vertices.concat(ahole);\n      }\n      function scalePt2(pt, vec, size) {\n        if (!vec) console.error('THREE.ExtrudeGeometry: vec does not exist');\n        return vec.clone().multiplyScalar(size).add(pt);\n      }\n      const vlen = vertices.length,\n        flen = faces.length;\n\n      // Find directions for point movement\n\n      function getBevelVec(inPt, inPrev, inNext) {\n        // computes for inPt the corresponding point inPt' on a new contour\n        //   shifted by 1 unit (length of normalized vector) to the left\n        // if we walk along contour clockwise, this new contour is outside the old one\n        //\n        // inPt' is the intersection of the two lines parallel to the two\n        //  adjacent edges of inPt at a distance of 1 unit on the left side.\n\n        let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\n\n        // good reading for geometry algorithms (here: line-line intersection)\n        // http://geomalgorithms.com/a05-_intersect-1.html\n\n        const v_prev_x = inPt.x - inPrev.x,\n          v_prev_y = inPt.y - inPrev.y;\n        const v_next_x = inNext.x - inPt.x,\n          v_next_y = inNext.y - inPt.y;\n        const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;\n\n        // check for collinear edges\n        const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;\n        if (Math.abs(collinear0) > Number.EPSILON) {\n          // not collinear\n\n          // length of vectors for normalizing\n\n          const v_prev_len = Math.sqrt(v_prev_lensq);\n          const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);\n\n          // shift adjacent points by unit vectors to the left\n\n          const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;\n          const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;\n          const ptNextShift_x = inNext.x - v_next_y / v_next_len;\n          const ptNextShift_y = inNext.y + v_next_x / v_next_len;\n\n          // scaling factor for v_prev to intersection point\n\n          const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);\n\n          // vector from inPt to intersection point\n\n          v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;\n          v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;\n\n          // Don't normalize!, otherwise sharp corners become ugly\n          //  but prevent crazy spikes\n          const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;\n          if (v_trans_lensq <= 2) {\n            return new Vector2(v_trans_x, v_trans_y);\n          } else {\n            shrink_by = Math.sqrt(v_trans_lensq / 2);\n          }\n        } else {\n          // handle special case of collinear edges\n\n          let direction_eq = false; // assumes: opposite\n\n          if (v_prev_x > Number.EPSILON) {\n            if (v_next_x > Number.EPSILON) {\n              direction_eq = true;\n            }\n          } else {\n            if (v_prev_x < -Number.EPSILON) {\n              if (v_next_x < -Number.EPSILON) {\n                direction_eq = true;\n              }\n            } else {\n              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {\n                direction_eq = true;\n              }\n            }\n          }\n          if (direction_eq) {\n            // console.log(\"Warning: lines are a straight sequence\");\n            v_trans_x = -v_prev_y;\n            v_trans_y = v_prev_x;\n            shrink_by = Math.sqrt(v_prev_lensq);\n          } else {\n            // console.log(\"Warning: lines are a straight spike\");\n            v_trans_x = v_prev_x;\n            v_trans_y = v_prev_y;\n            shrink_by = Math.sqrt(v_prev_lensq / 2);\n          }\n        }\n        return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);\n      }\n      const contourMovements = [];\n      for (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {\n        if (j === il) j = 0;\n        if (k === il) k = 0;\n\n        //  (j)---(i)---(k)\n        // console.log('i,j,k', i, j , k)\n\n        contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);\n      }\n      const holesMovements = [];\n      let oneHoleMovements,\n        verticesMovements = contourMovements.concat();\n      for (let h = 0, hl = holes.length; h < hl; h++) {\n        const ahole = holes[h];\n        oneHoleMovements = [];\n        for (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {\n          if (j === il) j = 0;\n          if (k === il) k = 0;\n\n          //  (j)---(i)---(k)\n          oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);\n        }\n        holesMovements.push(oneHoleMovements);\n        verticesMovements = verticesMovements.concat(oneHoleMovements);\n      }\n\n      // Loop bevelSegments, 1 for the front, 1 for the back\n\n      for (let b = 0; b < bevelSegments; b++) {\n        //for ( b = bevelSegments; b > 0; b -- ) {\n\n        const t = b / bevelSegments;\n        const z = bevelThickness * Math.cos(t * Math.PI / 2);\n        const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;\n\n        // contract shape\n\n        for (let i = 0, il = contour.length; i < il; i++) {\n          const vert = scalePt2(contour[i], contourMovements[i], bs);\n          v(vert.x, vert.y, -z);\n        }\n\n        // expand holes\n\n        for (let h = 0, hl = holes.length; h < hl; h++) {\n          const ahole = holes[h];\n          oneHoleMovements = holesMovements[h];\n          for (let i = 0, il = ahole.length; i < il; i++) {\n            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);\n            v(vert.x, vert.y, -z);\n          }\n        }\n      }\n      const bs = bevelSize + bevelOffset;\n\n      // Back facing vertices\n\n      for (let i = 0; i < vlen; i++) {\n        const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];\n        if (!extrudeByPath) {\n          v(vert.x, vert.y, 0);\n        } else {\n          // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\n          normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);\n          binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);\n          position2.copy(extrudePts[0]).add(normal).add(binormal);\n          v(position2.x, position2.y, position2.z);\n        }\n      }\n\n      // Add stepped vertices...\n      // Including front facing vertices\n\n      for (let s = 1; s <= steps; s++) {\n        for (let i = 0; i < vlen; i++) {\n          const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];\n          if (!extrudeByPath) {\n            v(vert.x, vert.y, depth / steps * s);\n          } else {\n            // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\n            normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);\n            binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);\n            position2.copy(extrudePts[s]).add(normal).add(binormal);\n            v(position2.x, position2.y, position2.z);\n          }\n        }\n      }\n\n      // Add bevel segments planes\n\n      //for ( b = 1; b <= bevelSegments; b ++ ) {\n      for (let b = bevelSegments - 1; b >= 0; b--) {\n        const t = b / bevelSegments;\n        const z = bevelThickness * Math.cos(t * Math.PI / 2);\n        const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;\n\n        // contract shape\n\n        for (let i = 0, il = contour.length; i < il; i++) {\n          const vert = scalePt2(contour[i], contourMovements[i], bs);\n          v(vert.x, vert.y, depth + z);\n        }\n\n        // expand holes\n\n        for (let h = 0, hl = holes.length; h < hl; h++) {\n          const ahole = holes[h];\n          oneHoleMovements = holesMovements[h];\n          for (let i = 0, il = ahole.length; i < il; i++) {\n            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);\n            if (!extrudeByPath) {\n              v(vert.x, vert.y, depth + z);\n            } else {\n              v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);\n            }\n          }\n        }\n      }\n\n      /* Faces */\n\n      // Top and bottom faces\n\n      buildLidFaces();\n\n      // Sides faces\n\n      buildSideFaces();\n\n      /////  Internal functions\n\n      function buildLidFaces() {\n        const start = verticesArray.length / 3;\n        if (bevelEnabled) {\n          let layer = 0; // steps + 1\n          let offset = vlen * layer;\n\n          // Bottom faces\n\n          for (let i = 0; i < flen; i++) {\n            const face = faces[i];\n            f3(face[2] + offset, face[1] + offset, face[0] + offset);\n          }\n          layer = steps + bevelSegments * 2;\n          offset = vlen * layer;\n\n          // Top faces\n\n          for (let i = 0; i < flen; i++) {\n            const face = faces[i];\n            f3(face[0] + offset, face[1] + offset, face[2] + offset);\n          }\n        } else {\n          // Bottom faces\n\n          for (let i = 0; i < flen; i++) {\n            const face = faces[i];\n            f3(face[2], face[1], face[0]);\n          }\n\n          // Top faces\n\n          for (let i = 0; i < flen; i++) {\n            const face = faces[i];\n            f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);\n          }\n        }\n        scope.addGroup(start, verticesArray.length / 3 - start, 0);\n      }\n\n      // Create faces for the z-sides of the shape\n\n      function buildSideFaces() {\n        const start = verticesArray.length / 3;\n        let layeroffset = 0;\n        sidewalls(contour, layeroffset);\n        layeroffset += contour.length;\n        for (let h = 0, hl = holes.length; h < hl; h++) {\n          const ahole = holes[h];\n          sidewalls(ahole, layeroffset);\n\n          //, true\n          layeroffset += ahole.length;\n        }\n        scope.addGroup(start, verticesArray.length / 3 - start, 1);\n      }\n      function sidewalls(contour, layeroffset) {\n        let i = contour.length;\n        while (--i >= 0) {\n          const j = i;\n          let k = i - 1;\n          if (k < 0) k = contour.length - 1;\n\n          //console.log('b', i,j, i-1, k,vertices.length);\n\n          for (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {\n            const slen1 = vlen * s;\n            const slen2 = vlen * (s + 1);\n            const a = layeroffset + j + slen1,\n              b = layeroffset + k + slen1,\n              c = layeroffset + k + slen2,\n              d = layeroffset + j + slen2;\n            f4(a, b, c, d);\n          }\n        }\n      }\n      function v(x, y, z) {\n        placeholder.push(x);\n        placeholder.push(y);\n        placeholder.push(z);\n      }\n      function f3(a, b, c) {\n        addVertex(a);\n        addVertex(b);\n        addVertex(c);\n        const nextIndex = verticesArray.length / 3;\n        const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);\n        addUV(uvs[0]);\n        addUV(uvs[1]);\n        addUV(uvs[2]);\n      }\n      function f4(a, b, c, d) {\n        addVertex(a);\n        addVertex(b);\n        addVertex(d);\n        addVertex(b);\n        addVertex(c);\n        addVertex(d);\n        const nextIndex = verticesArray.length / 3;\n        const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);\n        addUV(uvs[0]);\n        addUV(uvs[1]);\n        addUV(uvs[3]);\n        addUV(uvs[1]);\n        addUV(uvs[2]);\n        addUV(uvs[3]);\n      }\n      function addVertex(index) {\n        verticesArray.push(placeholder[index * 3 + 0]);\n        verticesArray.push(placeholder[index * 3 + 1]);\n        verticesArray.push(placeholder[index * 3 + 2]);\n      }\n      function addUV(vector2) {\n        uvArray.push(vector2.x);\n        uvArray.push(vector2.y);\n      }\n    }\n  }\n  toJSON() {\n    const data = super.toJSON();\n    const shapes = this.parameters.shapes;\n    const options = this.parameters.options;\n    return toJSON(shapes, options, data);\n  }\n  static fromJSON(data, shapes) {\n    const geometryShapes = [];\n    for (let j = 0, jl = data.shapes.length; j < jl; j++) {\n      const shape = shapes[data.shapes[j]];\n      geometryShapes.push(shape);\n    }\n    const extrudePath = data.options.extrudePath;\n    if (extrudePath !== undefined) {\n      data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);\n    }\n    return new ExtrudeGeometry(geometryShapes, data.options);\n  }\n}\nconst WorldUVGenerator = {\n  generateTopUV: function (geometry, vertices, indexA, indexB, indexC) {\n    const a_x = vertices[indexA * 3];\n    const a_y = vertices[indexA * 3 + 1];\n    const b_x = vertices[indexB * 3];\n    const b_y = vertices[indexB * 3 + 1];\n    const c_x = vertices[indexC * 3];\n    const c_y = vertices[indexC * 3 + 1];\n    return [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];\n  },\n  generateSideWallUV: function (geometry, vertices, indexA, indexB, indexC, indexD) {\n    const a_x = vertices[indexA * 3];\n    const a_y = vertices[indexA * 3 + 1];\n    const a_z = vertices[indexA * 3 + 2];\n    const b_x = vertices[indexB * 3];\n    const b_y = vertices[indexB * 3 + 1];\n    const b_z = vertices[indexB * 3 + 2];\n    const c_x = vertices[indexC * 3];\n    const c_y = vertices[indexC * 3 + 1];\n    const c_z = vertices[indexC * 3 + 2];\n    const d_x = vertices[indexD * 3];\n    const d_y = vertices[indexD * 3 + 1];\n    const d_z = vertices[indexD * 3 + 2];\n    if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {\n      return [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];\n    } else {\n      return [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];\n    }\n  }\n};\nfunction toJSON(shapes, options, data) {\n  data.shapes = [];\n  if (Array.isArray(shapes)) {\n    for (let i = 0, l = shapes.length; i < l; i++) {\n      const shape = shapes[i];\n      data.shapes.push(shape.uuid);\n    }\n  } else {\n    data.shapes.push(shapes.uuid);\n  }\n  data.options = Object.assign({}, options);\n  if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();\n  return data;\n}\nexport { ExtrudeGeometry };","map":{"version":3,"names":["BufferGeometry","Float32BufferAttribute","Curves","Vector2","Vector3","Shape","ShapeUtils","ExtrudeGeometry","constructor","shapes","options","type","parameters","Array","isArray","scope","verticesArray","uvArray","i","l","length","shape","addShape","setAttribute","computeVertexNormals","placeholder","curveSegments","undefined","steps","depth","bevelEnabled","bevelThickness","bevelSize","bevelOffset","bevelSegments","extrudePath","uvgen","UVGenerator","WorldUVGenerator","extrudePts","extrudeByPath","splineTube","binormal","normal","position2","getSpacedPoints","computeFrenetFrames","shapePoints","extractPoints","vertices","holes","reverse","isClockWise","h","hl","ahole","faces","triangulateShape","contour","concat","scalePt2","pt","vec","size","console","error","clone","multiplyScalar","add","vlen","flen","getBevelVec","inPt","inPrev","inNext","v_trans_x","v_trans_y","shrink_by","v_prev_x","x","v_prev_y","y","v_next_x","v_next_y","v_prev_lensq","collinear0","Math","abs","Number","EPSILON","v_prev_len","sqrt","v_next_len","ptPrevShift_x","ptPrevShift_y","ptNextShift_x","ptNextShift_y","sf","v_trans_lensq","direction_eq","sign","contourMovements","il","j","k","holesMovements","oneHoleMovements","verticesMovements","push","b","t","z","cos","PI","bs","sin","vert","v","copy","normals","binormals","s","buildLidFaces","buildSideFaces","start","layer","offset","face","f3","addGroup","layeroffset","sidewalls","sl","slen1","slen2","a","c","d","f4","addVertex","nextIndex","uvs","generateTopUV","addUV","generateSideWallUV","index","vector2","toJSON","data","fromJSON","geometryShapes","jl","geometry","indexA","indexB","indexC","a_x","a_y","b_x","b_y","c_x","c_y","indexD","a_z","b_z","c_z","d_x","d_y","d_z","uuid","Object","assign"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/geometries/ExtrudeGeometry.js"],"sourcesContent":["/**\n * Creates extruded geometry from a path shape.\n *\n * parameters = {\n *\n *  curveSegments: <int>, // number of points on the curves\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n *  depth: <float>, // Depth to extrude the shape\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\n *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel\n *  bevelOffset: <float>, // how far from shape outline does bevel start\n *  bevelSegments: <int>, // number of bevel layers\n *\n *  extrudePath: <THREE.Curve> // curve to extrude shape along\n *\n *  UVGenerator: <Object> // object that provides UV generator functions\n *\n * }\n */\n\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport * as Curves from '../extras/curves/Curves.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Shape } from '../extras/core/Shape.js';\nimport { ShapeUtils } from '../extras/ShapeUtils.js';\n\nclass ExtrudeGeometry extends BufferGeometry {\n\n\tconstructor( shapes = new Shape( [ new Vector2( 0.5, 0.5 ), new Vector2( - 0.5, 0.5 ), new Vector2( - 0.5, - 0.5 ), new Vector2( 0.5, - 0.5 ) ] ), options = {} ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'ExtrudeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tshapes: shapes,\n\t\t\toptions: options\n\t\t};\n\n\t\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\n\n\t\tconst scope = this;\n\n\t\tconst verticesArray = [];\n\t\tconst uvArray = [];\n\n\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tconst shape = shapes[ i ];\n\t\t\taddShape( shape );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );\n\n\t\tthis.computeVertexNormals();\n\n\t\t// functions\n\n\t\tfunction addShape( shape ) {\n\n\t\t\tconst placeholder = [];\n\n\t\t\t// options\n\n\t\t\tconst curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\t\t\tconst steps = options.steps !== undefined ? options.steps : 1;\n\t\t\tconst depth = options.depth !== undefined ? options.depth : 1;\n\n\t\t\tlet bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;\n\t\t\tlet bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 0.2;\n\t\t\tlet bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 0.1;\n\t\t\tlet bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;\n\t\t\tlet bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\n\t\t\tconst extrudePath = options.extrudePath;\n\n\t\t\tconst uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;\n\n\t\t\t//\n\n\t\t\tlet extrudePts, extrudeByPath = false;\n\t\t\tlet splineTube, binormal, normal, position2;\n\n\t\t\tif ( extrudePath ) {\n\n\t\t\t\textrudePts = extrudePath.getSpacedPoints( steps );\n\n\t\t\t\textrudeByPath = true;\n\t\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\n\t\t\t\t// SETUP TNB variables\n\n\t\t\t\t// TODO1 - have a .isClosed in spline?\n\n\t\t\t\tsplineTube = extrudePath.computeFrenetFrames( steps, false );\n\n\t\t\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n\t\t\t\tbinormal = new Vector3();\n\t\t\t\tnormal = new Vector3();\n\t\t\t\tposition2 = new Vector3();\n\n\t\t\t}\n\n\t\t\t// Safeguards if bevels are not enabled\n\n\t\t\tif ( ! bevelEnabled ) {\n\n\t\t\t\tbevelSegments = 0;\n\t\t\t\tbevelThickness = 0;\n\t\t\t\tbevelSize = 0;\n\t\t\t\tbevelOffset = 0;\n\n\t\t\t}\n\n\t\t\t// Variables initialization\n\n\t\t\tconst shapePoints = shape.extractPoints( curveSegments );\n\n\t\t\tlet vertices = shapePoints.shape;\n\t\t\tconst holes = shapePoints.holes;\n\n\t\t\tconst reverse = ! ShapeUtils.isClockWise( vertices );\n\n\t\t\tif ( reverse ) {\n\n\t\t\t\tvertices = vertices.reverse();\n\n\t\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\n\t\t\t\t\tif ( ShapeUtils.isClockWise( ahole ) ) {\n\n\t\t\t\t\t\tholes[ h ] = ahole.reverse();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tconst faces = ShapeUtils.triangulateShape( vertices, holes );\n\n\t\t\t/* Vertices */\n\n\t\t\tconst contour = vertices; // vertices has all points but contour has only points of circumference\n\n\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tconst ahole = holes[ h ];\n\n\t\t\t\tvertices = vertices.concat( ahole );\n\n\t\t\t}\n\n\n\t\t\tfunction scalePt2( pt, vec, size ) {\n\n\t\t\t\tif ( ! vec ) console.error( 'THREE.ExtrudeGeometry: vec does not exist' );\n\n\t\t\t\treturn vec.clone().multiplyScalar( size ).add( pt );\n\n\t\t\t}\n\n\t\t\tconst vlen = vertices.length, flen = faces.length;\n\n\n\t\t\t// Find directions for point movement\n\n\n\t\t\tfunction getBevelVec( inPt, inPrev, inNext ) {\n\n\t\t\t\t// computes for inPt the corresponding point inPt' on a new contour\n\t\t\t\t//   shifted by 1 unit (length of normalized vector) to the left\n\t\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\n\t\t\t\t//\n\t\t\t\t// inPt' is the intersection of the two lines parallel to the two\n\t\t\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\n\n\t\t\t\tlet v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\n\n\t\t\t\t// good reading for geometry algorithms (here: line-line intersection)\n\t\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\n\n\t\t\t\tconst v_prev_x = inPt.x - inPrev.x,\n\t\t\t\t\tv_prev_y = inPt.y - inPrev.y;\n\t\t\t\tconst v_next_x = inNext.x - inPt.x,\n\t\t\t\t\tv_next_y = inNext.y - inPt.y;\n\n\t\t\t\tconst v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\n\n\t\t\t\t// check for collinear edges\n\t\t\t\tconst collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\n\n\t\t\t\t\t// not collinear\n\n\t\t\t\t\t// length of vectors for normalizing\n\n\t\t\t\t\tconst v_prev_len = Math.sqrt( v_prev_lensq );\n\t\t\t\t\tconst v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\n\n\t\t\t\t\t// shift adjacent points by unit vectors to the left\n\n\t\t\t\t\tconst ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\n\t\t\t\t\tconst ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\n\n\t\t\t\t\tconst ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\n\t\t\t\t\tconst ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\n\n\t\t\t\t\t// scaling factor for v_prev to intersection point\n\n\t\t\t\t\tconst sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\n\t\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /\n\t\t\t\t\t\t( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\t\t\t// vector from inPt to intersection point\n\n\t\t\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\n\t\t\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\n\n\t\t\t\t\t// Don't normalize!, otherwise sharp corners become ugly\n\t\t\t\t\t//  but prevent crazy spikes\n\t\t\t\t\tconst v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\n\t\t\t\t\tif ( v_trans_lensq <= 2 ) {\n\n\t\t\t\t\t\treturn new Vector2( v_trans_x, v_trans_y );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// handle special case of collinear edges\n\n\t\t\t\t\tlet direction_eq = false; // assumes: opposite\n\n\t\t\t\t\tif ( v_prev_x > Number.EPSILON ) {\n\n\t\t\t\t\t\tif ( v_next_x > Number.EPSILON ) {\n\n\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\n\n\t\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( direction_eq ) {\n\n\t\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\n\t\t\t\t\t\tv_trans_x = - v_prev_y;\n\t\t\t\t\t\tv_trans_y = v_prev_x;\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\n\t\t\t\t\t\tv_trans_x = v_prev_x;\n\t\t\t\t\t\tv_trans_y = v_prev_y;\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\n\n\t\t\t}\n\n\n\t\t\tconst contourMovements = [];\n\n\t\t\tfor ( let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\tif ( k === il ) k = 0;\n\n\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\t// console.log('i,j,k', i, j , k)\n\n\t\t\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\n\n\t\t\t}\n\n\t\t\tconst holesMovements = [];\n\t\t\tlet oneHoleMovements, verticesMovements = contourMovements.concat();\n\n\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tconst ahole = holes[ h ];\n\n\t\t\t\toneHoleMovements = [];\n\n\t\t\t\tfor ( let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\t\tif ( k === il ) k = 0;\n\n\t\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\n\n\t\t\t\t}\n\n\t\t\t\tholesMovements.push( oneHoleMovements );\n\t\t\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\n\n\t\t\t}\n\n\n\t\t\t// Loop bevelSegments, 1 for the front, 1 for the back\n\n\t\t\tfor ( let b = 0; b < bevelSegments; b ++ ) {\n\n\t\t\t\t//for ( b = bevelSegments; b > 0; b -- ) {\n\n\t\t\t\tconst t = b / bevelSegments;\n\t\t\t\tconst z = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\t\tconst bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;\n\n\t\t\t\t// contract shape\n\n\t\t\t\tfor ( let i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst vert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\n\t\t\t\t\tv( vert.x, vert.y, - z );\n\n\t\t\t\t}\n\n\t\t\t\t// expand holes\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\t\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\t\tfor ( let i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tconst vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\t\tv( vert.x, vert.y, - z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst bs = bevelSize + bevelOffset;\n\n\t\t\t// Back facing vertices\n\n\t\t\tfor ( let i = 0; i < vlen; i ++ ) {\n\n\t\t\t\tconst vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\tv( vert.x, vert.y, 0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\n\t\t\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\n\t\t\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\n\n\t\t\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\n\n\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Add stepped vertices...\n\t\t\t// Including front facing vertices\n\n\t\t\tfor ( let s = 1; s <= steps; s ++ ) {\n\n\t\t\t\tfor ( let i = 0; i < vlen; i ++ ) {\n\n\t\t\t\t\tconst vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\t\tv( vert.x, vert.y, depth / steps * s );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\n\t\t\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\n\t\t\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\n\n\t\t\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\n\n\t\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// Add bevel segments planes\n\n\t\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\t\t\tfor ( let b = bevelSegments - 1; b >= 0; b -- ) {\n\n\t\t\t\tconst t = b / bevelSegments;\n\t\t\t\tconst z = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\t\tconst bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;\n\n\t\t\t\t// contract shape\n\n\t\t\t\tfor ( let i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst vert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\t\t\tv( vert.x, vert.y, depth + z );\n\n\t\t\t\t}\n\n\t\t\t\t// expand holes\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\t\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\t\tfor ( let i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tconst vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\t\t\tv( vert.x, vert.y, depth + z );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/* Faces */\n\n\t\t\t// Top and bottom faces\n\n\t\t\tbuildLidFaces();\n\n\t\t\t// Sides faces\n\n\t\t\tbuildSideFaces();\n\n\n\t\t\t/////  Internal functions\n\n\t\t\tfunction buildLidFaces() {\n\n\t\t\t\tconst start = verticesArray.length / 3;\n\n\t\t\t\tif ( bevelEnabled ) {\n\n\t\t\t\t\tlet layer = 0; // steps + 1\n\t\t\t\t\tlet offset = vlen * layer;\n\n\t\t\t\t\t// Bottom faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\t\t\toffset = vlen * layer;\n\n\t\t\t\t\t// Top faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Bottom faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Top faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, 0 );\n\n\t\t\t}\n\n\t\t\t// Create faces for the z-sides of the shape\n\n\t\t\tfunction buildSideFaces() {\n\n\t\t\t\tconst start = verticesArray.length / 3;\n\t\t\t\tlet layeroffset = 0;\n\t\t\t\tsidewalls( contour, layeroffset );\n\t\t\t\tlayeroffset += contour.length;\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\t\t\t\t\tsidewalls( ahole, layeroffset );\n\n\t\t\t\t\t//, true\n\t\t\t\t\tlayeroffset += ahole.length;\n\n\t\t\t\t}\n\n\n\t\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, 1 );\n\n\n\t\t\t}\n\n\t\t\tfunction sidewalls( contour, layeroffset ) {\n\n\t\t\t\tlet i = contour.length;\n\n\t\t\t\twhile ( -- i >= 0 ) {\n\n\t\t\t\t\tconst j = i;\n\t\t\t\t\tlet k = i - 1;\n\t\t\t\t\tif ( k < 0 ) k = contour.length - 1;\n\n\t\t\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\n\n\t\t\t\t\tfor ( let s = 0, sl = ( steps + bevelSegments * 2 ); s < sl; s ++ ) {\n\n\t\t\t\t\t\tconst slen1 = vlen * s;\n\t\t\t\t\t\tconst slen2 = vlen * ( s + 1 );\n\n\t\t\t\t\t\tconst a = layeroffset + j + slen1,\n\t\t\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\t\t\td = layeroffset + j + slen2;\n\n\t\t\t\t\t\tf4( a, b, c, d );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction v( x, y, z ) {\n\n\t\t\t\tplaceholder.push( x );\n\t\t\t\tplaceholder.push( y );\n\t\t\t\tplaceholder.push( z );\n\n\t\t\t}\n\n\n\t\t\tfunction f3( a, b, c ) {\n\n\t\t\t\taddVertex( a );\n\t\t\t\taddVertex( b );\n\t\t\t\taddVertex( c );\n\n\t\t\t\tconst nextIndex = verticesArray.length / 3;\n\t\t\t\tconst uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\n\n\t\t\t\taddUV( uvs[ 0 ] );\n\t\t\t\taddUV( uvs[ 1 ] );\n\t\t\t\taddUV( uvs[ 2 ] );\n\n\t\t\t}\n\n\t\t\tfunction f4( a, b, c, d ) {\n\n\t\t\t\taddVertex( a );\n\t\t\t\taddVertex( b );\n\t\t\t\taddVertex( d );\n\n\t\t\t\taddVertex( b );\n\t\t\t\taddVertex( c );\n\t\t\t\taddVertex( d );\n\n\n\t\t\t\tconst nextIndex = verticesArray.length / 3;\n\t\t\t\tconst uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\n\n\t\t\t\taddUV( uvs[ 0 ] );\n\t\t\t\taddUV( uvs[ 1 ] );\n\t\t\t\taddUV( uvs[ 3 ] );\n\n\t\t\t\taddUV( uvs[ 1 ] );\n\t\t\t\taddUV( uvs[ 2 ] );\n\t\t\t\taddUV( uvs[ 3 ] );\n\n\t\t\t}\n\n\t\t\tfunction addVertex( index ) {\n\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 0 ] );\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 1 ] );\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 2 ] );\n\n\t\t\t}\n\n\n\t\t\tfunction addUV( vector2 ) {\n\n\t\t\t\tuvArray.push( vector2.x );\n\t\t\t\tuvArray.push( vector2.y );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tconst shapes = this.parameters.shapes;\n\t\tconst options = this.parameters.options;\n\n\t\treturn toJSON( shapes, options, data );\n\n\t}\n\n\tstatic fromJSON( data, shapes ) {\n\n\t\tconst geometryShapes = [];\n\n\t\tfor ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {\n\n\t\t\tconst shape = shapes[ data.shapes[ j ] ];\n\n\t\t\tgeometryShapes.push( shape );\n\n\t\t}\n\n\t\tconst extrudePath = data.options.extrudePath;\n\n\t\tif ( extrudePath !== undefined ) {\n\n\t\t\tdata.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );\n\n\t\t}\n\n\t\treturn new ExtrudeGeometry( geometryShapes, data.options );\n\n\t}\n\n}\n\nconst WorldUVGenerator = {\n\n\tgenerateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {\n\n\t\tconst a_x = vertices[ indexA * 3 ];\n\t\tconst a_y = vertices[ indexA * 3 + 1 ];\n\t\tconst b_x = vertices[ indexB * 3 ];\n\t\tconst b_y = vertices[ indexB * 3 + 1 ];\n\t\tconst c_x = vertices[ indexC * 3 ];\n\t\tconst c_y = vertices[ indexC * 3 + 1 ];\n\n\t\treturn [\n\t\t\tnew Vector2( a_x, a_y ),\n\t\t\tnew Vector2( b_x, b_y ),\n\t\t\tnew Vector2( c_x, c_y )\n\t\t];\n\n\t},\n\n\tgenerateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {\n\n\t\tconst a_x = vertices[ indexA * 3 ];\n\t\tconst a_y = vertices[ indexA * 3 + 1 ];\n\t\tconst a_z = vertices[ indexA * 3 + 2 ];\n\t\tconst b_x = vertices[ indexB * 3 ];\n\t\tconst b_y = vertices[ indexB * 3 + 1 ];\n\t\tconst b_z = vertices[ indexB * 3 + 2 ];\n\t\tconst c_x = vertices[ indexC * 3 ];\n\t\tconst c_y = vertices[ indexC * 3 + 1 ];\n\t\tconst c_z = vertices[ indexC * 3 + 2 ];\n\t\tconst d_x = vertices[ indexD * 3 ];\n\t\tconst d_y = vertices[ indexD * 3 + 1 ];\n\t\tconst d_z = vertices[ indexD * 3 + 2 ];\n\n\t\tif ( Math.abs( a_y - b_y ) < Math.abs( a_x - b_x ) ) {\n\n\t\t\treturn [\n\t\t\t\tnew Vector2( a_x, 1 - a_z ),\n\t\t\t\tnew Vector2( b_x, 1 - b_z ),\n\t\t\t\tnew Vector2( c_x, 1 - c_z ),\n\t\t\t\tnew Vector2( d_x, 1 - d_z )\n\t\t\t];\n\n\t\t} else {\n\n\t\t\treturn [\n\t\t\t\tnew Vector2( a_y, 1 - a_z ),\n\t\t\t\tnew Vector2( b_y, 1 - b_z ),\n\t\t\t\tnew Vector2( c_y, 1 - c_z ),\n\t\t\t\tnew Vector2( d_y, 1 - d_z )\n\t\t\t];\n\n\t\t}\n\n\t}\n\n};\n\nfunction toJSON( shapes, options, data ) {\n\n\tdata.shapes = [];\n\n\tif ( Array.isArray( shapes ) ) {\n\n\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tconst shape = shapes[ i ];\n\n\t\t\tdata.shapes.push( shape.uuid );\n\n\t\t}\n\n\t} else {\n\n\t\tdata.shapes.push( shapes.uuid );\n\n\t}\n\n\tdata.options = Object.assign( {}, options );\n\n\tif ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();\n\n\treturn data;\n\n}\n\n\nexport { ExtrudeGeometry };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}