{"ast":null,"code":"import { Curve } from './Curve.js';\nimport * as Curves from '../curves/Curves.js';\n\n/**************************************************************\n *\tCurved Path - a curve path is simply a array of connected\n *  curves, but retains the api of a curve\n **************************************************************/\n\nclass CurvePath extends Curve {\n  constructor() {\n    super();\n    this.type = 'CurvePath';\n    this.curves = [];\n    this.autoClose = false; // Automatically closes the path\n  }\n\n  add(curve) {\n    this.curves.push(curve);\n  }\n  closePath() {\n    // Add a line curve if start and end of lines are not connected\n    const startPoint = this.curves[0].getPoint(0);\n    const endPoint = this.curves[this.curves.length - 1].getPoint(1);\n    if (!startPoint.equals(endPoint)) {\n      this.curves.push(new Curves['LineCurve'](endPoint, startPoint));\n    }\n  }\n\n  // To get accurate point with reference to\n  // entire path distance at time t,\n  // following has to be done:\n\n  // 1. Length of each sub path have to be known\n  // 2. Locate and identify type of curve\n  // 3. Get t for the curve\n  // 4. Return curve.getPointAt(t')\n\n  getPoint(t, optionalTarget) {\n    const d = t * this.getLength();\n    const curveLengths = this.getCurveLengths();\n    let i = 0;\n\n    // To think about boundaries points.\n\n    while (i < curveLengths.length) {\n      if (curveLengths[i] >= d) {\n        const diff = curveLengths[i] - d;\n        const curve = this.curves[i];\n        const segmentLength = curve.getLength();\n        const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n        return curve.getPointAt(u, optionalTarget);\n      }\n      i++;\n    }\n    return null;\n\n    // loop where sum != 0, sum > d , sum+1 <d\n  }\n\n  // We cannot use the default THREE.Curve getPoint() with getLength() because in\n  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n  // getPoint() depends on getLength\n\n  getLength() {\n    const lens = this.getCurveLengths();\n    return lens[lens.length - 1];\n  }\n\n  // cacheLengths must be recalculated.\n  updateArcLengths() {\n    this.needsUpdate = true;\n    this.cacheLengths = null;\n    this.getCurveLengths();\n  }\n\n  // Compute lengths and cache them\n  // We cannot overwrite getLengths() because UtoT mapping uses it.\n\n  getCurveLengths() {\n    // We use cache values if curves and cache array are same length\n\n    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {\n      return this.cacheLengths;\n    }\n\n    // Get length of sub-curve\n    // Push sums into cached array\n\n    const lengths = [];\n    let sums = 0;\n    for (let i = 0, l = this.curves.length; i < l; i++) {\n      sums += this.curves[i].getLength();\n      lengths.push(sums);\n    }\n    this.cacheLengths = lengths;\n    return lengths;\n  }\n  getSpacedPoints() {\n    let divisions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 40;\n    const points = [];\n    for (let i = 0; i <= divisions; i++) {\n      points.push(this.getPoint(i / divisions));\n    }\n    if (this.autoClose) {\n      points.push(points[0]);\n    }\n    return points;\n  }\n  getPoints() {\n    let divisions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 12;\n    const points = [];\n    let last;\n    for (let i = 0, curves = this.curves; i < curves.length; i++) {\n      const curve = curves[i];\n      const resolution = curve.isEllipseCurve ? divisions * 2 : curve.isLineCurve || curve.isLineCurve3 ? 1 : curve.isSplineCurve ? divisions * curve.points.length : divisions;\n      const pts = curve.getPoints(resolution);\n      for (let j = 0; j < pts.length; j++) {\n        const point = pts[j];\n        if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates\n\n        points.push(point);\n        last = point;\n      }\n    }\n    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {\n      points.push(points[0]);\n    }\n    return points;\n  }\n  copy(source) {\n    super.copy(source);\n    this.curves = [];\n    for (let i = 0, l = source.curves.length; i < l; i++) {\n      const curve = source.curves[i];\n      this.curves.push(curve.clone());\n    }\n    this.autoClose = source.autoClose;\n    return this;\n  }\n  toJSON() {\n    const data = super.toJSON();\n    data.autoClose = this.autoClose;\n    data.curves = [];\n    for (let i = 0, l = this.curves.length; i < l; i++) {\n      const curve = this.curves[i];\n      data.curves.push(curve.toJSON());\n    }\n    return data;\n  }\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.autoClose = json.autoClose;\n    this.curves = [];\n    for (let i = 0, l = json.curves.length; i < l; i++) {\n      const curve = json.curves[i];\n      this.curves.push(new Curves[curve.type]().fromJSON(curve));\n    }\n    return this;\n  }\n}\nexport { CurvePath };","map":{"version":3,"names":["Curve","Curves","CurvePath","constructor","type","curves","autoClose","add","curve","push","closePath","startPoint","getPoint","endPoint","length","equals","t","optionalTarget","d","getLength","curveLengths","getCurveLengths","i","diff","segmentLength","u","getPointAt","lens","updateArcLengths","needsUpdate","cacheLengths","lengths","sums","l","getSpacedPoints","divisions","points","getPoints","last","resolution","isEllipseCurve","isLineCurve","isLineCurve3","isSplineCurve","pts","j","point","copy","source","clone","toJSON","data","fromJSON","json"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/extras/core/CurvePath.js"],"sourcesContent":["import { Curve } from './Curve.js';\nimport * as Curves from '../curves/Curves.js';\n\n/**************************************************************\n *\tCurved Path - a curve path is simply a array of connected\n *  curves, but retains the api of a curve\n **************************************************************/\n\nclass CurvePath extends Curve {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.type = 'CurvePath';\n\n\t\tthis.curves = [];\n\t\tthis.autoClose = false; // Automatically closes the path\n\n\t}\n\n\tadd( curve ) {\n\n\t\tthis.curves.push( curve );\n\n\t}\n\n\tclosePath() {\n\n\t\t// Add a line curve if start and end of lines are not connected\n\t\tconst startPoint = this.curves[ 0 ].getPoint( 0 );\n\t\tconst endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\n\n\t\tif ( ! startPoint.equals( endPoint ) ) {\n\n\t\t\tthis.curves.push( new Curves[ 'LineCurve' ]( endPoint, startPoint ) );\n\n\t\t}\n\n\t}\n\n\t// To get accurate point with reference to\n\t// entire path distance at time t,\n\t// following has to be done:\n\n\t// 1. Length of each sub path have to be known\n\t// 2. Locate and identify type of curve\n\t// 3. Get t for the curve\n\t// 4. Return curve.getPointAt(t')\n\n\tgetPoint( t, optionalTarget ) {\n\n\t\tconst d = t * this.getLength();\n\t\tconst curveLengths = this.getCurveLengths();\n\t\tlet i = 0;\n\n\t\t// To think about boundaries points.\n\n\t\twhile ( i < curveLengths.length ) {\n\n\t\t\tif ( curveLengths[ i ] >= d ) {\n\n\t\t\t\tconst diff = curveLengths[ i ] - d;\n\t\t\t\tconst curve = this.curves[ i ];\n\n\t\t\t\tconst segmentLength = curve.getLength();\n\t\t\t\tconst u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n\n\t\t\t\treturn curve.getPointAt( u, optionalTarget );\n\n\t\t\t}\n\n\t\t\ti ++;\n\n\t\t}\n\n\t\treturn null;\n\n\t\t// loop where sum != 0, sum > d , sum+1 <d\n\n\t}\n\n\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\n\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n\t// getPoint() depends on getLength\n\n\tgetLength() {\n\n\t\tconst lens = this.getCurveLengths();\n\t\treturn lens[ lens.length - 1 ];\n\n\t}\n\n\t// cacheLengths must be recalculated.\n\tupdateArcLengths() {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.cacheLengths = null;\n\t\tthis.getCurveLengths();\n\n\t}\n\n\t// Compute lengths and cache them\n\t// We cannot overwrite getLengths() because UtoT mapping uses it.\n\n\tgetCurveLengths() {\n\n\t\t// We use cache values if curves and cache array are same length\n\n\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\n\n\t\t\treturn this.cacheLengths;\n\n\t\t}\n\n\t\t// Get length of sub-curve\n\t\t// Push sums into cached array\n\n\t\tconst lengths = [];\n\t\tlet sums = 0;\n\n\t\tfor ( let i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\tsums += this.curves[ i ].getLength();\n\t\t\tlengths.push( sums );\n\n\t\t}\n\n\t\tthis.cacheLengths = lengths;\n\n\t\treturn lengths;\n\n\t}\n\n\tgetSpacedPoints( divisions = 40 ) {\n\n\t\tconst points = [];\n\n\t\tfor ( let i = 0; i <= divisions; i ++ ) {\n\n\t\t\tpoints.push( this.getPoint( i / divisions ) );\n\n\t\t}\n\n\t\tif ( this.autoClose ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\tgetPoints( divisions = 12 ) {\n\n\t\tconst points = [];\n\t\tlet last;\n\n\t\tfor ( let i = 0, curves = this.curves; i < curves.length; i ++ ) {\n\n\t\t\tconst curve = curves[ i ];\n\t\t\tconst resolution = curve.isEllipseCurve ? divisions * 2\n\t\t\t\t: ( curve.isLineCurve || curve.isLineCurve3 ) ? 1\n\t\t\t\t\t: curve.isSplineCurve ? divisions * curve.points.length\n\t\t\t\t\t\t: divisions;\n\n\t\t\tconst pts = curve.getPoints( resolution );\n\n\t\t\tfor ( let j = 0; j < pts.length; j ++ ) {\n\n\t\t\t\tconst point = pts[ j ];\n\n\t\t\t\tif ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates\n\n\t\t\t\tpoints.push( point );\n\t\t\t\tlast = point;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.curves = [];\n\n\t\tfor ( let i = 0, l = source.curves.length; i < l; i ++ ) {\n\n\t\t\tconst curve = source.curves[ i ];\n\n\t\t\tthis.curves.push( curve.clone() );\n\n\t\t}\n\n\t\tthis.autoClose = source.autoClose;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.autoClose = this.autoClose;\n\t\tdata.curves = [];\n\n\t\tfor ( let i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\tconst curve = this.curves[ i ];\n\t\t\tdata.curves.push( curve.toJSON() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.autoClose = json.autoClose;\n\t\tthis.curves = [];\n\n\t\tfor ( let i = 0, l = json.curves.length; i < l; i ++ ) {\n\n\t\t\tconst curve = json.curves[ i ];\n\t\t\tthis.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\n\nexport { CurvePath };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}