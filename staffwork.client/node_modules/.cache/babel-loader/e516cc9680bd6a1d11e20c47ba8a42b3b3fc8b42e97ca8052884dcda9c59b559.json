{"ast":null,"code":"import { REVISION, BackSide, DoubleSide, FrontSide, RGBAFormat, HalfFloatType, FloatType, UnsignedByteType, LinearEncoding, NoToneMapping, LinearMipmapLinearFilter } from '../constants.js';\nimport { floorPowerOfTwo } from '../math/MathUtils.js';\nimport { Frustum } from '../math/Frustum.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector4 } from '../math/Vector4.js';\nimport { WebGLAnimation } from './webgl/WebGLAnimation.js';\nimport { WebGLAttributes } from './webgl/WebGLAttributes.js';\nimport { WebGLBackground } from './webgl/WebGLBackground.js';\nimport { WebGLBindingStates } from './webgl/WebGLBindingStates.js';\nimport { WebGLBufferRenderer } from './webgl/WebGLBufferRenderer.js';\nimport { WebGLCapabilities } from './webgl/WebGLCapabilities.js';\nimport { WebGLClipping } from './webgl/WebGLClipping.js';\nimport { WebGLCubeMaps } from './webgl/WebGLCubeMaps.js';\nimport { WebGLCubeUVMaps } from './webgl/WebGLCubeUVMaps.js';\nimport { WebGLExtensions } from './webgl/WebGLExtensions.js';\nimport { WebGLGeometries } from './webgl/WebGLGeometries.js';\nimport { WebGLIndexedBufferRenderer } from './webgl/WebGLIndexedBufferRenderer.js';\nimport { WebGLInfo } from './webgl/WebGLInfo.js';\nimport { WebGLMorphtargets } from './webgl/WebGLMorphtargets.js';\nimport { WebGLObjects } from './webgl/WebGLObjects.js';\nimport { WebGLPrograms } from './webgl/WebGLPrograms.js';\nimport { WebGLProperties } from './webgl/WebGLProperties.js';\nimport { WebGLRenderLists } from './webgl/WebGLRenderLists.js';\nimport { WebGLRenderStates } from './webgl/WebGLRenderStates.js';\nimport { WebGLRenderTarget } from './WebGLRenderTarget.js';\nimport { WebGLShadowMap } from './webgl/WebGLShadowMap.js';\nimport { WebGLState } from './webgl/WebGLState.js';\nimport { WebGLTextures } from './webgl/WebGLTextures.js';\nimport { WebGLUniforms } from './webgl/WebGLUniforms.js';\nimport { WebGLUtils } from './webgl/WebGLUtils.js';\nimport { WebXRManager } from './webxr/WebXRManager.js';\nimport { WebGLMaterials } from './webgl/WebGLMaterials.js';\nimport { WebGLUniformsGroups } from './webgl/WebGLUniformsGroups.js';\nimport { createElementNS } from '../utils.js';\nfunction createCanvasElement() {\n  const canvas = createElementNS('canvas');\n  canvas.style.display = 'block';\n  return canvas;\n}\nfunction WebGLRenderer() {\n  let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  this.isWebGLRenderer = true;\n  const _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),\n    _context = parameters.context !== undefined ? parameters.context : null,\n    _depth = parameters.depth !== undefined ? parameters.depth : true,\n    _stencil = parameters.stencil !== undefined ? parameters.stencil : true,\n    _antialias = parameters.antialias !== undefined ? parameters.antialias : false,\n    _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\n    _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,\n    _powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',\n    _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;\n  let _alpha;\n  if (_context !== null) {\n    _alpha = _context.getContextAttributes().alpha;\n  } else {\n    _alpha = parameters.alpha !== undefined ? parameters.alpha : false;\n  }\n  let currentRenderList = null;\n  let currentRenderState = null;\n\n  // render() can be called from within a callback triggered by another render.\n  // We track this so that the nested render call gets its list and state isolated from the parent render call.\n\n  const renderListStack = [];\n  const renderStateStack = [];\n\n  // public properties\n\n  this.domElement = _canvas;\n\n  // Debug configuration container\n  this.debug = {\n    /**\n     * Enables error checking and reporting when shader programs are being compiled\n     * @type {boolean}\n     */\n    checkShaderErrors: true\n  };\n\n  // clearing\n\n  this.autoClear = true;\n  this.autoClearColor = true;\n  this.autoClearDepth = true;\n  this.autoClearStencil = true;\n\n  // scene graph\n\n  this.sortObjects = true;\n\n  // user-defined clipping\n\n  this.clippingPlanes = [];\n  this.localClippingEnabled = false;\n\n  // physically based shading\n\n  this.outputEncoding = LinearEncoding;\n\n  // physical lights\n\n  this.physicallyCorrectLights = false;\n\n  // tone mapping\n\n  this.toneMapping = NoToneMapping;\n  this.toneMappingExposure = 1.0;\n\n  // internal properties\n\n  const _this = this;\n  let _isContextLost = false;\n\n  // internal state cache\n\n  let _currentActiveCubeFace = 0;\n  let _currentActiveMipmapLevel = 0;\n  let _currentRenderTarget = null;\n  let _currentMaterialId = -1;\n  let _currentCamera = null;\n  const _currentViewport = new Vector4();\n  const _currentScissor = new Vector4();\n  let _currentScissorTest = null;\n\n  //\n\n  let _width = _canvas.width;\n  let _height = _canvas.height;\n  let _pixelRatio = 1;\n  let _opaqueSort = null;\n  let _transparentSort = null;\n  const _viewport = new Vector4(0, 0, _width, _height);\n  const _scissor = new Vector4(0, 0, _width, _height);\n  let _scissorTest = false;\n\n  // frustum\n\n  const _frustum = new Frustum();\n\n  // clipping\n\n  let _clippingEnabled = false;\n  let _localClippingEnabled = false;\n\n  // transmission\n\n  let _transmissionRenderTarget = null;\n\n  // camera matrices cache\n\n  const _projScreenMatrix = new Matrix4();\n  const _vector2 = new Vector2();\n  const _vector3 = new Vector3();\n  const _emptyScene = {\n    background: null,\n    fog: null,\n    environment: null,\n    overrideMaterial: null,\n    isScene: true\n  };\n  function getTargetPixelRatio() {\n    return _currentRenderTarget === null ? _pixelRatio : 1;\n  }\n\n  // initialize\n\n  let _gl = _context;\n  function getContext(contextNames, contextAttributes) {\n    for (let i = 0; i < contextNames.length; i++) {\n      const contextName = contextNames[i];\n      const context = _canvas.getContext(contextName, contextAttributes);\n      if (context !== null) return context;\n    }\n    return null;\n  }\n  try {\n    const contextAttributes = {\n      alpha: true,\n      depth: _depth,\n      stencil: _stencil,\n      antialias: _antialias,\n      premultipliedAlpha: _premultipliedAlpha,\n      preserveDrawingBuffer: _preserveDrawingBuffer,\n      powerPreference: _powerPreference,\n      failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat\n    };\n\n    // OffscreenCanvas does not have setAttribute, see #22811\n    if ('setAttribute' in _canvas) _canvas.setAttribute('data-engine', `three.js r${REVISION}`);\n\n    // event listeners must be registered before WebGL context is created, see #12753\n    _canvas.addEventListener('webglcontextlost', onContextLost, false);\n    _canvas.addEventListener('webglcontextrestored', onContextRestore, false);\n    _canvas.addEventListener('webglcontextcreationerror', onContextCreationError, false);\n    if (_gl === null) {\n      const contextNames = ['webgl2', 'webgl', 'experimental-webgl'];\n      if (_this.isWebGL1Renderer === true) {\n        contextNames.shift();\n      }\n      _gl = getContext(contextNames, contextAttributes);\n      if (_gl === null) {\n        if (getContext(contextNames)) {\n          throw new Error('Error creating WebGL context with your selected attributes.');\n        } else {\n          throw new Error('Error creating WebGL context.');\n        }\n      }\n    }\n\n    // Some experimental-webgl implementations do not have getShaderPrecisionFormat\n\n    if (_gl.getShaderPrecisionFormat === undefined) {\n      _gl.getShaderPrecisionFormat = function () {\n        return {\n          'rangeMin': 1,\n          'rangeMax': 1,\n          'precision': 1\n        };\n      };\n    }\n  } catch (error) {\n    console.error('THREE.WebGLRenderer: ' + error.message);\n    throw error;\n  }\n  let extensions, capabilities, state, info;\n  let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;\n  let programCache, materials, renderLists, renderStates, clipping, shadowMap;\n  let background, morphtargets, bufferRenderer, indexedBufferRenderer;\n  let utils, bindingStates, uniformsGroups;\n  function initGLContext() {\n    extensions = new WebGLExtensions(_gl);\n    capabilities = new WebGLCapabilities(_gl, extensions, parameters);\n    extensions.init(capabilities);\n    utils = new WebGLUtils(_gl, extensions, capabilities);\n    state = new WebGLState(_gl, extensions, capabilities);\n    info = new WebGLInfo(_gl);\n    properties = new WebGLProperties();\n    textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);\n    cubemaps = new WebGLCubeMaps(_this);\n    cubeuvmaps = new WebGLCubeUVMaps(_this);\n    attributes = new WebGLAttributes(_gl, capabilities);\n    bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);\n    geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);\n    objects = new WebGLObjects(_gl, geometries, attributes, info);\n    morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);\n    clipping = new WebGLClipping(properties);\n    programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);\n    materials = new WebGLMaterials(_this, properties);\n    renderLists = new WebGLRenderLists();\n    renderStates = new WebGLRenderStates(extensions, capabilities);\n    background = new WebGLBackground(_this, cubemaps, cubeuvmaps, state, objects, _alpha, _premultipliedAlpha);\n    shadowMap = new WebGLShadowMap(_this, objects, capabilities);\n    uniformsGroups = new WebGLUniformsGroups(_gl, info, capabilities, state);\n    bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);\n    indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);\n    info.programs = programCache.programs;\n    _this.capabilities = capabilities;\n    _this.extensions = extensions;\n    _this.properties = properties;\n    _this.renderLists = renderLists;\n    _this.shadowMap = shadowMap;\n    _this.state = state;\n    _this.info = info;\n  }\n  initGLContext();\n\n  // xr\n\n  const xr = new WebXRManager(_this, _gl);\n  this.xr = xr;\n\n  // API\n\n  this.getContext = function () {\n    return _gl;\n  };\n  this.getContextAttributes = function () {\n    return _gl.getContextAttributes();\n  };\n  this.forceContextLoss = function () {\n    const extension = extensions.get('WEBGL_lose_context');\n    if (extension) extension.loseContext();\n  };\n  this.forceContextRestore = function () {\n    const extension = extensions.get('WEBGL_lose_context');\n    if (extension) extension.restoreContext();\n  };\n  this.getPixelRatio = function () {\n    return _pixelRatio;\n  };\n  this.setPixelRatio = function (value) {\n    if (value === undefined) return;\n    _pixelRatio = value;\n    this.setSize(_width, _height, false);\n  };\n  this.getSize = function (target) {\n    return target.set(_width, _height);\n  };\n  this.setSize = function (width, height, updateStyle) {\n    if (xr.isPresenting) {\n      console.warn('THREE.WebGLRenderer: Can\\'t change size while VR device is presenting.');\n      return;\n    }\n    _width = width;\n    _height = height;\n    _canvas.width = Math.floor(width * _pixelRatio);\n    _canvas.height = Math.floor(height * _pixelRatio);\n    if (updateStyle !== false) {\n      _canvas.style.width = width + 'px';\n      _canvas.style.height = height + 'px';\n    }\n    this.setViewport(0, 0, width, height);\n  };\n  this.getDrawingBufferSize = function (target) {\n    return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();\n  };\n  this.setDrawingBufferSize = function (width, height, pixelRatio) {\n    _width = width;\n    _height = height;\n    _pixelRatio = pixelRatio;\n    _canvas.width = Math.floor(width * pixelRatio);\n    _canvas.height = Math.floor(height * pixelRatio);\n    this.setViewport(0, 0, width, height);\n  };\n  this.getCurrentViewport = function (target) {\n    return target.copy(_currentViewport);\n  };\n  this.getViewport = function (target) {\n    return target.copy(_viewport);\n  };\n  this.setViewport = function (x, y, width, height) {\n    if (x.isVector4) {\n      _viewport.set(x.x, x.y, x.z, x.w);\n    } else {\n      _viewport.set(x, y, width, height);\n    }\n    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());\n  };\n  this.getScissor = function (target) {\n    return target.copy(_scissor);\n  };\n  this.setScissor = function (x, y, width, height) {\n    if (x.isVector4) {\n      _scissor.set(x.x, x.y, x.z, x.w);\n    } else {\n      _scissor.set(x, y, width, height);\n    }\n    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());\n  };\n  this.getScissorTest = function () {\n    return _scissorTest;\n  };\n  this.setScissorTest = function (boolean) {\n    state.setScissorTest(_scissorTest = boolean);\n  };\n  this.setOpaqueSort = function (method) {\n    _opaqueSort = method;\n  };\n  this.setTransparentSort = function (method) {\n    _transparentSort = method;\n  };\n\n  // Clearing\n\n  this.getClearColor = function (target) {\n    return target.copy(background.getClearColor());\n  };\n  this.setClearColor = function () {\n    background.setClearColor.apply(background, arguments);\n  };\n  this.getClearAlpha = function () {\n    return background.getClearAlpha();\n  };\n  this.setClearAlpha = function () {\n    background.setClearAlpha.apply(background, arguments);\n  };\n  this.clear = function () {\n    let color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let stencil = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let bits = 0;\n    if (color) bits |= _gl.COLOR_BUFFER_BIT;\n    if (depth) bits |= _gl.DEPTH_BUFFER_BIT;\n    if (stencil) bits |= _gl.STENCIL_BUFFER_BIT;\n    _gl.clear(bits);\n  };\n  this.clearColor = function () {\n    this.clear(true, false, false);\n  };\n  this.clearDepth = function () {\n    this.clear(false, true, false);\n  };\n  this.clearStencil = function () {\n    this.clear(false, false, true);\n  };\n\n  //\n\n  this.dispose = function () {\n    _canvas.removeEventListener('webglcontextlost', onContextLost, false);\n    _canvas.removeEventListener('webglcontextrestored', onContextRestore, false);\n    _canvas.removeEventListener('webglcontextcreationerror', onContextCreationError, false);\n    renderLists.dispose();\n    renderStates.dispose();\n    properties.dispose();\n    cubemaps.dispose();\n    cubeuvmaps.dispose();\n    objects.dispose();\n    bindingStates.dispose();\n    uniformsGroups.dispose();\n    programCache.dispose();\n    xr.dispose();\n    xr.removeEventListener('sessionstart', onXRSessionStart);\n    xr.removeEventListener('sessionend', onXRSessionEnd);\n    if (_transmissionRenderTarget) {\n      _transmissionRenderTarget.dispose();\n      _transmissionRenderTarget = null;\n    }\n    animation.stop();\n  };\n\n  // Events\n\n  function onContextLost(event) {\n    event.preventDefault();\n    console.log('THREE.WebGLRenderer: Context Lost.');\n    _isContextLost = true;\n  }\n  function onContextRestore( /* event */\n  ) {\n    console.log('THREE.WebGLRenderer: Context Restored.');\n    _isContextLost = false;\n    const infoAutoReset = info.autoReset;\n    const shadowMapEnabled = shadowMap.enabled;\n    const shadowMapAutoUpdate = shadowMap.autoUpdate;\n    const shadowMapNeedsUpdate = shadowMap.needsUpdate;\n    const shadowMapType = shadowMap.type;\n    initGLContext();\n    info.autoReset = infoAutoReset;\n    shadowMap.enabled = shadowMapEnabled;\n    shadowMap.autoUpdate = shadowMapAutoUpdate;\n    shadowMap.needsUpdate = shadowMapNeedsUpdate;\n    shadowMap.type = shadowMapType;\n  }\n  function onContextCreationError(event) {\n    console.error('THREE.WebGLRenderer: A WebGL context could not be created. Reason: ', event.statusMessage);\n  }\n  function onMaterialDispose(event) {\n    const material = event.target;\n    material.removeEventListener('dispose', onMaterialDispose);\n    deallocateMaterial(material);\n  }\n\n  // Buffer deallocation\n\n  function deallocateMaterial(material) {\n    releaseMaterialProgramReferences(material);\n    properties.remove(material);\n  }\n  function releaseMaterialProgramReferences(material) {\n    const programs = properties.get(material).programs;\n    if (programs !== undefined) {\n      programs.forEach(function (program) {\n        programCache.releaseProgram(program);\n      });\n      if (material.isShaderMaterial) {\n        programCache.releaseShaderCache(material);\n      }\n    }\n  }\n\n  // Buffer rendering\n\n  this.renderBufferDirect = function (camera, scene, geometry, material, object, group) {\n    if (scene === null) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)\n\n    const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;\n    const program = setProgram(camera, scene, geometry, material, object);\n    state.setMaterial(material, frontFaceCW);\n\n    //\n\n    let index = geometry.index;\n    let rangeFactor = 1;\n    if (material.wireframe === true) {\n      index = geometries.getWireframeAttribute(geometry);\n      rangeFactor = 2;\n    }\n\n    //\n\n    const drawRange = geometry.drawRange;\n    const position = geometry.attributes.position;\n    let drawStart = drawRange.start * rangeFactor;\n    let drawEnd = (drawRange.start + drawRange.count) * rangeFactor;\n    if (group !== null) {\n      drawStart = Math.max(drawStart, group.start * rangeFactor);\n      drawEnd = Math.min(drawEnd, (group.start + group.count) * rangeFactor);\n    }\n    if (index !== null) {\n      drawStart = Math.max(drawStart, 0);\n      drawEnd = Math.min(drawEnd, index.count);\n    } else if (position !== undefined && position !== null) {\n      drawStart = Math.max(drawStart, 0);\n      drawEnd = Math.min(drawEnd, position.count);\n    }\n    const drawCount = drawEnd - drawStart;\n    if (drawCount < 0 || drawCount === Infinity) return;\n\n    //\n\n    bindingStates.setup(object, material, program, geometry, index);\n    let attribute;\n    let renderer = bufferRenderer;\n    if (index !== null) {\n      attribute = attributes.get(index);\n      renderer = indexedBufferRenderer;\n      renderer.setIndex(attribute);\n    }\n\n    //\n\n    if (object.isMesh) {\n      if (material.wireframe === true) {\n        state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());\n        renderer.setMode(_gl.LINES);\n      } else {\n        renderer.setMode(_gl.TRIANGLES);\n      }\n    } else if (object.isLine) {\n      let lineWidth = material.linewidth;\n      if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material\n\n      state.setLineWidth(lineWidth * getTargetPixelRatio());\n      if (object.isLineSegments) {\n        renderer.setMode(_gl.LINES);\n      } else if (object.isLineLoop) {\n        renderer.setMode(_gl.LINE_LOOP);\n      } else {\n        renderer.setMode(_gl.LINE_STRIP);\n      }\n    } else if (object.isPoints) {\n      renderer.setMode(_gl.POINTS);\n    } else if (object.isSprite) {\n      renderer.setMode(_gl.TRIANGLES);\n    }\n    if (object.isInstancedMesh) {\n      renderer.renderInstances(drawStart, drawCount, object.count);\n    } else if (geometry.isInstancedBufferGeometry) {\n      const maxInstanceCount = geometry._maxInstanceCount !== undefined ? geometry._maxInstanceCount : Infinity;\n      const instanceCount = Math.min(geometry.instanceCount, maxInstanceCount);\n      renderer.renderInstances(drawStart, drawCount, instanceCount);\n    } else {\n      renderer.render(drawStart, drawCount);\n    }\n  };\n\n  // Compile\n\n  this.compile = function (scene, camera) {\n    function prepare(material, scene, object) {\n      if (material.transparent === true && material.side === DoubleSide) {\n        material.side = BackSide;\n        material.needsUpdate = true;\n        getProgram(material, scene, object);\n        material.side = FrontSide;\n        material.needsUpdate = true;\n        getProgram(material, scene, object);\n        material.side = DoubleSide;\n      } else {\n        getProgram(material, scene, object);\n      }\n    }\n    currentRenderState = renderStates.get(scene);\n    currentRenderState.init();\n    renderStateStack.push(currentRenderState);\n    scene.traverseVisible(function (object) {\n      if (object.isLight && object.layers.test(camera.layers)) {\n        currentRenderState.pushLight(object);\n        if (object.castShadow) {\n          currentRenderState.pushShadow(object);\n        }\n      }\n    });\n    currentRenderState.setupLights(_this.physicallyCorrectLights);\n    scene.traverse(function (object) {\n      const material = object.material;\n      if (material) {\n        if (Array.isArray(material)) {\n          for (let i = 0; i < material.length; i++) {\n            const material2 = material[i];\n            prepare(material2, scene, object);\n          }\n        } else {\n          prepare(material, scene, object);\n        }\n      }\n    });\n    renderStateStack.pop();\n    currentRenderState = null;\n  };\n\n  // Animation Loop\n\n  let onAnimationFrameCallback = null;\n  function onAnimationFrame(time) {\n    if (onAnimationFrameCallback) onAnimationFrameCallback(time);\n  }\n  function onXRSessionStart() {\n    animation.stop();\n  }\n  function onXRSessionEnd() {\n    animation.start();\n  }\n  const animation = new WebGLAnimation();\n  animation.setAnimationLoop(onAnimationFrame);\n  if (typeof self !== 'undefined') animation.setContext(self);\n  this.setAnimationLoop = function (callback) {\n    onAnimationFrameCallback = callback;\n    xr.setAnimationLoop(callback);\n    callback === null ? animation.stop() : animation.start();\n  };\n  xr.addEventListener('sessionstart', onXRSessionStart);\n  xr.addEventListener('sessionend', onXRSessionEnd);\n\n  // Rendering\n\n  this.render = function (scene, camera) {\n    if (camera !== undefined && camera.isCamera !== true) {\n      console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');\n      return;\n    }\n    if (_isContextLost === true) return;\n\n    // update scene graph\n\n    if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();\n\n    // update camera matrices and frustum\n\n    if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();\n    if (xr.enabled === true && xr.isPresenting === true) {\n      if (xr.cameraAutoUpdate === true) xr.updateCamera(camera);\n      camera = xr.getCamera(); // use XR camera for rendering\n    }\n\n    //\n    if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);\n    currentRenderState = renderStates.get(scene, renderStateStack.length);\n    currentRenderState.init();\n    renderStateStack.push(currentRenderState);\n    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);\n    _frustum.setFromProjectionMatrix(_projScreenMatrix);\n    _localClippingEnabled = this.localClippingEnabled;\n    _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);\n    currentRenderList = renderLists.get(scene, renderListStack.length);\n    currentRenderList.init();\n    renderListStack.push(currentRenderList);\n    projectObject(scene, camera, 0, _this.sortObjects);\n    currentRenderList.finish();\n    if (_this.sortObjects === true) {\n      currentRenderList.sort(_opaqueSort, _transparentSort);\n    }\n\n    //\n\n    if (_clippingEnabled === true) clipping.beginShadows();\n    const shadowsArray = currentRenderState.state.shadowsArray;\n    shadowMap.render(shadowsArray, scene, camera);\n    if (_clippingEnabled === true) clipping.endShadows();\n\n    //\n\n    if (this.info.autoReset === true) this.info.reset();\n\n    //\n\n    background.render(currentRenderList, scene);\n\n    // render scene\n\n    currentRenderState.setupLights(_this.physicallyCorrectLights);\n    if (camera.isArrayCamera) {\n      const cameras = camera.cameras;\n      for (let i = 0, l = cameras.length; i < l; i++) {\n        const camera2 = cameras[i];\n        renderScene(currentRenderList, scene, camera2, camera2.viewport);\n      }\n    } else {\n      renderScene(currentRenderList, scene, camera);\n    }\n\n    //\n\n    if (_currentRenderTarget !== null) {\n      // resolve multisample renderbuffers to a single-sample texture if necessary\n\n      textures.updateMultisampleRenderTarget(_currentRenderTarget);\n\n      // Generate mipmap if we're using any kind of mipmap filtering\n\n      textures.updateRenderTargetMipmap(_currentRenderTarget);\n    }\n\n    //\n\n    if (scene.isScene === true) scene.onAfterRender(_this, scene, camera);\n\n    // _gl.finish();\n\n    bindingStates.resetDefaultState();\n    _currentMaterialId = -1;\n    _currentCamera = null;\n    renderStateStack.pop();\n    if (renderStateStack.length > 0) {\n      currentRenderState = renderStateStack[renderStateStack.length - 1];\n    } else {\n      currentRenderState = null;\n    }\n    renderListStack.pop();\n    if (renderListStack.length > 0) {\n      currentRenderList = renderListStack[renderListStack.length - 1];\n    } else {\n      currentRenderList = null;\n    }\n  };\n  function projectObject(object, camera, groupOrder, sortObjects) {\n    if (object.visible === false) return;\n    const visible = object.layers.test(camera.layers);\n    if (visible) {\n      if (object.isGroup) {\n        groupOrder = object.renderOrder;\n      } else if (object.isLOD) {\n        if (object.autoUpdate === true) object.update(camera);\n      } else if (object.isLight) {\n        currentRenderState.pushLight(object);\n        if (object.castShadow) {\n          currentRenderState.pushShadow(object);\n        }\n      } else if (object.isSprite) {\n        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {\n          if (sortObjects) {\n            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);\n          }\n          const geometry = objects.update(object);\n          const material = object.material;\n          if (material.visible) {\n            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);\n          }\n        }\n      } else if (object.isMesh || object.isLine || object.isPoints) {\n        if (object.isSkinnedMesh) {\n          // update skeleton only once in a frame\n\n          if (object.skeleton.frame !== info.render.frame) {\n            object.skeleton.update();\n            object.skeleton.frame = info.render.frame;\n          }\n        }\n        if (!object.frustumCulled || _frustum.intersectsObject(object)) {\n          if (sortObjects) {\n            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);\n          }\n          const geometry = objects.update(object);\n          const material = object.material;\n          if (Array.isArray(material)) {\n            const groups = geometry.groups;\n            for (let i = 0, l = groups.length; i < l; i++) {\n              const group = groups[i];\n              const groupMaterial = material[group.materialIndex];\n              if (groupMaterial && groupMaterial.visible) {\n                currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);\n              }\n            }\n          } else if (material.visible) {\n            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);\n          }\n        }\n      }\n    }\n    const children = object.children;\n    for (let i = 0, l = children.length; i < l; i++) {\n      projectObject(children[i], camera, groupOrder, sortObjects);\n    }\n  }\n  function renderScene(currentRenderList, scene, camera, viewport) {\n    const opaqueObjects = currentRenderList.opaque;\n    const transmissiveObjects = currentRenderList.transmissive;\n    const transparentObjects = currentRenderList.transparent;\n    currentRenderState.setupLightsView(camera);\n    if (transmissiveObjects.length > 0) renderTransmissionPass(opaqueObjects, scene, camera);\n    if (viewport) state.viewport(_currentViewport.copy(viewport));\n    if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);\n    if (transmissiveObjects.length > 0) renderObjects(transmissiveObjects, scene, camera);\n    if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera);\n\n    // Ensure depth buffer writing is enabled so it can be cleared on next render\n\n    state.buffers.depth.setTest(true);\n    state.buffers.depth.setMask(true);\n    state.buffers.color.setMask(true);\n    state.setPolygonOffset(false);\n  }\n  function renderTransmissionPass(opaqueObjects, scene, camera) {\n    const isWebGL2 = capabilities.isWebGL2;\n    if (_transmissionRenderTarget === null) {\n      _transmissionRenderTarget = new WebGLRenderTarget(1, 1, {\n        generateMipmaps: true,\n        type: extensions.has('EXT_color_buffer_half_float') ? HalfFloatType : UnsignedByteType,\n        minFilter: LinearMipmapLinearFilter,\n        samples: isWebGL2 && _antialias === true ? 4 : 0\n      });\n    }\n    _this.getDrawingBufferSize(_vector2);\n    if (isWebGL2) {\n      _transmissionRenderTarget.setSize(_vector2.x, _vector2.y);\n    } else {\n      _transmissionRenderTarget.setSize(floorPowerOfTwo(_vector2.x), floorPowerOfTwo(_vector2.y));\n    }\n\n    //\n\n    const currentRenderTarget = _this.getRenderTarget();\n    _this.setRenderTarget(_transmissionRenderTarget);\n    _this.clear();\n\n    // Turn off the features which can affect the frag color for opaque objects pass.\n    // Otherwise they are applied twice in opaque objects pass and transmission objects pass.\n    const currentToneMapping = _this.toneMapping;\n    _this.toneMapping = NoToneMapping;\n    renderObjects(opaqueObjects, scene, camera);\n    _this.toneMapping = currentToneMapping;\n    textures.updateMultisampleRenderTarget(_transmissionRenderTarget);\n    textures.updateRenderTargetMipmap(_transmissionRenderTarget);\n    _this.setRenderTarget(currentRenderTarget);\n  }\n  function renderObjects(renderList, scene, camera) {\n    const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;\n    for (let i = 0, l = renderList.length; i < l; i++) {\n      const renderItem = renderList[i];\n      const object = renderItem.object;\n      const geometry = renderItem.geometry;\n      const material = overrideMaterial === null ? renderItem.material : overrideMaterial;\n      const group = renderItem.group;\n      if (object.layers.test(camera.layers)) {\n        renderObject(object, scene, camera, geometry, material, group);\n      }\n    }\n  }\n  function renderObject(object, scene, camera, geometry, material, group) {\n    object.onBeforeRender(_this, scene, camera, geometry, material, group);\n    object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);\n    object.normalMatrix.getNormalMatrix(object.modelViewMatrix);\n    material.onBeforeRender(_this, scene, camera, geometry, object, group);\n    if (material.transparent === true && material.side === DoubleSide) {\n      material.side = BackSide;\n      material.needsUpdate = true;\n      _this.renderBufferDirect(camera, scene, geometry, material, object, group);\n      material.side = FrontSide;\n      material.needsUpdate = true;\n      _this.renderBufferDirect(camera, scene, geometry, material, object, group);\n      material.side = DoubleSide;\n    } else {\n      _this.renderBufferDirect(camera, scene, geometry, material, object, group);\n    }\n    object.onAfterRender(_this, scene, camera, geometry, material, group);\n  }\n  function getProgram(material, scene, object) {\n    if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...\n\n    const materialProperties = properties.get(material);\n    const lights = currentRenderState.state.lights;\n    const shadowsArray = currentRenderState.state.shadowsArray;\n    const lightsStateVersion = lights.state.version;\n    const parameters = programCache.getParameters(material, lights.state, shadowsArray, scene, object);\n    const programCacheKey = programCache.getProgramCacheKey(parameters);\n    let programs = materialProperties.programs;\n\n    // always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change\n\n    materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;\n    materialProperties.fog = scene.fog;\n    materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);\n    if (programs === undefined) {\n      // new material\n\n      material.addEventListener('dispose', onMaterialDispose);\n      programs = new Map();\n      materialProperties.programs = programs;\n    }\n    let program = programs.get(programCacheKey);\n    if (program !== undefined) {\n      // early out if program and light state is identical\n\n      if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {\n        updateCommonMaterialProperties(material, parameters);\n        return program;\n      }\n    } else {\n      parameters.uniforms = programCache.getUniforms(material);\n      material.onBuild(object, parameters, _this);\n      material.onBeforeCompile(parameters, _this);\n      program = programCache.acquireProgram(parameters, programCacheKey);\n      programs.set(programCacheKey, program);\n      materialProperties.uniforms = parameters.uniforms;\n    }\n    const uniforms = materialProperties.uniforms;\n    if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {\n      uniforms.clippingPlanes = clipping.uniform;\n    }\n    updateCommonMaterialProperties(material, parameters);\n\n    // store the light setup it was created for\n\n    materialProperties.needsLights = materialNeedsLights(material);\n    materialProperties.lightsStateVersion = lightsStateVersion;\n    if (materialProperties.needsLights) {\n      // wire up the material to this renderer's lighting state\n\n      uniforms.ambientLightColor.value = lights.state.ambient;\n      uniforms.lightProbe.value = lights.state.probe;\n      uniforms.directionalLights.value = lights.state.directional;\n      uniforms.directionalLightShadows.value = lights.state.directionalShadow;\n      uniforms.spotLights.value = lights.state.spot;\n      uniforms.spotLightShadows.value = lights.state.spotShadow;\n      uniforms.rectAreaLights.value = lights.state.rectArea;\n      uniforms.ltc_1.value = lights.state.rectAreaLTC1;\n      uniforms.ltc_2.value = lights.state.rectAreaLTC2;\n      uniforms.pointLights.value = lights.state.point;\n      uniforms.pointLightShadows.value = lights.state.pointShadow;\n      uniforms.hemisphereLights.value = lights.state.hemi;\n      uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;\n      uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;\n      uniforms.spotShadowMap.value = lights.state.spotShadowMap;\n      uniforms.spotLightMatrix.value = lights.state.spotLightMatrix;\n      uniforms.spotLightMap.value = lights.state.spotLightMap;\n      uniforms.pointShadowMap.value = lights.state.pointShadowMap;\n      uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;\n      // TODO (abelnation): add area lights shadow info to uniforms\n    }\n\n    const progUniforms = program.getUniforms();\n    const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);\n    materialProperties.currentProgram = program;\n    materialProperties.uniformsList = uniformsList;\n    return program;\n  }\n  function updateCommonMaterialProperties(material, parameters) {\n    const materialProperties = properties.get(material);\n    materialProperties.outputEncoding = parameters.outputEncoding;\n    materialProperties.instancing = parameters.instancing;\n    materialProperties.skinning = parameters.skinning;\n    materialProperties.morphTargets = parameters.morphTargets;\n    materialProperties.morphNormals = parameters.morphNormals;\n    materialProperties.morphColors = parameters.morphColors;\n    materialProperties.morphTargetsCount = parameters.morphTargetsCount;\n    materialProperties.numClippingPlanes = parameters.numClippingPlanes;\n    materialProperties.numIntersection = parameters.numClipIntersection;\n    materialProperties.vertexAlphas = parameters.vertexAlphas;\n    materialProperties.vertexTangents = parameters.vertexTangents;\n    materialProperties.toneMapping = parameters.toneMapping;\n  }\n  function setProgram(camera, scene, geometry, material, object) {\n    if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...\n\n    textures.resetTextureUnits();\n    const fog = scene.fog;\n    const environment = material.isMeshStandardMaterial ? scene.environment : null;\n    const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.encoding : LinearEncoding;\n    const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);\n    const vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;\n    const vertexTangents = !!material.normalMap && !!geometry.attributes.tangent;\n    const morphTargets = !!geometry.morphAttributes.position;\n    const morphNormals = !!geometry.morphAttributes.normal;\n    const morphColors = !!geometry.morphAttributes.color;\n    const toneMapping = material.toneMapped ? _this.toneMapping : NoToneMapping;\n    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n    const morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;\n    const materialProperties = properties.get(material);\n    const lights = currentRenderState.state.lights;\n    if (_clippingEnabled === true) {\n      if (_localClippingEnabled === true || camera !== _currentCamera) {\n        const useCache = camera === _currentCamera && material.id === _currentMaterialId;\n\n        // we might want to call this function with some ClippingGroup\n        // object instead of the material, once it becomes feasible\n        // (#8465, #8379)\n        clipping.setState(material, camera, useCache);\n      }\n    }\n\n    //\n\n    let needsProgramChange = false;\n    if (material.version === materialProperties.__version) {\n      if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {\n        needsProgramChange = true;\n      } else if (materialProperties.outputEncoding !== encoding) {\n        needsProgramChange = true;\n      } else if (object.isInstancedMesh && materialProperties.instancing === false) {\n        needsProgramChange = true;\n      } else if (!object.isInstancedMesh && materialProperties.instancing === true) {\n        needsProgramChange = true;\n      } else if (object.isSkinnedMesh && materialProperties.skinning === false) {\n        needsProgramChange = true;\n      } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {\n        needsProgramChange = true;\n      } else if (materialProperties.envMap !== envMap) {\n        needsProgramChange = true;\n      } else if (material.fog === true && materialProperties.fog !== fog) {\n        needsProgramChange = true;\n      } else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {\n        needsProgramChange = true;\n      } else if (materialProperties.vertexAlphas !== vertexAlphas) {\n        needsProgramChange = true;\n      } else if (materialProperties.vertexTangents !== vertexTangents) {\n        needsProgramChange = true;\n      } else if (materialProperties.morphTargets !== morphTargets) {\n        needsProgramChange = true;\n      } else if (materialProperties.morphNormals !== morphNormals) {\n        needsProgramChange = true;\n      } else if (materialProperties.morphColors !== morphColors) {\n        needsProgramChange = true;\n      } else if (materialProperties.toneMapping !== toneMapping) {\n        needsProgramChange = true;\n      } else if (capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount) {\n        needsProgramChange = true;\n      }\n    } else {\n      needsProgramChange = true;\n      materialProperties.__version = material.version;\n    }\n\n    //\n\n    let program = materialProperties.currentProgram;\n    if (needsProgramChange === true) {\n      program = getProgram(material, scene, object);\n    }\n    let refreshProgram = false;\n    let refreshMaterial = false;\n    let refreshLights = false;\n    const p_uniforms = program.getUniforms(),\n      m_uniforms = materialProperties.uniforms;\n    if (state.useProgram(program.program)) {\n      refreshProgram = true;\n      refreshMaterial = true;\n      refreshLights = true;\n    }\n    if (material.id !== _currentMaterialId) {\n      _currentMaterialId = material.id;\n      refreshMaterial = true;\n    }\n    if (refreshProgram || _currentCamera !== camera) {\n      p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);\n      if (capabilities.logarithmicDepthBuffer) {\n        p_uniforms.setValue(_gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));\n      }\n      if (_currentCamera !== camera) {\n        _currentCamera = camera;\n\n        // lighting uniforms depend on the camera so enforce an update\n        // now, in case this material supports lights - or later, when\n        // the next material that does gets activated:\n\n        refreshMaterial = true; // set to true on material change\n        refreshLights = true; // remains set until update done\n      }\n\n      // load material specific uniforms\n      // (shader material also gets them for the sake of genericity)\n\n      if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {\n        const uCamPos = p_uniforms.map.cameraPosition;\n        if (uCamPos !== undefined) {\n          uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));\n        }\n      }\n      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {\n        p_uniforms.setValue(_gl, 'isOrthographic', camera.isOrthographicCamera === true);\n      }\n      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || object.isSkinnedMesh) {\n        p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);\n      }\n    }\n\n    // skinning and morph target uniforms must be set even if material didn't change\n    // auto-setting of texture unit for bone and morph texture must go before other textures\n    // otherwise textures used for skinning and morphing can take over texture units reserved for other material textures\n\n    if (object.isSkinnedMesh) {\n      p_uniforms.setOptional(_gl, object, 'bindMatrix');\n      p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');\n      const skeleton = object.skeleton;\n      if (skeleton) {\n        if (capabilities.floatVertexTextures) {\n          if (skeleton.boneTexture === null) skeleton.computeBoneTexture();\n          p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures);\n          p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);\n        } else {\n          console.warn('THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.');\n        }\n      }\n    }\n    const morphAttributes = geometry.morphAttributes;\n    if (morphAttributes.position !== undefined || morphAttributes.normal !== undefined || morphAttributes.color !== undefined && capabilities.isWebGL2 === true) {\n      morphtargets.update(object, geometry, material, program);\n    }\n    if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {\n      materialProperties.receiveShadow = object.receiveShadow;\n      p_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow);\n    }\n\n    // https://github.com/mrdoob/three.js/pull/24467#issuecomment-1209031512\n\n    if (material.isMeshGouraudMaterial && material.envMap !== null) {\n      m_uniforms.envMap.value = envMap;\n      m_uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;\n    }\n    if (refreshMaterial) {\n      p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);\n      if (materialProperties.needsLights) {\n        // the current material requires lighting info\n\n        // note: all lighting uniforms are always set correctly\n        // they simply reference the renderer's state for their\n        // values\n        //\n        // use the current material's .needsUpdate flags to set\n        // the GL state when required\n\n        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);\n      }\n\n      // refresh uniforms common to several materials\n\n      if (fog && material.fog === true) {\n        materials.refreshFogUniforms(m_uniforms, fog);\n      }\n      materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);\n      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);\n    }\n    if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {\n      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);\n      material.uniformsNeedUpdate = false;\n    }\n    if (material.isSpriteMaterial) {\n      p_uniforms.setValue(_gl, 'center', object.center);\n    }\n\n    // common matrices\n\n    p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);\n    p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);\n    p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);\n\n    // UBOs\n\n    if (material.isShaderMaterial || material.isRawShaderMaterial) {\n      const groups = material.uniformsGroups;\n      for (let i = 0, l = groups.length; i < l; i++) {\n        if (capabilities.isWebGL2) {\n          const group = groups[i];\n          uniformsGroups.update(group, program);\n          uniformsGroups.bind(group, program);\n        } else {\n          console.warn('THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.');\n        }\n      }\n    }\n    return program;\n  }\n\n  // If uniforms are marked as clean, they don't need to be loaded to the GPU.\n\n  function markUniformsLightsNeedsUpdate(uniforms, value) {\n    uniforms.ambientLightColor.needsUpdate = value;\n    uniforms.lightProbe.needsUpdate = value;\n    uniforms.directionalLights.needsUpdate = value;\n    uniforms.directionalLightShadows.needsUpdate = value;\n    uniforms.pointLights.needsUpdate = value;\n    uniforms.pointLightShadows.needsUpdate = value;\n    uniforms.spotLights.needsUpdate = value;\n    uniforms.spotLightShadows.needsUpdate = value;\n    uniforms.rectAreaLights.needsUpdate = value;\n    uniforms.hemisphereLights.needsUpdate = value;\n  }\n  function materialNeedsLights(material) {\n    return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;\n  }\n  this.getActiveCubeFace = function () {\n    return _currentActiveCubeFace;\n  };\n  this.getActiveMipmapLevel = function () {\n    return _currentActiveMipmapLevel;\n  };\n  this.getRenderTarget = function () {\n    return _currentRenderTarget;\n  };\n  this.setRenderTargetTextures = function (renderTarget, colorTexture, depthTexture) {\n    properties.get(renderTarget.texture).__webglTexture = colorTexture;\n    properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;\n    const renderTargetProperties = properties.get(renderTarget);\n    renderTargetProperties.__hasExternalTextures = true;\n    if (renderTargetProperties.__hasExternalTextures) {\n      renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === undefined;\n      if (!renderTargetProperties.__autoAllocateDepthBuffer) {\n        // The multisample_render_to_texture extension doesn't work properly if there\n        // are midframe flushes and an external depth buffer. Disable use of the extension.\n        if (extensions.has('WEBGL_multisampled_render_to_texture') === true) {\n          console.warn('THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided');\n          renderTargetProperties.__useRenderToTexture = false;\n        }\n      }\n    }\n  };\n  this.setRenderTargetFramebuffer = function (renderTarget, defaultFramebuffer) {\n    const renderTargetProperties = properties.get(renderTarget);\n    renderTargetProperties.__webglFramebuffer = defaultFramebuffer;\n    renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === undefined;\n  };\n  this.setRenderTarget = function (renderTarget) {\n    let activeCubeFace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let activeMipmapLevel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    _currentRenderTarget = renderTarget;\n    _currentActiveCubeFace = activeCubeFace;\n    _currentActiveMipmapLevel = activeMipmapLevel;\n    let useDefaultFramebuffer = true;\n    let framebuffer = null;\n    let isCube = false;\n    let isRenderTarget3D = false;\n    if (renderTarget) {\n      const renderTargetProperties = properties.get(renderTarget);\n      if (renderTargetProperties.__useDefaultFramebuffer !== undefined) {\n        // We need to make sure to rebind the framebuffer.\n        state.bindFramebuffer(_gl.FRAMEBUFFER, null);\n        useDefaultFramebuffer = false;\n      } else if (renderTargetProperties.__webglFramebuffer === undefined) {\n        textures.setupRenderTarget(renderTarget);\n      } else if (renderTargetProperties.__hasExternalTextures) {\n        // Color and depth texture must be rebound in order for the swapchain to update.\n        textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);\n      }\n      const texture = renderTarget.texture;\n      if (texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture) {\n        isRenderTarget3D = true;\n      }\n      const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;\n      if (renderTarget.isWebGLCubeRenderTarget) {\n        framebuffer = __webglFramebuffer[activeCubeFace];\n        isCube = true;\n      } else if (capabilities.isWebGL2 && renderTarget.samples > 0 && textures.useMultisampledRTT(renderTarget) === false) {\n        framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;\n      } else {\n        framebuffer = __webglFramebuffer;\n      }\n      _currentViewport.copy(renderTarget.viewport);\n      _currentScissor.copy(renderTarget.scissor);\n      _currentScissorTest = renderTarget.scissorTest;\n    } else {\n      _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();\n      _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();\n      _currentScissorTest = _scissorTest;\n    }\n    const framebufferBound = state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);\n    if (framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer) {\n      state.drawBuffers(renderTarget, framebuffer);\n    }\n    state.viewport(_currentViewport);\n    state.scissor(_currentScissor);\n    state.setScissorTest(_currentScissorTest);\n    if (isCube) {\n      const textureProperties = properties.get(renderTarget.texture);\n      _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);\n    } else if (isRenderTarget3D) {\n      const textureProperties = properties.get(renderTarget.texture);\n      const layer = activeCubeFace || 0;\n      _gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);\n    }\n    _currentMaterialId = -1; // reset current material to ensure correct uniform bindings\n  };\n\n  this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {\n    if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {\n      console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');\n      return;\n    }\n    let framebuffer = properties.get(renderTarget).__webglFramebuffer;\n    if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) {\n      framebuffer = framebuffer[activeCubeFaceIndex];\n    }\n    if (framebuffer) {\n      state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);\n      try {\n        const texture = renderTarget.texture;\n        const textureFormat = texture.format;\n        const textureType = texture.type;\n        if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {\n          console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');\n          return;\n        }\n        const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has('EXT_color_buffer_half_float') || capabilities.isWebGL2 && extensions.has('EXT_color_buffer_float'));\n        if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) &&\n        // Edge and Chrome Mac < 52 (#9513)\n        !(textureType === FloatType && (capabilities.isWebGL2 || extensions.has('OES_texture_float') || extensions.has('WEBGL_color_buffer_float'))) &&\n        // Chrome Mac >= 52 and Firefox\n        !halfFloatSupportedByExt) {\n          console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');\n          return;\n        }\n\n        // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\n        if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) {\n          _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);\n        }\n      } finally {\n        // restore framebuffer of current render target if necessary\n\n        const framebuffer = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;\n        state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);\n      }\n    }\n  };\n  this.copyFramebufferToTexture = function (position, texture) {\n    let level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    const levelScale = Math.pow(2, -level);\n    const width = Math.floor(texture.image.width * levelScale);\n    const height = Math.floor(texture.image.height * levelScale);\n    textures.setTexture2D(texture, 0);\n    _gl.copyTexSubImage2D(_gl.TEXTURE_2D, level, 0, 0, position.x, position.y, width, height);\n    state.unbindTexture();\n  };\n  this.copyTextureToTexture = function (position, srcTexture, dstTexture) {\n    let level = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    const width = srcTexture.image.width;\n    const height = srcTexture.image.height;\n    const glFormat = utils.convert(dstTexture.format);\n    const glType = utils.convert(dstTexture.type);\n    textures.setTexture2D(dstTexture, 0);\n\n    // As another texture upload may have changed pixelStorei\n    // parameters, make sure they are correct for the dstTexture\n    _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);\n    _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);\n    _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);\n    if (srcTexture.isDataTexture) {\n      _gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);\n    } else {\n      if (srcTexture.isCompressedTexture) {\n        _gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);\n      } else {\n        _gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image);\n      }\n    }\n\n    // Generate mipmaps only when copying level 0\n    if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(_gl.TEXTURE_2D);\n    state.unbindTexture();\n  };\n  this.copyTextureToTexture3D = function (sourceBox, position, srcTexture, dstTexture) {\n    let level = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    if (_this.isWebGL1Renderer) {\n      console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.');\n      return;\n    }\n    const width = sourceBox.max.x - sourceBox.min.x + 1;\n    const height = sourceBox.max.y - sourceBox.min.y + 1;\n    const depth = sourceBox.max.z - sourceBox.min.z + 1;\n    const glFormat = utils.convert(dstTexture.format);\n    const glType = utils.convert(dstTexture.type);\n    let glTarget;\n    if (dstTexture.isData3DTexture) {\n      textures.setTexture3D(dstTexture, 0);\n      glTarget = _gl.TEXTURE_3D;\n    } else if (dstTexture.isDataArrayTexture) {\n      textures.setTexture2DArray(dstTexture, 0);\n      glTarget = _gl.TEXTURE_2D_ARRAY;\n    } else {\n      console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.');\n      return;\n    }\n    _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);\n    _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);\n    _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);\n    const unpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);\n    const unpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);\n    const unpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);\n    const unpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);\n    const unpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);\n    const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;\n    _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);\n    _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height);\n    _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, sourceBox.min.x);\n    _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, sourceBox.min.y);\n    _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, sourceBox.min.z);\n    if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {\n      _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data);\n    } else {\n      if (srcTexture.isCompressedArrayTexture) {\n        console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.');\n        _gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data);\n      } else {\n        _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image);\n      }\n    }\n    _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, unpackRowLen);\n    _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, unpackImageHeight);\n    _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, unpackSkipPixels);\n    _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, unpackSkipRows);\n    _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, unpackSkipImages);\n\n    // Generate mipmaps only when copying level 0\n    if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(glTarget);\n    state.unbindTexture();\n  };\n  this.initTexture = function (texture) {\n    if (texture.isCubeTexture) {\n      textures.setTextureCube(texture, 0);\n    } else if (texture.isData3DTexture) {\n      textures.setTexture3D(texture, 0);\n    } else if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) {\n      textures.setTexture2DArray(texture, 0);\n    } else {\n      textures.setTexture2D(texture, 0);\n    }\n    state.unbindTexture();\n  };\n  this.resetState = function () {\n    _currentActiveCubeFace = 0;\n    _currentActiveMipmapLevel = 0;\n    _currentRenderTarget = null;\n    state.reset();\n    bindingStates.reset();\n  };\n  if (typeof __THREE_DEVTOOLS__ !== 'undefined') {\n    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {\n      detail: this\n    }));\n  }\n}\nexport { WebGLRenderer };","map":{"version":3,"names":["REVISION","BackSide","DoubleSide","FrontSide","RGBAFormat","HalfFloatType","FloatType","UnsignedByteType","LinearEncoding","NoToneMapping","LinearMipmapLinearFilter","floorPowerOfTwo","Frustum","Matrix4","Vector2","Vector3","Vector4","WebGLAnimation","WebGLAttributes","WebGLBackground","WebGLBindingStates","WebGLBufferRenderer","WebGLCapabilities","WebGLClipping","WebGLCubeMaps","WebGLCubeUVMaps","WebGLExtensions","WebGLGeometries","WebGLIndexedBufferRenderer","WebGLInfo","WebGLMorphtargets","WebGLObjects","WebGLPrograms","WebGLProperties","WebGLRenderLists","WebGLRenderStates","WebGLRenderTarget","WebGLShadowMap","WebGLState","WebGLTextures","WebGLUniforms","WebGLUtils","WebXRManager","WebGLMaterials","WebGLUniformsGroups","createElementNS","createCanvasElement","canvas","style","display","WebGLRenderer","parameters","isWebGLRenderer","_canvas","undefined","_context","context","_depth","depth","_stencil","stencil","_antialias","antialias","_premultipliedAlpha","premultipliedAlpha","_preserveDrawingBuffer","preserveDrawingBuffer","_powerPreference","powerPreference","_failIfMajorPerformanceCaveat","failIfMajorPerformanceCaveat","_alpha","getContextAttributes","alpha","currentRenderList","currentRenderState","renderListStack","renderStateStack","domElement","debug","checkShaderErrors","autoClear","autoClearColor","autoClearDepth","autoClearStencil","sortObjects","clippingPlanes","localClippingEnabled","outputEncoding","physicallyCorrectLights","toneMapping","toneMappingExposure","_this","_isContextLost","_currentActiveCubeFace","_currentActiveMipmapLevel","_currentRenderTarget","_currentMaterialId","_currentCamera","_currentViewport","_currentScissor","_currentScissorTest","_width","width","_height","height","_pixelRatio","_opaqueSort","_transparentSort","_viewport","_scissor","_scissorTest","_frustum","_clippingEnabled","_localClippingEnabled","_transmissionRenderTarget","_projScreenMatrix","_vector2","_vector3","_emptyScene","background","fog","environment","overrideMaterial","isScene","getTargetPixelRatio","_gl","getContext","contextNames","contextAttributes","i","length","contextName","setAttribute","addEventListener","onContextLost","onContextRestore","onContextCreationError","isWebGL1Renderer","shift","Error","getShaderPrecisionFormat","error","console","message","extensions","capabilities","state","info","properties","textures","cubemaps","cubeuvmaps","attributes","geometries","objects","programCache","materials","renderLists","renderStates","clipping","shadowMap","morphtargets","bufferRenderer","indexedBufferRenderer","utils","bindingStates","uniformsGroups","initGLContext","init","programs","xr","forceContextLoss","extension","get","loseContext","forceContextRestore","restoreContext","getPixelRatio","setPixelRatio","value","setSize","getSize","target","set","updateStyle","isPresenting","warn","Math","floor","setViewport","getDrawingBufferSize","setDrawingBufferSize","pixelRatio","getCurrentViewport","copy","getViewport","x","y","isVector4","z","w","viewport","multiplyScalar","getScissor","setScissor","scissor","getScissorTest","setScissorTest","boolean","setOpaqueSort","method","setTransparentSort","getClearColor","setClearColor","apply","arguments","getClearAlpha","setClearAlpha","clear","color","bits","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT","clearColor","clearDepth","clearStencil","dispose","removeEventListener","onXRSessionStart","onXRSessionEnd","animation","stop","event","preventDefault","log","infoAutoReset","autoReset","shadowMapEnabled","enabled","shadowMapAutoUpdate","autoUpdate","shadowMapNeedsUpdate","needsUpdate","shadowMapType","type","statusMessage","onMaterialDispose","material","deallocateMaterial","releaseMaterialProgramReferences","remove","forEach","program","releaseProgram","isShaderMaterial","releaseShaderCache","renderBufferDirect","camera","scene","geometry","object","group","frontFaceCW","isMesh","matrixWorld","determinant","setProgram","setMaterial","index","rangeFactor","wireframe","getWireframeAttribute","drawRange","position","drawStart","start","drawEnd","count","max","min","drawCount","Infinity","setup","attribute","renderer","setIndex","setLineWidth","wireframeLinewidth","setMode","LINES","TRIANGLES","isLine","lineWidth","linewidth","isLineSegments","isLineLoop","LINE_LOOP","LINE_STRIP","isPoints","POINTS","isSprite","isInstancedMesh","renderInstances","isInstancedBufferGeometry","maxInstanceCount","_maxInstanceCount","instanceCount","render","compile","prepare","transparent","side","getProgram","push","traverseVisible","isLight","layers","test","pushLight","castShadow","pushShadow","setupLights","traverse","Array","isArray","material2","pop","onAnimationFrameCallback","onAnimationFrame","time","setAnimationLoop","self","setContext","callback","isCamera","matrixWorldAutoUpdate","updateMatrixWorld","parent","cameraAutoUpdate","updateCamera","getCamera","onBeforeRender","multiplyMatrices","projectionMatrix","matrixWorldInverse","setFromProjectionMatrix","projectObject","finish","sort","beginShadows","shadowsArray","endShadows","reset","isArrayCamera","cameras","l","camera2","renderScene","updateMultisampleRenderTarget","updateRenderTargetMipmap","onAfterRender","resetDefaultState","groupOrder","visible","isGroup","renderOrder","isLOD","update","frustumCulled","intersectsSprite","setFromMatrixPosition","applyMatrix4","isSkinnedMesh","skeleton","frame","intersectsObject","groups","groupMaterial","materialIndex","children","opaqueObjects","opaque","transmissiveObjects","transmissive","transparentObjects","setupLightsView","renderTransmissionPass","renderObjects","buffers","setTest","setMask","setPolygonOffset","isWebGL2","generateMipmaps","has","minFilter","samples","currentRenderTarget","getRenderTarget","setRenderTarget","currentToneMapping","renderList","renderItem","renderObject","modelViewMatrix","normalMatrix","getNormalMatrix","materialProperties","lights","lightsStateVersion","version","getParameters","programCacheKey","getProgramCacheKey","isMeshStandardMaterial","envMap","Map","currentProgram","updateCommonMaterialProperties","uniforms","getUniforms","onBuild","onBeforeCompile","acquireProgram","isRawShaderMaterial","uniform","needsLights","materialNeedsLights","ambientLightColor","ambient","lightProbe","probe","directionalLights","directional","directionalLightShadows","directionalShadow","spotLights","spot","spotLightShadows","spotShadow","rectAreaLights","rectArea","ltc_1","rectAreaLTC1","ltc_2","rectAreaLTC2","pointLights","point","pointLightShadows","pointShadow","hemisphereLights","hemi","directionalShadowMap","directionalShadowMatrix","spotShadowMap","spotLightMatrix","spotLightMap","pointShadowMap","pointShadowMatrix","progUniforms","uniformsList","seqWithValue","seq","instancing","skinning","morphTargets","morphNormals","morphColors","morphTargetsCount","numClippingPlanes","numIntersection","numClipIntersection","vertexAlphas","vertexTangents","resetTextureUnits","encoding","isXRRenderTarget","texture","vertexColors","itemSize","normalMap","tangent","morphAttributes","normal","toneMapped","morphAttribute","useCache","id","setState","needsProgramChange","__version","numPlanes","refreshProgram","refreshMaterial","refreshLights","p_uniforms","m_uniforms","useProgram","setValue","logarithmicDepthBuffer","far","LN2","isMeshPhongMaterial","isMeshToonMaterial","uCamPos","map","cameraPosition","isMeshLambertMaterial","isMeshBasicMaterial","isOrthographicCamera","isShadowMaterial","setOptional","floatVertexTextures","boneTexture","computeBoneTexture","boneTextureSize","receiveShadow","isMeshGouraudMaterial","flipEnvMap","isCubeTexture","isRenderTargetTexture","markUniformsLightsNeedsUpdate","refreshFogUniforms","refreshMaterialUniforms","upload","uniformsNeedUpdate","isSpriteMaterial","center","bind","getActiveCubeFace","getActiveMipmapLevel","setRenderTargetTextures","renderTarget","colorTexture","depthTexture","__webglTexture","renderTargetProperties","__hasExternalTextures","__autoAllocateDepthBuffer","__useRenderToTexture","setRenderTargetFramebuffer","defaultFramebuffer","__webglFramebuffer","__useDefaultFramebuffer","activeCubeFace","activeMipmapLevel","useDefaultFramebuffer","framebuffer","isCube","isRenderTarget3D","bindFramebuffer","FRAMEBUFFER","setupRenderTarget","rebindTextures","isData3DTexture","isDataArrayTexture","isCompressedArrayTexture","isWebGLCubeRenderTarget","useMultisampledRTT","__webglMultisampledFramebuffer","scissorTest","framebufferBound","drawBuffers","textureProperties","framebufferTexture2D","COLOR_ATTACHMENT0","TEXTURE_CUBE_MAP_POSITIVE_X","layer","framebufferTextureLayer","readRenderTargetPixels","buffer","activeCubeFaceIndex","isWebGLRenderTarget","textureFormat","format","textureType","convert","getParameter","IMPLEMENTATION_COLOR_READ_FORMAT","halfFloatSupportedByExt","IMPLEMENTATION_COLOR_READ_TYPE","readPixels","copyFramebufferToTexture","level","levelScale","pow","image","setTexture2D","copyTexSubImage2D","TEXTURE_2D","unbindTexture","copyTextureToTexture","srcTexture","dstTexture","glFormat","glType","pixelStorei","UNPACK_FLIP_Y_WEBGL","flipY","UNPACK_PREMULTIPLY_ALPHA_WEBGL","premultiplyAlpha","UNPACK_ALIGNMENT","unpackAlignment","isDataTexture","texSubImage2D","data","isCompressedTexture","compressedTexSubImage2D","mipmaps","generateMipmap","copyTextureToTexture3D","sourceBox","glTarget","setTexture3D","TEXTURE_3D","setTexture2DArray","TEXTURE_2D_ARRAY","unpackRowLen","UNPACK_ROW_LENGTH","unpackImageHeight","UNPACK_IMAGE_HEIGHT","unpackSkipPixels","UNPACK_SKIP_PIXELS","unpackSkipRows","UNPACK_SKIP_ROWS","unpackSkipImages","UNPACK_SKIP_IMAGES","texSubImage3D","compressedTexSubImage3D","initTexture","setTextureCube","resetState","__THREE_DEVTOOLS__","dispatchEvent","CustomEvent","detail"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/renderers/WebGLRenderer.js"],"sourcesContent":["import {\n\tREVISION,\n\tBackSide,\n\tDoubleSide,\n\tFrontSide,\n\tRGBAFormat,\n\tHalfFloatType,\n\tFloatType,\n\tUnsignedByteType,\n\tLinearEncoding,\n\tNoToneMapping,\n\tLinearMipmapLinearFilter\n} from '../constants.js';\nimport { floorPowerOfTwo } from '../math/MathUtils.js';\nimport { Frustum } from '../math/Frustum.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector4 } from '../math/Vector4.js';\nimport { WebGLAnimation } from './webgl/WebGLAnimation.js';\nimport { WebGLAttributes } from './webgl/WebGLAttributes.js';\nimport { WebGLBackground } from './webgl/WebGLBackground.js';\nimport { WebGLBindingStates } from './webgl/WebGLBindingStates.js';\nimport { WebGLBufferRenderer } from './webgl/WebGLBufferRenderer.js';\nimport { WebGLCapabilities } from './webgl/WebGLCapabilities.js';\nimport { WebGLClipping } from './webgl/WebGLClipping.js';\nimport { WebGLCubeMaps } from './webgl/WebGLCubeMaps.js';\nimport { WebGLCubeUVMaps } from './webgl/WebGLCubeUVMaps.js';\nimport { WebGLExtensions } from './webgl/WebGLExtensions.js';\nimport { WebGLGeometries } from './webgl/WebGLGeometries.js';\nimport { WebGLIndexedBufferRenderer } from './webgl/WebGLIndexedBufferRenderer.js';\nimport { WebGLInfo } from './webgl/WebGLInfo.js';\nimport { WebGLMorphtargets } from './webgl/WebGLMorphtargets.js';\nimport { WebGLObjects } from './webgl/WebGLObjects.js';\nimport { WebGLPrograms } from './webgl/WebGLPrograms.js';\nimport { WebGLProperties } from './webgl/WebGLProperties.js';\nimport { WebGLRenderLists } from './webgl/WebGLRenderLists.js';\nimport { WebGLRenderStates } from './webgl/WebGLRenderStates.js';\nimport { WebGLRenderTarget } from './WebGLRenderTarget.js';\nimport { WebGLShadowMap } from './webgl/WebGLShadowMap.js';\nimport { WebGLState } from './webgl/WebGLState.js';\nimport { WebGLTextures } from './webgl/WebGLTextures.js';\nimport { WebGLUniforms } from './webgl/WebGLUniforms.js';\nimport { WebGLUtils } from './webgl/WebGLUtils.js';\nimport { WebXRManager } from './webxr/WebXRManager.js';\nimport { WebGLMaterials } from './webgl/WebGLMaterials.js';\nimport { WebGLUniformsGroups } from './webgl/WebGLUniformsGroups.js';\nimport { createElementNS } from '../utils.js';\n\nfunction createCanvasElement() {\n\n\tconst canvas = createElementNS( 'canvas' );\n\tcanvas.style.display = 'block';\n\treturn canvas;\n\n}\n\nfunction WebGLRenderer( parameters = {} ) {\n\n\tthis.isWebGLRenderer = true;\n\n\tconst _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),\n\t\t_context = parameters.context !== undefined ? parameters.context : null,\n\n\t\t_depth = parameters.depth !== undefined ? parameters.depth : true,\n\t\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\n\t\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\n\t\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\n\t\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,\n\t\t_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',\n\t\t_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;\n\n\tlet _alpha;\n\n\tif ( _context !== null ) {\n\n\t\t_alpha = _context.getContextAttributes().alpha;\n\n\t} else {\n\n\t\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false;\n\n\t}\n\n\tlet currentRenderList = null;\n\tlet currentRenderState = null;\n\n\t// render() can be called from within a callback triggered by another render.\n\t// We track this so that the nested render call gets its list and state isolated from the parent render call.\n\n\tconst renderListStack = [];\n\tconst renderStateStack = [];\n\n\t// public properties\n\n\tthis.domElement = _canvas;\n\n\t// Debug configuration container\n\tthis.debug = {\n\n\t\t/**\n\t\t * Enables error checking and reporting when shader programs are being compiled\n\t\t * @type {boolean}\n\t\t */\n\t\tcheckShaderErrors: true\n\t};\n\n\t// clearing\n\n\tthis.autoClear = true;\n\tthis.autoClearColor = true;\n\tthis.autoClearDepth = true;\n\tthis.autoClearStencil = true;\n\n\t// scene graph\n\n\tthis.sortObjects = true;\n\n\t// user-defined clipping\n\n\tthis.clippingPlanes = [];\n\tthis.localClippingEnabled = false;\n\n\t// physically based shading\n\n\tthis.outputEncoding = LinearEncoding;\n\n\t// physical lights\n\n\tthis.physicallyCorrectLights = false;\n\n\t// tone mapping\n\n\tthis.toneMapping = NoToneMapping;\n\tthis.toneMappingExposure = 1.0;\n\n\t// internal properties\n\n\tconst _this = this;\n\n\tlet _isContextLost = false;\n\n\t// internal state cache\n\n\tlet _currentActiveCubeFace = 0;\n\tlet _currentActiveMipmapLevel = 0;\n\tlet _currentRenderTarget = null;\n\tlet _currentMaterialId = - 1;\n\n\tlet _currentCamera = null;\n\n\tconst _currentViewport = new Vector4();\n\tconst _currentScissor = new Vector4();\n\tlet _currentScissorTest = null;\n\n\t//\n\n\tlet _width = _canvas.width;\n\tlet _height = _canvas.height;\n\n\tlet _pixelRatio = 1;\n\tlet _opaqueSort = null;\n\tlet _transparentSort = null;\n\n\tconst _viewport = new Vector4( 0, 0, _width, _height );\n\tconst _scissor = new Vector4( 0, 0, _width, _height );\n\tlet _scissorTest = false;\n\n\t// frustum\n\n\tconst _frustum = new Frustum();\n\n\t// clipping\n\n\tlet _clippingEnabled = false;\n\tlet _localClippingEnabled = false;\n\n\t// transmission\n\n\tlet _transmissionRenderTarget = null;\n\n\t// camera matrices cache\n\n\tconst _projScreenMatrix = new Matrix4();\n\n\tconst _vector2 = new Vector2();\n\tconst _vector3 = new Vector3();\n\n\tconst _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };\n\n\tfunction getTargetPixelRatio() {\n\n\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\n\n\t}\n\n\t// initialize\n\n\tlet _gl = _context;\n\n\tfunction getContext( contextNames, contextAttributes ) {\n\n\t\tfor ( let i = 0; i < contextNames.length; i ++ ) {\n\n\t\t\tconst contextName = contextNames[ i ];\n\t\t\tconst context = _canvas.getContext( contextName, contextAttributes );\n\t\t\tif ( context !== null ) return context;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\ttry {\n\n\t\tconst contextAttributes = {\n\t\t\talpha: true,\n\t\t\tdepth: _depth,\n\t\t\tstencil: _stencil,\n\t\t\tantialias: _antialias,\n\t\t\tpremultipliedAlpha: _premultipliedAlpha,\n\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer,\n\t\t\tpowerPreference: _powerPreference,\n\t\t\tfailIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat\n\t\t};\n\n\t\t// OffscreenCanvas does not have setAttribute, see #22811\n\t\tif ( 'setAttribute' in _canvas ) _canvas.setAttribute( 'data-engine', `three.js r${REVISION}` );\n\n\t\t// event listeners must be registered before WebGL context is created, see #12753\n\t\t_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\n\t\t_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );\n\t\t_canvas.addEventListener( 'webglcontextcreationerror', onContextCreationError, false );\n\n\t\tif ( _gl === null ) {\n\n\t\t\tconst contextNames = [ 'webgl2', 'webgl', 'experimental-webgl' ];\n\n\t\t\tif ( _this.isWebGL1Renderer === true ) {\n\n\t\t\t\tcontextNames.shift();\n\n\t\t\t}\n\n\t\t\t_gl = getContext( contextNames, contextAttributes );\n\n\t\t\tif ( _gl === null ) {\n\n\t\t\t\tif ( getContext( contextNames ) ) {\n\n\t\t\t\t\tthrow new Error( 'Error creating WebGL context with your selected attributes.' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'Error creating WebGL context.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Some experimental-webgl implementations do not have getShaderPrecisionFormat\n\n\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\n\n\t\t\t_gl.getShaderPrecisionFormat = function () {\n\n\t\t\t\treturn { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\n\n\t\t\t};\n\n\t\t}\n\n\t} catch ( error ) {\n\n\t\tconsole.error( 'THREE.WebGLRenderer: ' + error.message );\n\t\tthrow error;\n\n\t}\n\n\tlet extensions, capabilities, state, info;\n\tlet properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;\n\tlet programCache, materials, renderLists, renderStates, clipping, shadowMap;\n\n\tlet background, morphtargets, bufferRenderer, indexedBufferRenderer;\n\n\tlet utils, bindingStates, uniformsGroups;\n\n\tfunction initGLContext() {\n\n\t\textensions = new WebGLExtensions( _gl );\n\n\t\tcapabilities = new WebGLCapabilities( _gl, extensions, parameters );\n\n\t\textensions.init( capabilities );\n\n\t\tutils = new WebGLUtils( _gl, extensions, capabilities );\n\n\t\tstate = new WebGLState( _gl, extensions, capabilities );\n\n\t\tinfo = new WebGLInfo( _gl );\n\t\tproperties = new WebGLProperties();\n\t\ttextures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );\n\t\tcubemaps = new WebGLCubeMaps( _this );\n\t\tcubeuvmaps = new WebGLCubeUVMaps( _this );\n\t\tattributes = new WebGLAttributes( _gl, capabilities );\n\t\tbindingStates = new WebGLBindingStates( _gl, extensions, attributes, capabilities );\n\t\tgeometries = new WebGLGeometries( _gl, attributes, info, bindingStates );\n\t\tobjects = new WebGLObjects( _gl, geometries, attributes, info );\n\t\tmorphtargets = new WebGLMorphtargets( _gl, capabilities, textures );\n\t\tclipping = new WebGLClipping( properties );\n\t\tprogramCache = new WebGLPrograms( _this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping );\n\t\tmaterials = new WebGLMaterials( _this, properties );\n\t\trenderLists = new WebGLRenderLists();\n\t\trenderStates = new WebGLRenderStates( extensions, capabilities );\n\t\tbackground = new WebGLBackground( _this, cubemaps, cubeuvmaps, state, objects, _alpha, _premultipliedAlpha );\n\t\tshadowMap = new WebGLShadowMap( _this, objects, capabilities );\n\t\tuniformsGroups = new WebGLUniformsGroups( _gl, info, capabilities, state );\n\n\t\tbufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );\n\t\tindexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );\n\n\t\tinfo.programs = programCache.programs;\n\n\t\t_this.capabilities = capabilities;\n\t\t_this.extensions = extensions;\n\t\t_this.properties = properties;\n\t\t_this.renderLists = renderLists;\n\t\t_this.shadowMap = shadowMap;\n\t\t_this.state = state;\n\t\t_this.info = info;\n\n\t}\n\n\tinitGLContext();\n\n\t// xr\n\n\tconst xr = new WebXRManager( _this, _gl );\n\n\tthis.xr = xr;\n\n\t// API\n\n\tthis.getContext = function () {\n\n\t\treturn _gl;\n\n\t};\n\n\tthis.getContextAttributes = function () {\n\n\t\treturn _gl.getContextAttributes();\n\n\t};\n\n\tthis.forceContextLoss = function () {\n\n\t\tconst extension = extensions.get( 'WEBGL_lose_context' );\n\t\tif ( extension ) extension.loseContext();\n\n\t};\n\n\tthis.forceContextRestore = function () {\n\n\t\tconst extension = extensions.get( 'WEBGL_lose_context' );\n\t\tif ( extension ) extension.restoreContext();\n\n\t};\n\n\tthis.getPixelRatio = function () {\n\n\t\treturn _pixelRatio;\n\n\t};\n\n\tthis.setPixelRatio = function ( value ) {\n\n\t\tif ( value === undefined ) return;\n\n\t\t_pixelRatio = value;\n\n\t\tthis.setSize( _width, _height, false );\n\n\t};\n\n\tthis.getSize = function ( target ) {\n\n\t\treturn target.set( _width, _height );\n\n\t};\n\n\tthis.setSize = function ( width, height, updateStyle ) {\n\n\t\tif ( xr.isPresenting ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Can\\'t change size while VR device is presenting.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\t_width = width;\n\t\t_height = height;\n\n\t\t_canvas.width = Math.floor( width * _pixelRatio );\n\t\t_canvas.height = Math.floor( height * _pixelRatio );\n\n\t\tif ( updateStyle !== false ) {\n\n\t\t\t_canvas.style.width = width + 'px';\n\t\t\t_canvas.style.height = height + 'px';\n\n\t\t}\n\n\t\tthis.setViewport( 0, 0, width, height );\n\n\t};\n\n\tthis.getDrawingBufferSize = function ( target ) {\n\n\t\treturn target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();\n\n\t};\n\n\tthis.setDrawingBufferSize = function ( width, height, pixelRatio ) {\n\n\t\t_width = width;\n\t\t_height = height;\n\n\t\t_pixelRatio = pixelRatio;\n\n\t\t_canvas.width = Math.floor( width * pixelRatio );\n\t\t_canvas.height = Math.floor( height * pixelRatio );\n\n\t\tthis.setViewport( 0, 0, width, height );\n\n\t};\n\n\tthis.getCurrentViewport = function ( target ) {\n\n\t\treturn target.copy( _currentViewport );\n\n\t};\n\n\tthis.getViewport = function ( target ) {\n\n\t\treturn target.copy( _viewport );\n\n\t};\n\n\tthis.setViewport = function ( x, y, width, height ) {\n\n\t\tif ( x.isVector4 ) {\n\n\t\t\t_viewport.set( x.x, x.y, x.z, x.w );\n\n\t\t} else {\n\n\t\t\t_viewport.set( x, y, width, height );\n\n\t\t}\n\n\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );\n\n\t};\n\n\tthis.getScissor = function ( target ) {\n\n\t\treturn target.copy( _scissor );\n\n\t};\n\n\tthis.setScissor = function ( x, y, width, height ) {\n\n\t\tif ( x.isVector4 ) {\n\n\t\t\t_scissor.set( x.x, x.y, x.z, x.w );\n\n\t\t} else {\n\n\t\t\t_scissor.set( x, y, width, height );\n\n\t\t}\n\n\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );\n\n\t};\n\n\tthis.getScissorTest = function () {\n\n\t\treturn _scissorTest;\n\n\t};\n\n\tthis.setScissorTest = function ( boolean ) {\n\n\t\tstate.setScissorTest( _scissorTest = boolean );\n\n\t};\n\n\tthis.setOpaqueSort = function ( method ) {\n\n\t\t_opaqueSort = method;\n\n\t};\n\n\tthis.setTransparentSort = function ( method ) {\n\n\t\t_transparentSort = method;\n\n\t};\n\n\t// Clearing\n\n\tthis.getClearColor = function ( target ) {\n\n\t\treturn target.copy( background.getClearColor() );\n\n\t};\n\n\tthis.setClearColor = function () {\n\n\t\tbackground.setClearColor.apply( background, arguments );\n\n\t};\n\n\tthis.getClearAlpha = function () {\n\n\t\treturn background.getClearAlpha();\n\n\t};\n\n\tthis.setClearAlpha = function () {\n\n\t\tbackground.setClearAlpha.apply( background, arguments );\n\n\t};\n\n\tthis.clear = function ( color = true, depth = true, stencil = true ) {\n\n\t\tlet bits = 0;\n\n\t\tif ( color ) bits |= _gl.COLOR_BUFFER_BIT;\n\t\tif ( depth ) bits |= _gl.DEPTH_BUFFER_BIT;\n\t\tif ( stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\n\n\t\t_gl.clear( bits );\n\n\t};\n\n\tthis.clearColor = function () {\n\n\t\tthis.clear( true, false, false );\n\n\t};\n\n\tthis.clearDepth = function () {\n\n\t\tthis.clear( false, true, false );\n\n\t};\n\n\tthis.clearStencil = function () {\n\n\t\tthis.clear( false, false, true );\n\n\t};\n\n\t//\n\n\tthis.dispose = function () {\n\n\t\t_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\n\t\t_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );\n\t\t_canvas.removeEventListener( 'webglcontextcreationerror', onContextCreationError, false );\n\n\t\trenderLists.dispose();\n\t\trenderStates.dispose();\n\t\tproperties.dispose();\n\t\tcubemaps.dispose();\n\t\tcubeuvmaps.dispose();\n\t\tobjects.dispose();\n\t\tbindingStates.dispose();\n\t\tuniformsGroups.dispose();\n\t\tprogramCache.dispose();\n\n\t\txr.dispose();\n\n\t\txr.removeEventListener( 'sessionstart', onXRSessionStart );\n\t\txr.removeEventListener( 'sessionend', onXRSessionEnd );\n\n\t\tif ( _transmissionRenderTarget ) {\n\n\t\t\t_transmissionRenderTarget.dispose();\n\t\t\t_transmissionRenderTarget = null;\n\n\t\t}\n\n\t\tanimation.stop();\n\n\t};\n\n\t// Events\n\n\tfunction onContextLost( event ) {\n\n\t\tevent.preventDefault();\n\n\t\tconsole.log( 'THREE.WebGLRenderer: Context Lost.' );\n\n\t\t_isContextLost = true;\n\n\t}\n\n\tfunction onContextRestore( /* event */ ) {\n\n\t\tconsole.log( 'THREE.WebGLRenderer: Context Restored.' );\n\n\t\t_isContextLost = false;\n\n\t\tconst infoAutoReset = info.autoReset;\n\t\tconst shadowMapEnabled = shadowMap.enabled;\n\t\tconst shadowMapAutoUpdate = shadowMap.autoUpdate;\n\t\tconst shadowMapNeedsUpdate = shadowMap.needsUpdate;\n\t\tconst shadowMapType = shadowMap.type;\n\n\t\tinitGLContext();\n\n\t\tinfo.autoReset = infoAutoReset;\n\t\tshadowMap.enabled = shadowMapEnabled;\n\t\tshadowMap.autoUpdate = shadowMapAutoUpdate;\n\t\tshadowMap.needsUpdate = shadowMapNeedsUpdate;\n\t\tshadowMap.type = shadowMapType;\n\n\t}\n\n\tfunction onContextCreationError( event ) {\n\n\t\tconsole.error( 'THREE.WebGLRenderer: A WebGL context could not be created. Reason: ', event.statusMessage );\n\n\t}\n\n\tfunction onMaterialDispose( event ) {\n\n\t\tconst material = event.target;\n\n\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\n\n\t\tdeallocateMaterial( material );\n\n\t}\n\n\t// Buffer deallocation\n\n\tfunction deallocateMaterial( material ) {\n\n\t\treleaseMaterialProgramReferences( material );\n\n\t\tproperties.remove( material );\n\n\t}\n\n\n\tfunction releaseMaterialProgramReferences( material ) {\n\n\t\tconst programs = properties.get( material ).programs;\n\n\t\tif ( programs !== undefined ) {\n\n\t\t\tprograms.forEach( function ( program ) {\n\n\t\t\t\tprogramCache.releaseProgram( program );\n\n\t\t\t} );\n\n\t\t\tif ( material.isShaderMaterial ) {\n\n\t\t\t\tprogramCache.releaseShaderCache( material );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Buffer rendering\n\n\tthis.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {\n\n\t\tif ( scene === null ) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)\n\n\t\tconst frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );\n\n\t\tconst program = setProgram( camera, scene, geometry, material, object );\n\n\t\tstate.setMaterial( material, frontFaceCW );\n\n\t\t//\n\n\t\tlet index = geometry.index;\n\t\tlet rangeFactor = 1;\n\n\t\tif ( material.wireframe === true ) {\n\n\t\t\tindex = geometries.getWireframeAttribute( geometry );\n\t\t\trangeFactor = 2;\n\n\t\t}\n\n\t\t//\n\n\t\tconst drawRange = geometry.drawRange;\n\t\tconst position = geometry.attributes.position;\n\n\t\tlet drawStart = drawRange.start * rangeFactor;\n\t\tlet drawEnd = ( drawRange.start + drawRange.count ) * rangeFactor;\n\n\t\tif ( group !== null ) {\n\n\t\t\tdrawStart = Math.max( drawStart, group.start * rangeFactor );\n\t\t\tdrawEnd = Math.min( drawEnd, ( group.start + group.count ) * rangeFactor );\n\n\t\t}\n\n\t\tif ( index !== null ) {\n\n\t\t\tdrawStart = Math.max( drawStart, 0 );\n\t\t\tdrawEnd = Math.min( drawEnd, index.count );\n\n\t\t} else if ( position !== undefined && position !== null ) {\n\n\t\t\tdrawStart = Math.max( drawStart, 0 );\n\t\t\tdrawEnd = Math.min( drawEnd, position.count );\n\n\t\t}\n\n\t\tconst drawCount = drawEnd - drawStart;\n\n\t\tif ( drawCount < 0 || drawCount === Infinity ) return;\n\n\t\t//\n\n\t\tbindingStates.setup( object, material, program, geometry, index );\n\n\t\tlet attribute;\n\t\tlet renderer = bufferRenderer;\n\n\t\tif ( index !== null ) {\n\n\t\t\tattribute = attributes.get( index );\n\n\t\t\trenderer = indexedBufferRenderer;\n\t\t\trenderer.setIndex( attribute );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( object.isMesh ) {\n\n\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\n\t\t\t\trenderer.setMode( _gl.LINES );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.setMode( _gl.TRIANGLES );\n\n\t\t\t}\n\n\t\t} else if ( object.isLine ) {\n\n\t\t\tlet lineWidth = material.linewidth;\n\n\t\t\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\n\n\t\t\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\n\n\t\t\tif ( object.isLineSegments ) {\n\n\t\t\t\trenderer.setMode( _gl.LINES );\n\n\t\t\t} else if ( object.isLineLoop ) {\n\n\t\t\t\trenderer.setMode( _gl.LINE_LOOP );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.setMode( _gl.LINE_STRIP );\n\n\t\t\t}\n\n\t\t} else if ( object.isPoints ) {\n\n\t\t\trenderer.setMode( _gl.POINTS );\n\n\t\t} else if ( object.isSprite ) {\n\n\t\t\trenderer.setMode( _gl.TRIANGLES );\n\n\t\t}\n\n\t\tif ( object.isInstancedMesh ) {\n\n\t\t\trenderer.renderInstances( drawStart, drawCount, object.count );\n\n\t\t} else if ( geometry.isInstancedBufferGeometry ) {\n\n\t\t\tconst maxInstanceCount = geometry._maxInstanceCount !== undefined ? geometry._maxInstanceCount : Infinity;\n\t\t\tconst instanceCount = Math.min( geometry.instanceCount, maxInstanceCount );\n\n\t\t\trenderer.renderInstances( drawStart, drawCount, instanceCount );\n\n\t\t} else {\n\n\t\t\trenderer.render( drawStart, drawCount );\n\n\t\t}\n\n\t};\n\n\t// Compile\n\n\tthis.compile = function ( scene, camera ) {\n\n\t\tfunction prepare( material, scene, object ) {\n\n\t\t\tif ( material.transparent === true && material.side === DoubleSide ) {\n\n\t\t\t\tmaterial.side = BackSide;\n\t\t\t\tmaterial.needsUpdate = true;\n\t\t\t\tgetProgram( material, scene, object );\n\n\t\t\t\tmaterial.side = FrontSide;\n\t\t\t\tmaterial.needsUpdate = true;\n\t\t\t\tgetProgram( material, scene, object );\n\n\t\t\t\tmaterial.side = DoubleSide;\n\n\t\t\t} else {\n\n\t\t\t\tgetProgram( material, scene, object );\n\n\t\t\t}\n\n\t\t}\n\n\t\tcurrentRenderState = renderStates.get( scene );\n\t\tcurrentRenderState.init();\n\n\t\trenderStateStack.push( currentRenderState );\n\n\t\tscene.traverseVisible( function ( object ) {\n\n\t\t\tif ( object.isLight && object.layers.test( camera.layers ) ) {\n\n\t\t\t\tcurrentRenderState.pushLight( object );\n\n\t\t\t\tif ( object.castShadow ) {\n\n\t\t\t\t\tcurrentRenderState.pushShadow( object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\tcurrentRenderState.setupLights( _this.physicallyCorrectLights );\n\n\t\tscene.traverse( function ( object ) {\n\n\t\t\tconst material = object.material;\n\n\t\t\tif ( material ) {\n\n\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\tfor ( let i = 0; i < material.length; i ++ ) {\n\n\t\t\t\t\t\tconst material2 = material[ i ];\n\n\t\t\t\t\t\tprepare( material2, scene, object );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tprepare( material, scene, object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\trenderStateStack.pop();\n\t\tcurrentRenderState = null;\n\n\t};\n\n\t// Animation Loop\n\n\tlet onAnimationFrameCallback = null;\n\n\tfunction onAnimationFrame( time ) {\n\n\t\tif ( onAnimationFrameCallback ) onAnimationFrameCallback( time );\n\n\t}\n\n\tfunction onXRSessionStart() {\n\n\t\tanimation.stop();\n\n\t}\n\n\tfunction onXRSessionEnd() {\n\n\t\tanimation.start();\n\n\t}\n\n\tconst animation = new WebGLAnimation();\n\tanimation.setAnimationLoop( onAnimationFrame );\n\n\tif ( typeof self !== 'undefined' ) animation.setContext( self );\n\n\tthis.setAnimationLoop = function ( callback ) {\n\n\t\tonAnimationFrameCallback = callback;\n\t\txr.setAnimationLoop( callback );\n\n\t\t( callback === null ) ? animation.stop() : animation.start();\n\n\t};\n\n\txr.addEventListener( 'sessionstart', onXRSessionStart );\n\txr.addEventListener( 'sessionend', onXRSessionEnd );\n\n\t// Rendering\n\n\tthis.render = function ( scene, camera ) {\n\n\t\tif ( camera !== undefined && camera.isCamera !== true ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( _isContextLost === true ) return;\n\n\t\t// update scene graph\n\n\t\tif ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();\n\n\t\t// update camera matrices and frustum\n\n\t\tif ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();\n\n\t\tif ( xr.enabled === true && xr.isPresenting === true ) {\n\n\t\t\tif ( xr.cameraAutoUpdate === true ) xr.updateCamera( camera );\n\n\t\t\tcamera = xr.getCamera(); // use XR camera for rendering\n\n\t\t}\n\n\t\t//\n\t\tif ( scene.isScene === true ) scene.onBeforeRender( _this, scene, camera, _currentRenderTarget );\n\n\t\tcurrentRenderState = renderStates.get( scene, renderStateStack.length );\n\t\tcurrentRenderState.init();\n\n\t\trenderStateStack.push( currentRenderState );\n\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t_frustum.setFromProjectionMatrix( _projScreenMatrix );\n\n\t\t_localClippingEnabled = this.localClippingEnabled;\n\t\t_clippingEnabled = clipping.init( this.clippingPlanes, _localClippingEnabled, camera );\n\n\t\tcurrentRenderList = renderLists.get( scene, renderListStack.length );\n\t\tcurrentRenderList.init();\n\n\t\trenderListStack.push( currentRenderList );\n\n\t\tprojectObject( scene, camera, 0, _this.sortObjects );\n\n\t\tcurrentRenderList.finish();\n\n\t\tif ( _this.sortObjects === true ) {\n\n\t\t\tcurrentRenderList.sort( _opaqueSort, _transparentSort );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( _clippingEnabled === true ) clipping.beginShadows();\n\n\t\tconst shadowsArray = currentRenderState.state.shadowsArray;\n\n\t\tshadowMap.render( shadowsArray, scene, camera );\n\n\t\tif ( _clippingEnabled === true ) clipping.endShadows();\n\n\t\t//\n\n\t\tif ( this.info.autoReset === true ) this.info.reset();\n\n\t\t//\n\n\t\tbackground.render( currentRenderList, scene );\n\n\t\t// render scene\n\n\t\tcurrentRenderState.setupLights( _this.physicallyCorrectLights );\n\n\t\tif ( camera.isArrayCamera ) {\n\n\t\t\tconst cameras = camera.cameras;\n\n\t\t\tfor ( let i = 0, l = cameras.length; i < l; i ++ ) {\n\n\t\t\t\tconst camera2 = cameras[ i ];\n\n\t\t\t\trenderScene( currentRenderList, scene, camera2, camera2.viewport );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\trenderScene( currentRenderList, scene, camera );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( _currentRenderTarget !== null ) {\n\n\t\t\t// resolve multisample renderbuffers to a single-sample texture if necessary\n\n\t\t\ttextures.updateMultisampleRenderTarget( _currentRenderTarget );\n\n\t\t\t// Generate mipmap if we're using any kind of mipmap filtering\n\n\t\t\ttextures.updateRenderTargetMipmap( _currentRenderTarget );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( scene.isScene === true ) scene.onAfterRender( _this, scene, camera );\n\n\t\t// _gl.finish();\n\n\t\tbindingStates.resetDefaultState();\n\t\t_currentMaterialId = - 1;\n\t\t_currentCamera = null;\n\n\t\trenderStateStack.pop();\n\n\t\tif ( renderStateStack.length > 0 ) {\n\n\t\t\tcurrentRenderState = renderStateStack[ renderStateStack.length - 1 ];\n\n\t\t} else {\n\n\t\t\tcurrentRenderState = null;\n\n\t\t}\n\n\t\trenderListStack.pop();\n\n\t\tif ( renderListStack.length > 0 ) {\n\n\t\t\tcurrentRenderList = renderListStack[ renderListStack.length - 1 ];\n\n\t\t} else {\n\n\t\t\tcurrentRenderList = null;\n\n\t\t}\n\n\t};\n\n\tfunction projectObject( object, camera, groupOrder, sortObjects ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tconst visible = object.layers.test( camera.layers );\n\n\t\tif ( visible ) {\n\n\t\t\tif ( object.isGroup ) {\n\n\t\t\t\tgroupOrder = object.renderOrder;\n\n\t\t\t} else if ( object.isLOD ) {\n\n\t\t\t\tif ( object.autoUpdate === true ) object.update( camera );\n\n\t\t\t} else if ( object.isLight ) {\n\n\t\t\t\tcurrentRenderState.pushLight( object );\n\n\t\t\t\tif ( object.castShadow ) {\n\n\t\t\t\t\tcurrentRenderState.pushShadow( object );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isSprite ) {\n\n\t\t\t\tif ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {\n\n\t\t\t\t\tif ( sortObjects ) {\n\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld )\n\t\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst geometry = objects.update( object );\n\t\t\t\t\tconst material = object.material;\n\n\t\t\t\t\tif ( material.visible ) {\n\n\t\t\t\t\t\tcurrentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\t\t\t// update skeleton only once in a frame\n\n\t\t\t\t\tif ( object.skeleton.frame !== info.render.frame ) {\n\n\t\t\t\t\t\tobject.skeleton.update();\n\t\t\t\t\t\tobject.skeleton.frame = info.render.frame;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {\n\n\t\t\t\t\tif ( sortObjects ) {\n\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld )\n\t\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst geometry = objects.update( object );\n\t\t\t\t\tconst material = object.material;\n\n\t\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\t\tconst groups = geometry.groups;\n\n\t\t\t\t\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\t\tif ( groupMaterial && groupMaterial.visible ) {\n\n\t\t\t\t\t\t\t\tcurrentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( material.visible ) {\n\n\t\t\t\t\t\tcurrentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tprojectObject( children[ i ], camera, groupOrder, sortObjects );\n\n\t\t}\n\n\t}\n\n\tfunction renderScene( currentRenderList, scene, camera, viewport ) {\n\n\t\tconst opaqueObjects = currentRenderList.opaque;\n\t\tconst transmissiveObjects = currentRenderList.transmissive;\n\t\tconst transparentObjects = currentRenderList.transparent;\n\n\t\tcurrentRenderState.setupLightsView( camera );\n\n\t\tif ( transmissiveObjects.length > 0 ) renderTransmissionPass( opaqueObjects, scene, camera );\n\n\t\tif ( viewport ) state.viewport( _currentViewport.copy( viewport ) );\n\n\t\tif ( opaqueObjects.length > 0 ) renderObjects( opaqueObjects, scene, camera );\n\t\tif ( transmissiveObjects.length > 0 ) renderObjects( transmissiveObjects, scene, camera );\n\t\tif ( transparentObjects.length > 0 ) renderObjects( transparentObjects, scene, camera );\n\n\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\n\n\t\tstate.buffers.depth.setTest( true );\n\t\tstate.buffers.depth.setMask( true );\n\t\tstate.buffers.color.setMask( true );\n\n\t\tstate.setPolygonOffset( false );\n\n\t}\n\n\tfunction renderTransmissionPass( opaqueObjects, scene, camera ) {\n\n\t\tconst isWebGL2 = capabilities.isWebGL2;\n\n\t\tif ( _transmissionRenderTarget === null ) {\n\n\t\t\t_transmissionRenderTarget = new WebGLRenderTarget( 1, 1, {\n\t\t\t\tgenerateMipmaps: true,\n\t\t\t\ttype: extensions.has( 'EXT_color_buffer_half_float' ) ? HalfFloatType : UnsignedByteType,\n\t\t\t\tminFilter: LinearMipmapLinearFilter,\n\t\t\t\tsamples: ( isWebGL2 && _antialias === true ) ? 4 : 0\n\t\t\t} );\n\n\t\t}\n\n\t\t_this.getDrawingBufferSize( _vector2 );\n\n\t\tif ( isWebGL2 ) {\n\n\t\t\t_transmissionRenderTarget.setSize( _vector2.x, _vector2.y );\n\n\t\t} else {\n\n\t\t\t_transmissionRenderTarget.setSize( floorPowerOfTwo( _vector2.x ), floorPowerOfTwo( _vector2.y ) );\n\n\t\t}\n\n\t\t//\n\n\t\tconst currentRenderTarget = _this.getRenderTarget();\n\t\t_this.setRenderTarget( _transmissionRenderTarget );\n\t\t_this.clear();\n\n\t\t// Turn off the features which can affect the frag color for opaque objects pass.\n\t\t// Otherwise they are applied twice in opaque objects pass and transmission objects pass.\n\t\tconst currentToneMapping = _this.toneMapping;\n\t\t_this.toneMapping = NoToneMapping;\n\n\t\trenderObjects( opaqueObjects, scene, camera );\n\n\t\t_this.toneMapping = currentToneMapping;\n\n\t\ttextures.updateMultisampleRenderTarget( _transmissionRenderTarget );\n\t\ttextures.updateRenderTargetMipmap( _transmissionRenderTarget );\n\n\t\t_this.setRenderTarget( currentRenderTarget );\n\n\t}\n\n\tfunction renderObjects( renderList, scene, camera ) {\n\n\t\tconst overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;\n\n\t\tfor ( let i = 0, l = renderList.length; i < l; i ++ ) {\n\n\t\t\tconst renderItem = renderList[ i ];\n\n\t\t\tconst object = renderItem.object;\n\t\t\tconst geometry = renderItem.geometry;\n\t\t\tconst material = overrideMaterial === null ? renderItem.material : overrideMaterial;\n\t\t\tconst group = renderItem.group;\n\n\t\t\tif ( object.layers.test( camera.layers ) ) {\n\n\t\t\t\trenderObject( object, scene, camera, geometry, material, group );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction renderObject( object, scene, camera, geometry, material, group ) {\n\n\t\tobject.onBeforeRender( _this, scene, camera, geometry, material, group );\n\n\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\t\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\n\n\t\tmaterial.onBeforeRender( _this, scene, camera, geometry, object, group );\n\n\t\tif ( material.transparent === true && material.side === DoubleSide ) {\n\n\t\t\tmaterial.side = BackSide;\n\t\t\tmaterial.needsUpdate = true;\n\t\t\t_this.renderBufferDirect( camera, scene, geometry, material, object, group );\n\n\t\t\tmaterial.side = FrontSide;\n\t\t\tmaterial.needsUpdate = true;\n\t\t\t_this.renderBufferDirect( camera, scene, geometry, material, object, group );\n\n\t\t\tmaterial.side = DoubleSide;\n\n\t\t} else {\n\n\t\t\t_this.renderBufferDirect( camera, scene, geometry, material, object, group );\n\n\t\t}\n\n\t\tobject.onAfterRender( _this, scene, camera, geometry, material, group );\n\n\t}\n\n\tfunction getProgram( material, scene, object ) {\n\n\t\tif ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...\n\n\t\tconst materialProperties = properties.get( material );\n\n\t\tconst lights = currentRenderState.state.lights;\n\t\tconst shadowsArray = currentRenderState.state.shadowsArray;\n\n\t\tconst lightsStateVersion = lights.state.version;\n\n\t\tconst parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, object );\n\t\tconst programCacheKey = programCache.getProgramCacheKey( parameters );\n\n\t\tlet programs = materialProperties.programs;\n\n\t\t// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change\n\n\t\tmaterialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;\n\t\tmaterialProperties.fog = scene.fog;\n\t\tmaterialProperties.envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || materialProperties.environment );\n\n\t\tif ( programs === undefined ) {\n\n\t\t\t// new material\n\n\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\n\n\t\t\tprograms = new Map();\n\t\t\tmaterialProperties.programs = programs;\n\n\t\t}\n\n\t\tlet program = programs.get( programCacheKey );\n\n\t\tif ( program !== undefined ) {\n\n\t\t\t// early out if program and light state is identical\n\n\t\t\tif ( materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion ) {\n\n\t\t\t\tupdateCommonMaterialProperties( material, parameters );\n\n\t\t\t\treturn program;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tparameters.uniforms = programCache.getUniforms( material );\n\n\t\t\tmaterial.onBuild( object, parameters, _this );\n\n\t\t\tmaterial.onBeforeCompile( parameters, _this );\n\n\t\t\tprogram = programCache.acquireProgram( parameters, programCacheKey );\n\t\t\tprograms.set( programCacheKey, program );\n\n\t\t\tmaterialProperties.uniforms = parameters.uniforms;\n\n\t\t}\n\n\t\tconst uniforms = materialProperties.uniforms;\n\n\t\tif ( ( ! material.isShaderMaterial && ! material.isRawShaderMaterial ) || material.clipping === true ) {\n\n\t\t\tuniforms.clippingPlanes = clipping.uniform;\n\n\t\t}\n\n\t\tupdateCommonMaterialProperties( material, parameters );\n\n\t\t// store the light setup it was created for\n\n\t\tmaterialProperties.needsLights = materialNeedsLights( material );\n\t\tmaterialProperties.lightsStateVersion = lightsStateVersion;\n\n\t\tif ( materialProperties.needsLights ) {\n\n\t\t\t// wire up the material to this renderer's lighting state\n\n\t\t\tuniforms.ambientLightColor.value = lights.state.ambient;\n\t\t\tuniforms.lightProbe.value = lights.state.probe;\n\t\t\tuniforms.directionalLights.value = lights.state.directional;\n\t\t\tuniforms.directionalLightShadows.value = lights.state.directionalShadow;\n\t\t\tuniforms.spotLights.value = lights.state.spot;\n\t\t\tuniforms.spotLightShadows.value = lights.state.spotShadow;\n\t\t\tuniforms.rectAreaLights.value = lights.state.rectArea;\n\t\t\tuniforms.ltc_1.value = lights.state.rectAreaLTC1;\n\t\t\tuniforms.ltc_2.value = lights.state.rectAreaLTC2;\n\t\t\tuniforms.pointLights.value = lights.state.point;\n\t\t\tuniforms.pointLightShadows.value = lights.state.pointShadow;\n\t\t\tuniforms.hemisphereLights.value = lights.state.hemi;\n\n\t\t\tuniforms.directionalShadowMap.value = lights.state.directionalShadowMap;\n\t\t\tuniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;\n\t\t\tuniforms.spotShadowMap.value = lights.state.spotShadowMap;\n\t\t\tuniforms.spotLightMatrix.value = lights.state.spotLightMatrix;\n\t\t\tuniforms.spotLightMap.value = lights.state.spotLightMap;\n\t\t\tuniforms.pointShadowMap.value = lights.state.pointShadowMap;\n\t\t\tuniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;\n\t\t\t// TODO (abelnation): add area lights shadow info to uniforms\n\n\t\t}\n\n\t\tconst progUniforms = program.getUniforms();\n\t\tconst uniformsList = WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );\n\n\t\tmaterialProperties.currentProgram = program;\n\t\tmaterialProperties.uniformsList = uniformsList;\n\n\t\treturn program;\n\n\t}\n\n\tfunction updateCommonMaterialProperties( material, parameters ) {\n\n\t\tconst materialProperties = properties.get( material );\n\n\t\tmaterialProperties.outputEncoding = parameters.outputEncoding;\n\t\tmaterialProperties.instancing = parameters.instancing;\n\t\tmaterialProperties.skinning = parameters.skinning;\n\t\tmaterialProperties.morphTargets = parameters.morphTargets;\n\t\tmaterialProperties.morphNormals = parameters.morphNormals;\n\t\tmaterialProperties.morphColors = parameters.morphColors;\n\t\tmaterialProperties.morphTargetsCount = parameters.morphTargetsCount;\n\t\tmaterialProperties.numClippingPlanes = parameters.numClippingPlanes;\n\t\tmaterialProperties.numIntersection = parameters.numClipIntersection;\n\t\tmaterialProperties.vertexAlphas = parameters.vertexAlphas;\n\t\tmaterialProperties.vertexTangents = parameters.vertexTangents;\n\t\tmaterialProperties.toneMapping = parameters.toneMapping;\n\n\t}\n\n\tfunction setProgram( camera, scene, geometry, material, object ) {\n\n\t\tif ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...\n\n\t\ttextures.resetTextureUnits();\n\n\t\tconst fog = scene.fog;\n\t\tconst environment = material.isMeshStandardMaterial ? scene.environment : null;\n\t\tconst encoding = ( _currentRenderTarget === null ) ? _this.outputEncoding : ( _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.encoding : LinearEncoding );\n\t\tconst envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );\n\t\tconst vertexAlphas = material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4;\n\t\tconst vertexTangents = !! material.normalMap && !! geometry.attributes.tangent;\n\t\tconst morphTargets = !! geometry.morphAttributes.position;\n\t\tconst morphNormals = !! geometry.morphAttributes.normal;\n\t\tconst morphColors = !! geometry.morphAttributes.color;\n\t\tconst toneMapping = material.toneMapped ? _this.toneMapping : NoToneMapping;\n\n\t\tconst morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n\t\tconst morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;\n\n\t\tconst materialProperties = properties.get( material );\n\t\tconst lights = currentRenderState.state.lights;\n\n\t\tif ( _clippingEnabled === true ) {\n\n\t\t\tif ( _localClippingEnabled === true || camera !== _currentCamera ) {\n\n\t\t\t\tconst useCache =\n\t\t\t\t\tcamera === _currentCamera &&\n\t\t\t\t\tmaterial.id === _currentMaterialId;\n\n\t\t\t\t// we might want to call this function with some ClippingGroup\n\t\t\t\t// object instead of the material, once it becomes feasible\n\t\t\t\t// (#8465, #8379)\n\t\t\t\tclipping.setState( material, camera, useCache );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tlet needsProgramChange = false;\n\n\t\tif ( material.version === materialProperties.__version ) {\n\n\t\t\tif ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {\n\n\t\t\t\tneedsProgramChange = true;\n\n\t\t\t} else if ( materialProperties.outputEncoding !== encoding ) {\n\n\t\t\t\tneedsProgramChange = true;\n\n\t\t\t} else if ( object.isInstancedMesh && materialProperties.instancing === false ) {\n\n\t\t\t\tneedsProgramChange = true;\n\n\t\t\t} else if ( ! object.isInstancedMesh && materialProperties.instancing === true ) {\n\n\t\t\t\tneedsProgramChange = true;\n\n\t\t\t} else if ( object.isSkinnedMesh && materialProperties.skinning === false ) {\n\n\t\t\t\tneedsProgramChange = true;\n\n\t\t\t} else if ( ! object.isSkinnedMesh && materialProperties.skinning === true ) {\n\n\t\t\t\tneedsProgramChange = true;\n\n\t\t\t} else if ( materialProperties.envMap !== envMap ) {\n\n\t\t\t\tneedsProgramChange = true;\n\n\t\t\t} else if ( material.fog === true && materialProperties.fog !== fog ) {\n\n\t\t\t\tneedsProgramChange = true;\n\n\t\t\t} else if ( materialProperties.numClippingPlanes !== undefined &&\n\t\t\t\t( materialProperties.numClippingPlanes !== clipping.numPlanes ||\n\t\t\t\tmaterialProperties.numIntersection !== clipping.numIntersection ) ) {\n\n\t\t\t\tneedsProgramChange = true;\n\n\t\t\t} else if ( materialProperties.vertexAlphas !== vertexAlphas ) {\n\n\t\t\t\tneedsProgramChange = true;\n\n\t\t\t} else if ( materialProperties.vertexTangents !== vertexTangents ) {\n\n\t\t\t\tneedsProgramChange = true;\n\n\t\t\t} else if ( materialProperties.morphTargets !== morphTargets ) {\n\n\t\t\t\tneedsProgramChange = true;\n\n\t\t\t} else if ( materialProperties.morphNormals !== morphNormals ) {\n\n\t\t\t\tneedsProgramChange = true;\n\n\t\t\t} else if ( materialProperties.morphColors !== morphColors ) {\n\n\t\t\t\tneedsProgramChange = true;\n\n\t\t\t} else if ( materialProperties.toneMapping !== toneMapping ) {\n\n\t\t\t\tneedsProgramChange = true;\n\n\t\t\t} else if ( capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount ) {\n\n\t\t\t\tneedsProgramChange = true;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tneedsProgramChange = true;\n\t\t\tmaterialProperties.__version = material.version;\n\n\t\t}\n\n\t\t//\n\n\t\tlet program = materialProperties.currentProgram;\n\n\t\tif ( needsProgramChange === true ) {\n\n\t\t\tprogram = getProgram( material, scene, object );\n\n\t\t}\n\n\t\tlet refreshProgram = false;\n\t\tlet refreshMaterial = false;\n\t\tlet refreshLights = false;\n\n\t\tconst p_uniforms = program.getUniforms(),\n\t\t\tm_uniforms = materialProperties.uniforms;\n\n\t\tif ( state.useProgram( program.program ) ) {\n\n\t\t\trefreshProgram = true;\n\t\t\trefreshMaterial = true;\n\t\t\trefreshLights = true;\n\n\t\t}\n\n\t\tif ( material.id !== _currentMaterialId ) {\n\n\t\t\t_currentMaterialId = material.id;\n\n\t\t\trefreshMaterial = true;\n\n\t\t}\n\n\t\tif ( refreshProgram || _currentCamera !== camera ) {\n\n\t\t\tp_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );\n\n\t\t\tif ( capabilities.logarithmicDepthBuffer ) {\n\n\t\t\t\tp_uniforms.setValue( _gl, 'logDepthBufFC',\n\t\t\t\t\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\n\n\t\t\t}\n\n\t\t\tif ( _currentCamera !== camera ) {\n\n\t\t\t\t_currentCamera = camera;\n\n\t\t\t\t// lighting uniforms depend on the camera so enforce an update\n\t\t\t\t// now, in case this material supports lights - or later, when\n\t\t\t\t// the next material that does gets activated:\n\n\t\t\t\trefreshMaterial = true;\t\t// set to true on material change\n\t\t\t\trefreshLights = true;\t\t// remains set until update done\n\n\t\t\t}\n\n\t\t\t// load material specific uniforms\n\t\t\t// (shader material also gets them for the sake of genericity)\n\n\t\t\tif ( material.isShaderMaterial ||\n\t\t\t\tmaterial.isMeshPhongMaterial ||\n\t\t\t\tmaterial.isMeshToonMaterial ||\n\t\t\t\tmaterial.isMeshStandardMaterial ||\n\t\t\t\tmaterial.envMap ) {\n\n\t\t\t\tconst uCamPos = p_uniforms.map.cameraPosition;\n\n\t\t\t\tif ( uCamPos !== undefined ) {\n\n\t\t\t\t\tuCamPos.setValue( _gl,\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material.isMeshPhongMaterial ||\n\t\t\t\tmaterial.isMeshToonMaterial ||\n\t\t\t\tmaterial.isMeshLambertMaterial ||\n\t\t\t\tmaterial.isMeshBasicMaterial ||\n\t\t\t\tmaterial.isMeshStandardMaterial ||\n\t\t\t\tmaterial.isShaderMaterial ) {\n\n\t\t\t\tp_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );\n\n\t\t\t}\n\n\t\t\tif ( material.isMeshPhongMaterial ||\n\t\t\t\tmaterial.isMeshToonMaterial ||\n\t\t\t\tmaterial.isMeshLambertMaterial ||\n\t\t\t\tmaterial.isMeshBasicMaterial ||\n\t\t\t\tmaterial.isMeshStandardMaterial ||\n\t\t\t\tmaterial.isShaderMaterial ||\n\t\t\t\tmaterial.isShadowMaterial ||\n\t\t\t\tobject.isSkinnedMesh ) {\n\n\t\t\t\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// skinning and morph target uniforms must be set even if material didn't change\n\t\t// auto-setting of texture unit for bone and morph texture must go before other textures\n\t\t// otherwise textures used for skinning and morphing can take over texture units reserved for other material textures\n\n\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\n\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\n\n\t\t\tconst skeleton = object.skeleton;\n\n\t\t\tif ( skeleton ) {\n\n\t\t\t\tif ( capabilities.floatVertexTextures ) {\n\n\t\t\t\t\tif ( skeleton.boneTexture === null ) skeleton.computeBoneTexture();\n\n\t\t\t\t\tp_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );\n\t\t\t\t\tp_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst morphAttributes = geometry.morphAttributes;\n\n\t\tif ( morphAttributes.position !== undefined || morphAttributes.normal !== undefined || ( morphAttributes.color !== undefined && capabilities.isWebGL2 === true ) ) {\n\n\t\t\tmorphtargets.update( object, geometry, material, program );\n\n\t\t}\n\n\t\tif ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {\n\n\t\t\tmaterialProperties.receiveShadow = object.receiveShadow;\n\t\t\tp_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );\n\n\t\t}\n\n\t\t// https://github.com/mrdoob/three.js/pull/24467#issuecomment-1209031512\n\n\t\tif ( material.isMeshGouraudMaterial && material.envMap !== null ) {\n\n\t\t\tm_uniforms.envMap.value = envMap;\n\n\t\t\tm_uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) ? - 1 : 1;\n\n\t\t}\n\n\t\tif ( refreshMaterial ) {\n\n\t\t\tp_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );\n\n\t\t\tif ( materialProperties.needsLights ) {\n\n\t\t\t\t// the current material requires lighting info\n\n\t\t\t\t// note: all lighting uniforms are always set correctly\n\t\t\t\t// they simply reference the renderer's state for their\n\t\t\t\t// values\n\t\t\t\t//\n\t\t\t\t// use the current material's .needsUpdate flags to set\n\t\t\t\t// the GL state when required\n\n\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\n\n\t\t\t}\n\n\t\t\t// refresh uniforms common to several materials\n\n\t\t\tif ( fog && material.fog === true ) {\n\n\t\t\t\tmaterials.refreshFogUniforms( m_uniforms, fog );\n\n\t\t\t}\n\n\t\t\tmaterials.refreshMaterialUniforms( m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget );\n\n\t\t\tWebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );\n\n\t\t}\n\n\t\tif ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {\n\n\t\t\tWebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );\n\t\t\tmaterial.uniformsNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( material.isSpriteMaterial ) {\n\n\t\t\tp_uniforms.setValue( _gl, 'center', object.center );\n\n\t\t}\n\n\t\t// common matrices\n\n\t\tp_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );\n\t\tp_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );\n\t\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\n\n\t\t// UBOs\n\n\t\tif ( material.isShaderMaterial || material.isRawShaderMaterial ) {\n\n\t\t\tconst groups = material.uniformsGroups;\n\n\t\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\tif ( capabilities.isWebGL2 ) {\n\n\t\t\t\t\tconst group = groups[ i ];\n\n\t\t\t\t\tuniformsGroups.update( group, program );\n\t\t\t\t\tuniformsGroups.bind( group, program );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn program;\n\n\t}\n\n\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\n\n\tfunction markUniformsLightsNeedsUpdate( uniforms, value ) {\n\n\t\tuniforms.ambientLightColor.needsUpdate = value;\n\t\tuniforms.lightProbe.needsUpdate = value;\n\n\t\tuniforms.directionalLights.needsUpdate = value;\n\t\tuniforms.directionalLightShadows.needsUpdate = value;\n\t\tuniforms.pointLights.needsUpdate = value;\n\t\tuniforms.pointLightShadows.needsUpdate = value;\n\t\tuniforms.spotLights.needsUpdate = value;\n\t\tuniforms.spotLightShadows.needsUpdate = value;\n\t\tuniforms.rectAreaLights.needsUpdate = value;\n\t\tuniforms.hemisphereLights.needsUpdate = value;\n\n\t}\n\n\tfunction materialNeedsLights( material ) {\n\n\t\treturn material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||\n\t\t\tmaterial.isMeshStandardMaterial || material.isShadowMaterial ||\n\t\t\t( material.isShaderMaterial && material.lights === true );\n\n\t}\n\n\tthis.getActiveCubeFace = function () {\n\n\t\treturn _currentActiveCubeFace;\n\n\t};\n\n\tthis.getActiveMipmapLevel = function () {\n\n\t\treturn _currentActiveMipmapLevel;\n\n\t};\n\n\tthis.getRenderTarget = function () {\n\n\t\treturn _currentRenderTarget;\n\n\t};\n\n\tthis.setRenderTargetTextures = function ( renderTarget, colorTexture, depthTexture ) {\n\n\t\tproperties.get( renderTarget.texture ).__webglTexture = colorTexture;\n\t\tproperties.get( renderTarget.depthTexture ).__webglTexture = depthTexture;\n\n\t\tconst renderTargetProperties = properties.get( renderTarget );\n\t\trenderTargetProperties.__hasExternalTextures = true;\n\n\t\tif ( renderTargetProperties.__hasExternalTextures ) {\n\n\t\t\trenderTargetProperties.__autoAllocateDepthBuffer = depthTexture === undefined;\n\n\t\t\tif ( ! renderTargetProperties.__autoAllocateDepthBuffer ) {\n\n\t\t\t\t// The multisample_render_to_texture extension doesn't work properly if there\n\t\t\t\t// are midframe flushes and an external depth buffer. Disable use of the extension.\n\t\t\t\tif ( extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided' );\n\t\t\t\t\trenderTargetProperties.__useRenderToTexture = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.setRenderTargetFramebuffer = function ( renderTarget, defaultFramebuffer ) {\n\n\t\tconst renderTargetProperties = properties.get( renderTarget );\n\t\trenderTargetProperties.__webglFramebuffer = defaultFramebuffer;\n\t\trenderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === undefined;\n\n\t};\n\n\tthis.setRenderTarget = function ( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {\n\n\t\t_currentRenderTarget = renderTarget;\n\t\t_currentActiveCubeFace = activeCubeFace;\n\t\t_currentActiveMipmapLevel = activeMipmapLevel;\n\n\t\tlet useDefaultFramebuffer = true;\n\t\tlet framebuffer = null;\n\t\tlet isCube = false;\n\t\tlet isRenderTarget3D = false;\n\n\t\tif ( renderTarget ) {\n\n\t\t\tconst renderTargetProperties = properties.get( renderTarget );\n\n\t\t\tif ( renderTargetProperties.__useDefaultFramebuffer !== undefined ) {\n\n\t\t\t\t// We need to make sure to rebind the framebuffer.\n\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\t\t\t\tuseDefaultFramebuffer = false;\n\n\t\t\t} else if ( renderTargetProperties.__webglFramebuffer === undefined ) {\n\n\t\t\t\ttextures.setupRenderTarget( renderTarget );\n\n\t\t\t} else if ( renderTargetProperties.__hasExternalTextures ) {\n\n\t\t\t\t// Color and depth texture must be rebound in order for the swapchain to update.\n\t\t\t\ttextures.rebindTextures( renderTarget, properties.get( renderTarget.texture ).__webglTexture, properties.get( renderTarget.depthTexture ).__webglTexture );\n\n\t\t\t}\n\n\t\t\tconst texture = renderTarget.texture;\n\n\t\t\tif ( texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {\n\n\t\t\t\tisRenderTarget3D = true;\n\n\t\t\t}\n\n\t\t\tconst __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\n\t\t\tif ( renderTarget.isWebGLCubeRenderTarget ) {\n\n\t\t\t\tframebuffer = __webglFramebuffer[ activeCubeFace ];\n\t\t\t\tisCube = true;\n\n\t\t\t} else if ( ( capabilities.isWebGL2 && renderTarget.samples > 0 ) && textures.useMultisampledRTT( renderTarget ) === false ) {\n\n\t\t\t\tframebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;\n\n\t\t\t} else {\n\n\t\t\t\tframebuffer = __webglFramebuffer;\n\n\t\t\t}\n\n\t\t\t_currentViewport.copy( renderTarget.viewport );\n\t\t\t_currentScissor.copy( renderTarget.scissor );\n\t\t\t_currentScissorTest = renderTarget.scissorTest;\n\n\t\t} else {\n\n\t\t\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();\n\t\t\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();\n\t\t\t_currentScissorTest = _scissorTest;\n\n\t\t}\n\n\t\tconst framebufferBound = state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\tif ( framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer ) {\n\n\t\t\tstate.drawBuffers( renderTarget, framebuffer );\n\n\t\t}\n\n\t\tstate.viewport( _currentViewport );\n\t\tstate.scissor( _currentScissor );\n\t\tstate.setScissorTest( _currentScissorTest );\n\n\t\tif ( isCube ) {\n\n\t\t\tconst textureProperties = properties.get( renderTarget.texture );\n\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel );\n\n\t\t} else if ( isRenderTarget3D ) {\n\n\t\t\tconst textureProperties = properties.get( renderTarget.texture );\n\t\t\tconst layer = activeCubeFace || 0;\n\t\t\t_gl.framebufferTextureLayer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer );\n\n\t\t}\n\n\t\t_currentMaterialId = - 1; // reset current material to ensure correct uniform bindings\n\n\t};\n\n\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {\n\n\t\tif ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tlet framebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\n\t\tif ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {\n\n\t\t\tframebuffer = framebuffer[ activeCubeFaceIndex ];\n\n\t\t}\n\n\t\tif ( framebuffer ) {\n\n\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\ttry {\n\n\t\t\t\tconst texture = renderTarget.texture;\n\t\t\t\tconst textureFormat = texture.format;\n\t\t\t\tconst textureType = texture.type;\n\n\t\t\t\tif ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tconst halfFloatSupportedByExt = ( textureType === HalfFloatType ) && ( extensions.has( 'EXT_color_buffer_half_float' ) || ( capabilities.isWebGL2 && extensions.has( 'EXT_color_buffer_float' ) ) );\n\n\t\t\t\tif ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // Edge and Chrome Mac < 52 (#9513)\n\t\t\t\t\t! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.has( 'OES_texture_float' ) || extensions.has( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox\n\t\t\t\t\t! halfFloatSupportedByExt ) {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\n\t\t\t\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\n\n\t\t\t\t\t_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );\n\n\t\t\t\t}\n\n\t\t\t} finally {\n\n\t\t\t\t// restore framebuffer of current render target if necessary\n\n\t\t\t\tconst framebuffer = ( _currentRenderTarget !== null ) ? properties.get( _currentRenderTarget ).__webglFramebuffer : null;\n\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.copyFramebufferToTexture = function ( position, texture, level = 0 ) {\n\n\t\tconst levelScale = Math.pow( 2, - level );\n\t\tconst width = Math.floor( texture.image.width * levelScale );\n\t\tconst height = Math.floor( texture.image.height * levelScale );\n\n\t\ttextures.setTexture2D( texture, 0 );\n\n\t\t_gl.copyTexSubImage2D( _gl.TEXTURE_2D, level, 0, 0, position.x, position.y, width, height );\n\n\t\tstate.unbindTexture();\n\n\t};\n\n\tthis.copyTextureToTexture = function ( position, srcTexture, dstTexture, level = 0 ) {\n\n\t\tconst width = srcTexture.image.width;\n\t\tconst height = srcTexture.image.height;\n\t\tconst glFormat = utils.convert( dstTexture.format );\n\t\tconst glType = utils.convert( dstTexture.type );\n\n\t\ttextures.setTexture2D( dstTexture, 0 );\n\n\t\t// As another texture upload may have changed pixelStorei\n\t\t// parameters, make sure they are correct for the dstTexture\n\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );\n\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );\n\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );\n\n\t\tif ( srcTexture.isDataTexture ) {\n\n\t\t\t_gl.texSubImage2D( _gl.TEXTURE_2D, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );\n\n\t\t} else {\n\n\t\t\tif ( srcTexture.isCompressedTexture ) {\n\n\t\t\t\t_gl.compressedTexSubImage2D( _gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[ 0 ].width, srcTexture.mipmaps[ 0 ].height, glFormat, srcTexture.mipmaps[ 0 ].data );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.texSubImage2D( _gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Generate mipmaps only when copying level 0\n\t\tif ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\n\t\tstate.unbindTexture();\n\n\t};\n\n\tthis.copyTextureToTexture3D = function ( sourceBox, position, srcTexture, dstTexture, level = 0 ) {\n\n\t\tif ( _this.isWebGL1Renderer ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst width = sourceBox.max.x - sourceBox.min.x + 1;\n\t\tconst height = sourceBox.max.y - sourceBox.min.y + 1;\n\t\tconst depth = sourceBox.max.z - sourceBox.min.z + 1;\n\t\tconst glFormat = utils.convert( dstTexture.format );\n\t\tconst glType = utils.convert( dstTexture.type );\n\t\tlet glTarget;\n\n\t\tif ( dstTexture.isData3DTexture ) {\n\n\t\t\ttextures.setTexture3D( dstTexture, 0 );\n\t\t\tglTarget = _gl.TEXTURE_3D;\n\n\t\t} else if ( dstTexture.isDataArrayTexture ) {\n\n\t\t\ttextures.setTexture2DArray( dstTexture, 0 );\n\t\t\tglTarget = _gl.TEXTURE_2D_ARRAY;\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );\n\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );\n\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );\n\n\t\tconst unpackRowLen = _gl.getParameter( _gl.UNPACK_ROW_LENGTH );\n\t\tconst unpackImageHeight = _gl.getParameter( _gl.UNPACK_IMAGE_HEIGHT );\n\t\tconst unpackSkipPixels = _gl.getParameter( _gl.UNPACK_SKIP_PIXELS );\n\t\tconst unpackSkipRows = _gl.getParameter( _gl.UNPACK_SKIP_ROWS );\n\t\tconst unpackSkipImages = _gl.getParameter( _gl.UNPACK_SKIP_IMAGES );\n\n\t\tconst image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[ 0 ] : srcTexture.image;\n\n\t\t_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, image.width );\n\t\t_gl.pixelStorei( _gl.UNPACK_IMAGE_HEIGHT, image.height );\n\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, sourceBox.min.x );\n\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, sourceBox.min.y );\n\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_IMAGES, sourceBox.min.z );\n\n\t\tif ( srcTexture.isDataTexture || srcTexture.isData3DTexture ) {\n\n\t\t\t_gl.texSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data );\n\n\t\t} else {\n\n\t\t\tif ( srcTexture.isCompressedArrayTexture ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.' );\n\t\t\t\t_gl.compressedTexSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.texSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image );\n\n\t\t\t}\n\n\t\t}\n\n\t\t_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, unpackRowLen );\n\t\t_gl.pixelStorei( _gl.UNPACK_IMAGE_HEIGHT, unpackImageHeight );\n\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, unpackSkipPixels );\n\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, unpackSkipRows );\n\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_IMAGES, unpackSkipImages );\n\n\t\t// Generate mipmaps only when copying level 0\n\t\tif ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( glTarget );\n\n\t\tstate.unbindTexture();\n\n\t};\n\n\tthis.initTexture = function ( texture ) {\n\n\t\tif ( texture.isCubeTexture ) {\n\n\t\t\ttextures.setTextureCube( texture, 0 );\n\n\t\t} else if ( texture.isData3DTexture ) {\n\n\t\t\ttextures.setTexture3D( texture, 0 );\n\n\t\t} else if ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {\n\n\t\t\ttextures.setTexture2DArray( texture, 0 );\n\n\t\t} else {\n\n\t\t\ttextures.setTexture2D( texture, 0 );\n\n\t\t}\n\n\t\tstate.unbindTexture();\n\n\t};\n\n\tthis.resetState = function () {\n\n\t\t_currentActiveCubeFace = 0;\n\t\t_currentActiveMipmapLevel = 0;\n\t\t_currentRenderTarget = null;\n\n\t\tstate.reset();\n\t\tbindingStates.reset();\n\n\t};\n\n\tif ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {\n\n\t\t__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );\n\n\t}\n\n}\n\nexport { WebGLRenderer };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}