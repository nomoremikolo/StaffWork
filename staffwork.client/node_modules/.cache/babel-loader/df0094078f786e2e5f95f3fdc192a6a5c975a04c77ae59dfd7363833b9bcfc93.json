{"ast":null,"code":"import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Shape } from '../extras/core/Shape.js';\nimport { ShapeUtils } from '../extras/ShapeUtils.js';\nimport { Vector2 } from '../math/Vector2.js';\nclass ShapeGeometry extends BufferGeometry {\n  constructor() {\n    let shapes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Shape([new Vector2(0, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]);\n    let curveSegments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 12;\n    super();\n    this.type = 'ShapeGeometry';\n    this.parameters = {\n      shapes: shapes,\n      curveSegments: curveSegments\n    };\n\n    // buffers\n\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n\n    // helper variables\n\n    let groupStart = 0;\n    let groupCount = 0;\n\n    // allow single and array values for \"shapes\" parameter\n\n    if (Array.isArray(shapes) === false) {\n      addShape(shapes);\n    } else {\n      for (let i = 0; i < shapes.length; i++) {\n        addShape(shapes[i]);\n        this.addGroup(groupStart, groupCount, i); // enables MultiMaterial support\n\n        groupStart += groupCount;\n        groupCount = 0;\n      }\n    }\n\n    // build geometry\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\n    // helper functions\n\n    function addShape(shape) {\n      const indexOffset = vertices.length / 3;\n      const points = shape.extractPoints(curveSegments);\n      let shapeVertices = points.shape;\n      const shapeHoles = points.holes;\n\n      // check direction of vertices\n\n      if (ShapeUtils.isClockWise(shapeVertices) === false) {\n        shapeVertices = shapeVertices.reverse();\n      }\n      for (let i = 0, l = shapeHoles.length; i < l; i++) {\n        const shapeHole = shapeHoles[i];\n        if (ShapeUtils.isClockWise(shapeHole) === true) {\n          shapeHoles[i] = shapeHole.reverse();\n        }\n      }\n      const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);\n\n      // join vertices of inner and outer paths to a single array\n\n      for (let i = 0, l = shapeHoles.length; i < l; i++) {\n        const shapeHole = shapeHoles[i];\n        shapeVertices = shapeVertices.concat(shapeHole);\n      }\n\n      // vertices, normals, uvs\n\n      for (let i = 0, l = shapeVertices.length; i < l; i++) {\n        const vertex = shapeVertices[i];\n        vertices.push(vertex.x, vertex.y, 0);\n        normals.push(0, 0, 1);\n        uvs.push(vertex.x, vertex.y); // world uvs\n      }\n\n      // indices\n\n      for (let i = 0, l = faces.length; i < l; i++) {\n        const face = faces[i];\n        const a = face[0] + indexOffset;\n        const b = face[1] + indexOffset;\n        const c = face[2] + indexOffset;\n        indices.push(a, b, c);\n        groupCount += 3;\n      }\n    }\n  }\n  toJSON() {\n    const data = super.toJSON();\n    const shapes = this.parameters.shapes;\n    return toJSON(shapes, data);\n  }\n  static fromJSON(data, shapes) {\n    const geometryShapes = [];\n    for (let j = 0, jl = data.shapes.length; j < jl; j++) {\n      const shape = shapes[data.shapes[j]];\n      geometryShapes.push(shape);\n    }\n    return new ShapeGeometry(geometryShapes, data.curveSegments);\n  }\n}\nfunction toJSON(shapes, data) {\n  data.shapes = [];\n  if (Array.isArray(shapes)) {\n    for (let i = 0, l = shapes.length; i < l; i++) {\n      const shape = shapes[i];\n      data.shapes.push(shape.uuid);\n    }\n  } else {\n    data.shapes.push(shapes.uuid);\n  }\n  return data;\n}\nexport { ShapeGeometry };","map":{"version":3,"names":["BufferGeometry","Float32BufferAttribute","Shape","ShapeUtils","Vector2","ShapeGeometry","constructor","shapes","curveSegments","type","parameters","indices","vertices","normals","uvs","groupStart","groupCount","Array","isArray","addShape","i","length","addGroup","setIndex","setAttribute","shape","indexOffset","points","extractPoints","shapeVertices","shapeHoles","holes","isClockWise","reverse","l","shapeHole","faces","triangulateShape","concat","vertex","push","x","y","face","a","b","c","toJSON","data","fromJSON","geometryShapes","j","jl","uuid"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/geometries/ShapeGeometry.js"],"sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Shape } from '../extras/core/Shape.js';\nimport { ShapeUtils } from '../extras/ShapeUtils.js';\nimport { Vector2 } from '../math/Vector2.js';\n\nclass ShapeGeometry extends BufferGeometry {\n\n\tconstructor( shapes = new Shape( [ new Vector2( 0, 0.5 ), new Vector2( - 0.5, - 0.5 ), new Vector2( 0.5, - 0.5 ) ] ), curveSegments = 12 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'ShapeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tshapes: shapes,\n\t\t\tcurveSegments: curveSegments\n\t\t};\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tlet groupStart = 0;\n\t\tlet groupCount = 0;\n\n\t\t// allow single and array values for \"shapes\" parameter\n\n\t\tif ( Array.isArray( shapes ) === false ) {\n\n\t\t\taddShape( shapes );\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0; i < shapes.length; i ++ ) {\n\n\t\t\t\taddShape( shapes[ i ] );\n\n\t\t\t\tthis.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support\n\n\t\t\t\tgroupStart += groupCount;\n\t\t\t\tgroupCount = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\n\t\t// helper functions\n\n\t\tfunction addShape( shape ) {\n\n\t\t\tconst indexOffset = vertices.length / 3;\n\t\t\tconst points = shape.extractPoints( curveSegments );\n\n\t\t\tlet shapeVertices = points.shape;\n\t\t\tconst shapeHoles = points.holes;\n\n\t\t\t// check direction of vertices\n\n\t\t\tif ( ShapeUtils.isClockWise( shapeVertices ) === false ) {\n\n\t\t\t\tshapeVertices = shapeVertices.reverse();\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {\n\n\t\t\t\tconst shapeHole = shapeHoles[ i ];\n\n\t\t\t\tif ( ShapeUtils.isClockWise( shapeHole ) === true ) {\n\n\t\t\t\t\tshapeHoles[ i ] = shapeHole.reverse();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );\n\n\t\t\t// join vertices of inner and outer paths to a single array\n\n\t\t\tfor ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {\n\n\t\t\t\tconst shapeHole = shapeHoles[ i ];\n\t\t\t\tshapeVertices = shapeVertices.concat( shapeHole );\n\n\t\t\t}\n\n\t\t\t// vertices, normals, uvs\n\n\t\t\tfor ( let i = 0, l = shapeVertices.length; i < l; i ++ ) {\n\n\t\t\t\tconst vertex = shapeVertices[ i ];\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, 0 );\n\t\t\t\tnormals.push( 0, 0, 1 );\n\t\t\t\tuvs.push( vertex.x, vertex.y ); // world uvs\n\n\t\t\t}\n\n\t\t\t// indices\n\n\t\t\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tconst face = faces[ i ];\n\n\t\t\t\tconst a = face[ 0 ] + indexOffset;\n\t\t\t\tconst b = face[ 1 ] + indexOffset;\n\t\t\t\tconst c = face[ 2 ] + indexOffset;\n\n\t\t\t\tindices.push( a, b, c );\n\t\t\t\tgroupCount += 3;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tconst shapes = this.parameters.shapes;\n\n\t\treturn toJSON( shapes, data );\n\n\t}\n\n\tstatic fromJSON( data, shapes ) {\n\n\t\tconst geometryShapes = [];\n\n\t\tfor ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {\n\n\t\t\tconst shape = shapes[ data.shapes[ j ] ];\n\n\t\t\tgeometryShapes.push( shape );\n\n\t\t}\n\n\t\treturn new ShapeGeometry( geometryShapes, data.curveSegments );\n\n\t}\n\n}\n\nfunction toJSON( shapes, data ) {\n\n\tdata.shapes = [];\n\n\tif ( Array.isArray( shapes ) ) {\n\n\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tconst shape = shapes[ i ];\n\n\t\t\tdata.shapes.push( shape.uuid );\n\n\t\t}\n\n\t} else {\n\n\t\tdata.shapes.push( shapes.uuid );\n\n\t}\n\n\treturn data;\n\n}\n\nexport { ShapeGeometry };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}