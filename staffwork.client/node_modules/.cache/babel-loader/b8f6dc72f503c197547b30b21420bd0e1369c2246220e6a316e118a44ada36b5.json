{"ast":null,"code":"import { CubeReflectionMapping, CubeRefractionMapping, CubeUVReflectionMapping, LinearEncoding, LinearFilter, NoToneMapping, NoBlending, RGBAFormat, HalfFloatType } from '../constants.js';\nimport { BufferAttribute } from '../core/BufferAttribute.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Mesh } from '../objects/Mesh.js';\nimport { OrthographicCamera } from '../cameras/OrthographicCamera.js';\nimport { PerspectiveCamera } from '../cameras/PerspectiveCamera.js';\nimport { ShaderMaterial } from '../materials/ShaderMaterial.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Color } from '../math/Color.js';\nimport { WebGLRenderTarget } from '../renderers/WebGLRenderTarget.js';\nimport { MeshBasicMaterial } from '../materials/MeshBasicMaterial.js';\nimport { BoxGeometry } from '../geometries/BoxGeometry.js';\nimport { BackSide } from '../constants.js';\nconst LOD_MIN = 4;\n\n// The standard deviations (radians) associated with the extra mips. These are\n// chosen to approximate a Trowbridge-Reitz distribution function times the\n// geometric shadowing function. These sigma values squared must match the\n// variance #defines in cube_uv_reflection_fragment.glsl.js.\nconst EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];\n\n// The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\nconst MAX_SAMPLES = 20;\nconst _flatCamera = /*@__PURE__*/new OrthographicCamera();\nconst _clearColor = /*@__PURE__*/new Color();\nlet _oldTarget = null;\n\n// Golden Ratio\nconst PHI = (1 + Math.sqrt(5)) / 2;\nconst INV_PHI = 1 / PHI;\n\n// Vertices of a dodecahedron (except the opposites, which represent the\n// same axis), used as axis directions evenly spread on a sphere.\nconst _axisDirections = [/*@__PURE__*/new Vector3(1, 1, 1), /*@__PURE__*/new Vector3(-1, 1, 1), /*@__PURE__*/new Vector3(1, 1, -1), /*@__PURE__*/new Vector3(-1, 1, -1), /*@__PURE__*/new Vector3(0, PHI, INV_PHI), /*@__PURE__*/new Vector3(0, PHI, -INV_PHI), /*@__PURE__*/new Vector3(INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(-INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(PHI, INV_PHI, 0), /*@__PURE__*/new Vector3(-PHI, INV_PHI, 0)];\n\n/**\n * This class generates a Prefiltered, Mipmapped Radiance Environment Map\n * (PMREM) from a cubeMap environment texture. This allows different levels of\n * blur to be quickly accessed based on material roughness. It is packed into a\n * special CubeUV format that allows us to perform custom interpolation so that\n * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\n * chain, it only goes down to the LOD_MIN level (above), and then creates extra\n * even more filtered 'mips' at the same LOD_MIN resolution, associated with\n * higher roughness levels. In this way we maintain resolution to smoothly\n * interpolate diffuse lighting while limiting sampling computation.\n *\n * Paper: Fast, Accurate Image-Based Lighting\n * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view\n*/\n\nclass PMREMGenerator {\n  constructor(renderer) {\n    this._renderer = renderer;\n    this._pingPongRenderTarget = null;\n    this._lodMax = 0;\n    this._cubeSize = 0;\n    this._lodPlanes = [];\n    this._sizeLods = [];\n    this._sigmas = [];\n    this._blurMaterial = null;\n    this._cubemapMaterial = null;\n    this._equirectMaterial = null;\n    this._compileMaterial(this._blurMaterial);\n  }\n\n  /**\n   * Generates a PMREM from a supplied Scene, which can be faster than using an\n   * image if networking bandwidth is low. Optional sigma specifies a blur radius\n   * in radians to be applied to the scene before PMREM generation. Optional near\n   * and far planes ensure the scene is rendered in its entirety (the cubeCamera\n   * is placed at the origin).\n   */\n  fromScene(scene) {\n    let sigma = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let near = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.1;\n    let far = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 100;\n    _oldTarget = this._renderer.getRenderTarget();\n    this._setSize(256);\n    const cubeUVRenderTarget = this._allocateTargets();\n    cubeUVRenderTarget.depthBuffer = true;\n    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);\n    if (sigma > 0) {\n      this._blur(cubeUVRenderTarget, 0, 0, sigma);\n    }\n    this._applyPMREM(cubeUVRenderTarget);\n    this._cleanup(cubeUVRenderTarget);\n    return cubeUVRenderTarget;\n  }\n\n  /**\n   * Generates a PMREM from an equirectangular texture, which can be either LDR\n   * or HDR. The ideal input image size is 1k (1024 x 512),\n   * as this matches best with the 256 x 256 cubemap output.\n   */\n  fromEquirectangular(equirectangular) {\n    let renderTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return this._fromTexture(equirectangular, renderTarget);\n  }\n\n  /**\n   * Generates a PMREM from an cubemap texture, which can be either LDR\n   * or HDR. The ideal input cube size is 256 x 256,\n   * as this matches best with the 256 x 256 cubemap output.\n   */\n  fromCubemap(cubemap) {\n    let renderTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return this._fromTexture(cubemap, renderTarget);\n  }\n\n  /**\n   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\n   * your texture's network fetch for increased concurrency.\n   */\n  compileCubemapShader() {\n    if (this._cubemapMaterial === null) {\n      this._cubemapMaterial = _getCubemapMaterial();\n      this._compileMaterial(this._cubemapMaterial);\n    }\n  }\n\n  /**\n   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\n   * your texture's network fetch for increased concurrency.\n   */\n  compileEquirectangularShader() {\n    if (this._equirectMaterial === null) {\n      this._equirectMaterial = _getEquirectMaterial();\n      this._compileMaterial(this._equirectMaterial);\n    }\n  }\n\n  /**\n   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\n   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\n   * one of them will cause any others to also become unusable.\n   */\n  dispose() {\n    this._dispose();\n    if (this._cubemapMaterial !== null) this._cubemapMaterial.dispose();\n    if (this._equirectMaterial !== null) this._equirectMaterial.dispose();\n  }\n\n  // private interface\n\n  _setSize(cubeSize) {\n    this._lodMax = Math.floor(Math.log2(cubeSize));\n    this._cubeSize = Math.pow(2, this._lodMax);\n  }\n  _dispose() {\n    if (this._blurMaterial !== null) this._blurMaterial.dispose();\n    if (this._pingPongRenderTarget !== null) this._pingPongRenderTarget.dispose();\n    for (let i = 0; i < this._lodPlanes.length; i++) {\n      this._lodPlanes[i].dispose();\n    }\n  }\n  _cleanup(outputTarget) {\n    this._renderer.setRenderTarget(_oldTarget);\n    outputTarget.scissorTest = false;\n    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);\n  }\n  _fromTexture(texture, renderTarget) {\n    if (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping) {\n      this._setSize(texture.image.length === 0 ? 16 : texture.image[0].width || texture.image[0].image.width);\n    } else {\n      // Equirectangular\n\n      this._setSize(texture.image.width / 4);\n    }\n    _oldTarget = this._renderer.getRenderTarget();\n    const cubeUVRenderTarget = renderTarget || this._allocateTargets();\n    this._textureToCubeUV(texture, cubeUVRenderTarget);\n    this._applyPMREM(cubeUVRenderTarget);\n    this._cleanup(cubeUVRenderTarget);\n    return cubeUVRenderTarget;\n  }\n  _allocateTargets() {\n    const width = 3 * Math.max(this._cubeSize, 16 * 7);\n    const height = 4 * this._cubeSize;\n    const params = {\n      magFilter: LinearFilter,\n      minFilter: LinearFilter,\n      generateMipmaps: false,\n      type: HalfFloatType,\n      format: RGBAFormat,\n      encoding: LinearEncoding,\n      depthBuffer: false\n    };\n    const cubeUVRenderTarget = _createRenderTarget(width, height, params);\n    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width) {\n      if (this._pingPongRenderTarget !== null) {\n        this._dispose();\n      }\n      this._pingPongRenderTarget = _createRenderTarget(width, height, params);\n      const {\n        _lodMax\n      } = this;\n      ({\n        sizeLods: this._sizeLods,\n        lodPlanes: this._lodPlanes,\n        sigmas: this._sigmas\n      } = _createPlanes(_lodMax));\n      this._blurMaterial = _getBlurShader(_lodMax, width, height);\n    }\n    return cubeUVRenderTarget;\n  }\n  _compileMaterial(material) {\n    const tmpMesh = new Mesh(this._lodPlanes[0], material);\n    this._renderer.compile(tmpMesh, _flatCamera);\n  }\n  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {\n    const fov = 90;\n    const aspect = 1;\n    const cubeCamera = new PerspectiveCamera(fov, aspect, near, far);\n    const upSign = [1, -1, 1, 1, 1, 1];\n    const forwardSign = [1, 1, 1, -1, -1, -1];\n    const renderer = this._renderer;\n    const originalAutoClear = renderer.autoClear;\n    const toneMapping = renderer.toneMapping;\n    renderer.getClearColor(_clearColor);\n    renderer.toneMapping = NoToneMapping;\n    renderer.autoClear = false;\n    const backgroundMaterial = new MeshBasicMaterial({\n      name: 'PMREM.Background',\n      side: BackSide,\n      depthWrite: false,\n      depthTest: false\n    });\n    const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);\n    let useSolidColor = false;\n    const background = scene.background;\n    if (background) {\n      if (background.isColor) {\n        backgroundMaterial.color.copy(background);\n        scene.background = null;\n        useSolidColor = true;\n      }\n    } else {\n      backgroundMaterial.color.copy(_clearColor);\n      useSolidColor = true;\n    }\n    for (let i = 0; i < 6; i++) {\n      const col = i % 3;\n      if (col === 0) {\n        cubeCamera.up.set(0, upSign[i], 0);\n        cubeCamera.lookAt(forwardSign[i], 0, 0);\n      } else if (col === 1) {\n        cubeCamera.up.set(0, 0, upSign[i]);\n        cubeCamera.lookAt(0, forwardSign[i], 0);\n      } else {\n        cubeCamera.up.set(0, upSign[i], 0);\n        cubeCamera.lookAt(0, 0, forwardSign[i]);\n      }\n      const size = this._cubeSize;\n      _setViewport(cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size);\n      renderer.setRenderTarget(cubeUVRenderTarget);\n      if (useSolidColor) {\n        renderer.render(backgroundBox, cubeCamera);\n      }\n      renderer.render(scene, cubeCamera);\n    }\n    backgroundBox.geometry.dispose();\n    backgroundBox.material.dispose();\n    renderer.toneMapping = toneMapping;\n    renderer.autoClear = originalAutoClear;\n    scene.background = background;\n  }\n  _textureToCubeUV(texture, cubeUVRenderTarget) {\n    const renderer = this._renderer;\n    const isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;\n    if (isCubeTexture) {\n      if (this._cubemapMaterial === null) {\n        this._cubemapMaterial = _getCubemapMaterial();\n      }\n      this._cubemapMaterial.uniforms.flipEnvMap.value = texture.isRenderTargetTexture === false ? -1 : 1;\n    } else {\n      if (this._equirectMaterial === null) {\n        this._equirectMaterial = _getEquirectMaterial();\n      }\n    }\n    const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;\n    const mesh = new Mesh(this._lodPlanes[0], material);\n    const uniforms = material.uniforms;\n    uniforms['envMap'].value = texture;\n    const size = this._cubeSize;\n    _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);\n    renderer.setRenderTarget(cubeUVRenderTarget);\n    renderer.render(mesh, _flatCamera);\n  }\n  _applyPMREM(cubeUVRenderTarget) {\n    const renderer = this._renderer;\n    const autoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    for (let i = 1; i < this._lodPlanes.length; i++) {\n      const sigma = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]);\n      const poleAxis = _axisDirections[(i - 1) % _axisDirections.length];\n      this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);\n    }\n    renderer.autoClear = autoClear;\n  }\n\n  /**\n   * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n   * vertically and horizontally, but this breaks down on a cube. Here we apply\n   * the blur latitudinally (around the poles), and then longitudinally (towards\n   * the poles) to approximate the orthogonally-separable blur. It is least\n   * accurate at the poles, but still does a decent job.\n   */\n  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {\n    const pingPongRenderTarget = this._pingPongRenderTarget;\n    this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);\n    this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);\n  }\n  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {\n    const renderer = this._renderer;\n    const blurMaterial = this._blurMaterial;\n    if (direction !== 'latitudinal' && direction !== 'longitudinal') {\n      console.error('blur direction must be either latitudinal or longitudinal!');\n    }\n\n    // Number of standard deviations at which to cut off the discrete approximation.\n    const STANDARD_DEVIATIONS = 3;\n    const blurMesh = new Mesh(this._lodPlanes[lodOut], blurMaterial);\n    const blurUniforms = blurMaterial.uniforms;\n    const pixels = this._sizeLods[lodIn] - 1;\n    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);\n    const sigmaPixels = sigmaRadians / radiansPerPixel;\n    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;\n    if (samples > MAX_SAMPLES) {\n      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);\n    }\n    const weights = [];\n    let sum = 0;\n    for (let i = 0; i < MAX_SAMPLES; ++i) {\n      const x = i / sigmaPixels;\n      const weight = Math.exp(-x * x / 2);\n      weights.push(weight);\n      if (i === 0) {\n        sum += weight;\n      } else if (i < samples) {\n        sum += 2 * weight;\n      }\n    }\n    for (let i = 0; i < weights.length; i++) {\n      weights[i] = weights[i] / sum;\n    }\n    blurUniforms['envMap'].value = targetIn.texture;\n    blurUniforms['samples'].value = samples;\n    blurUniforms['weights'].value = weights;\n    blurUniforms['latitudinal'].value = direction === 'latitudinal';\n    if (poleAxis) {\n      blurUniforms['poleAxis'].value = poleAxis;\n    }\n    const {\n      _lodMax\n    } = this;\n    blurUniforms['dTheta'].value = radiansPerPixel;\n    blurUniforms['mipInt'].value = _lodMax - lodIn;\n    const outputSize = this._sizeLods[lodOut];\n    const x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);\n    const y = 4 * (this._cubeSize - outputSize);\n    _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);\n    renderer.setRenderTarget(targetOut);\n    renderer.render(blurMesh, _flatCamera);\n  }\n}\nfunction _createPlanes(lodMax) {\n  const lodPlanes = [];\n  const sizeLods = [];\n  const sigmas = [];\n  let lod = lodMax;\n  const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;\n  for (let i = 0; i < totalLods; i++) {\n    const sizeLod = Math.pow(2, lod);\n    sizeLods.push(sizeLod);\n    let sigma = 1.0 / sizeLod;\n    if (i > lodMax - LOD_MIN) {\n      sigma = EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - 1];\n    } else if (i === 0) {\n      sigma = 0;\n    }\n    sigmas.push(sigma);\n    const texelSize = 1.0 / (sizeLod - 2);\n    const min = -texelSize;\n    const max = 1 + texelSize;\n    const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];\n    const cubeFaces = 6;\n    const vertices = 6;\n    const positionSize = 3;\n    const uvSize = 2;\n    const faceIndexSize = 1;\n    const position = new Float32Array(positionSize * vertices * cubeFaces);\n    const uv = new Float32Array(uvSize * vertices * cubeFaces);\n    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);\n    for (let face = 0; face < cubeFaces; face++) {\n      const x = face % 3 * 2 / 3 - 1;\n      const y = face > 2 ? 0 : -1;\n      const coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];\n      position.set(coordinates, positionSize * vertices * face);\n      uv.set(uv1, uvSize * vertices * face);\n      const fill = [face, face, face, face, face, face];\n      faceIndex.set(fill, faceIndexSize * vertices * face);\n    }\n    const planes = new BufferGeometry();\n    planes.setAttribute('position', new BufferAttribute(position, positionSize));\n    planes.setAttribute('uv', new BufferAttribute(uv, uvSize));\n    planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));\n    lodPlanes.push(planes);\n    if (lod > LOD_MIN) {\n      lod--;\n    }\n  }\n  return {\n    lodPlanes,\n    sizeLods,\n    sigmas\n  };\n}\nfunction _createRenderTarget(width, height, params) {\n  const cubeUVRenderTarget = new WebGLRenderTarget(width, height, params);\n  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n  cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';\n  cubeUVRenderTarget.scissorTest = true;\n  return cubeUVRenderTarget;\n}\nfunction _setViewport(target, x, y, width, height) {\n  target.viewport.set(x, y, width, height);\n  target.scissor.set(x, y, width, height);\n}\nfunction _getBlurShader(lodMax, width, height) {\n  const weights = new Float32Array(MAX_SAMPLES);\n  const poleAxis = new Vector3(0, 1, 0);\n  const shaderMaterial = new ShaderMaterial({\n    name: 'SphericalGaussianBlur',\n    defines: {\n      'n': MAX_SAMPLES,\n      'CUBEUV_TEXEL_WIDTH': 1.0 / width,\n      'CUBEUV_TEXEL_HEIGHT': 1.0 / height,\n      'CUBEUV_MAX_MIP': `${lodMax}.0`\n    },\n    uniforms: {\n      'envMap': {\n        value: null\n      },\n      'samples': {\n        value: 1\n      },\n      'weights': {\n        value: weights\n      },\n      'latitudinal': {\n        value: false\n      },\n      'dTheta': {\n        value: 0\n      },\n      'mipInt': {\n        value: 0\n      },\n      'poleAxis': {\n        value: poleAxis\n      }\n    },\n    vertexShader: _getCommonVertexShader(),\n    fragmentShader: /* glsl */`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t`,\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n  return shaderMaterial;\n}\nfunction _getEquirectMaterial() {\n  return new ShaderMaterial({\n    name: 'EquirectangularToCubeUV',\n    uniforms: {\n      'envMap': {\n        value: null\n      }\n    },\n    vertexShader: _getCommonVertexShader(),\n    fragmentShader: /* glsl */`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t`,\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n}\nfunction _getCubemapMaterial() {\n  return new ShaderMaterial({\n    name: 'CubemapToCubeUV',\n    uniforms: {\n      'envMap': {\n        value: null\n      },\n      'flipEnvMap': {\n        value: -1\n      }\n    },\n    vertexShader: _getCommonVertexShader(),\n    fragmentShader: /* glsl */`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t`,\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n}\nfunction _getCommonVertexShader() {\n  return (/* glsl */`\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t`\n  );\n}\nexport { PMREMGenerator };","map":{"version":3,"names":["CubeReflectionMapping","CubeRefractionMapping","CubeUVReflectionMapping","LinearEncoding","LinearFilter","NoToneMapping","NoBlending","RGBAFormat","HalfFloatType","BufferAttribute","BufferGeometry","Mesh","OrthographicCamera","PerspectiveCamera","ShaderMaterial","Vector3","Color","WebGLRenderTarget","MeshBasicMaterial","BoxGeometry","BackSide","LOD_MIN","EXTRA_LOD_SIGMA","MAX_SAMPLES","_flatCamera","_clearColor","_oldTarget","PHI","Math","sqrt","INV_PHI","_axisDirections","PMREMGenerator","constructor","renderer","_renderer","_pingPongRenderTarget","_lodMax","_cubeSize","_lodPlanes","_sizeLods","_sigmas","_blurMaterial","_cubemapMaterial","_equirectMaterial","_compileMaterial","fromScene","scene","sigma","near","far","getRenderTarget","_setSize","cubeUVRenderTarget","_allocateTargets","depthBuffer","_sceneToCubeUV","_blur","_applyPMREM","_cleanup","fromEquirectangular","equirectangular","renderTarget","_fromTexture","fromCubemap","cubemap","compileCubemapShader","_getCubemapMaterial","compileEquirectangularShader","_getEquirectMaterial","dispose","_dispose","cubeSize","floor","log2","pow","i","length","outputTarget","setRenderTarget","scissorTest","_setViewport","width","height","texture","mapping","image","_textureToCubeUV","max","params","magFilter","minFilter","generateMipmaps","type","format","encoding","_createRenderTarget","sizeLods","lodPlanes","sigmas","_createPlanes","_getBlurShader","material","tmpMesh","compile","fov","aspect","cubeCamera","upSign","forwardSign","originalAutoClear","autoClear","toneMapping","getClearColor","backgroundMaterial","name","side","depthWrite","depthTest","backgroundBox","useSolidColor","background","isColor","color","copy","col","up","set","lookAt","size","render","geometry","isCubeTexture","uniforms","flipEnvMap","value","isRenderTargetTexture","mesh","poleAxis","lodIn","lodOut","pingPongRenderTarget","_halfBlur","targetIn","targetOut","sigmaRadians","direction","blurMaterial","console","error","STANDARD_DEVIATIONS","blurMesh","blurUniforms","pixels","radiansPerPixel","isFinite","PI","sigmaPixels","samples","warn","weights","sum","x","weight","exp","push","outputSize","y","lodMax","lod","totalLods","sizeLod","texelSize","min","uv1","cubeFaces","vertices","positionSize","uvSize","faceIndexSize","position","Float32Array","uv","faceIndex","face","coordinates","fill","planes","setAttribute","target","viewport","scissor","shaderMaterial","defines","vertexShader","_getCommonVertexShader","fragmentShader","blending"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/extras/PMREMGenerator.js"],"sourcesContent":["import {\n\tCubeReflectionMapping,\n\tCubeRefractionMapping,\n\tCubeUVReflectionMapping,\n\tLinearEncoding,\n\tLinearFilter,\n\tNoToneMapping,\n\tNoBlending,\n\tRGBAFormat,\n\tHalfFloatType\n} from '../constants.js';\n\nimport { BufferAttribute } from '../core/BufferAttribute.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Mesh } from '../objects/Mesh.js';\nimport { OrthographicCamera } from '../cameras/OrthographicCamera.js';\nimport { PerspectiveCamera } from '../cameras/PerspectiveCamera.js';\nimport { ShaderMaterial } from '../materials/ShaderMaterial.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Color } from '../math/Color.js';\nimport { WebGLRenderTarget } from '../renderers/WebGLRenderTarget.js';\nimport { MeshBasicMaterial } from '../materials/MeshBasicMaterial.js';\nimport { BoxGeometry } from '../geometries/BoxGeometry.js';\nimport { BackSide } from '../constants.js';\n\nconst LOD_MIN = 4;\n\n// The standard deviations (radians) associated with the extra mips. These are\n// chosen to approximate a Trowbridge-Reitz distribution function times the\n// geometric shadowing function. These sigma values squared must match the\n// variance #defines in cube_uv_reflection_fragment.glsl.js.\nconst EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];\n\n// The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\nconst MAX_SAMPLES = 20;\n\nconst _flatCamera = /*@__PURE__*/ new OrthographicCamera();\nconst _clearColor = /*@__PURE__*/ new Color();\nlet _oldTarget = null;\n\n// Golden Ratio\nconst PHI = ( 1 + Math.sqrt( 5 ) ) / 2;\nconst INV_PHI = 1 / PHI;\n\n// Vertices of a dodecahedron (except the opposites, which represent the\n// same axis), used as axis directions evenly spread on a sphere.\nconst _axisDirections = [\n\t/*@__PURE__*/ new Vector3( 1, 1, 1 ),\n\t/*@__PURE__*/ new Vector3( - 1, 1, 1 ),\n\t/*@__PURE__*/ new Vector3( 1, 1, - 1 ),\n\t/*@__PURE__*/ new Vector3( - 1, 1, - 1 ),\n\t/*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ),\n\t/*@__PURE__*/ new Vector3( 0, PHI, - INV_PHI ),\n\t/*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ),\n\t/*@__PURE__*/ new Vector3( - INV_PHI, 0, PHI ),\n\t/*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ),\n\t/*@__PURE__*/ new Vector3( - PHI, INV_PHI, 0 ) ];\n\n/**\n * This class generates a Prefiltered, Mipmapped Radiance Environment Map\n * (PMREM) from a cubeMap environment texture. This allows different levels of\n * blur to be quickly accessed based on material roughness. It is packed into a\n * special CubeUV format that allows us to perform custom interpolation so that\n * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\n * chain, it only goes down to the LOD_MIN level (above), and then creates extra\n * even more filtered 'mips' at the same LOD_MIN resolution, associated with\n * higher roughness levels. In this way we maintain resolution to smoothly\n * interpolate diffuse lighting while limiting sampling computation.\n *\n * Paper: Fast, Accurate Image-Based Lighting\n * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view\n*/\n\nclass PMREMGenerator {\n\n\tconstructor( renderer ) {\n\n\t\tthis._renderer = renderer;\n\t\tthis._pingPongRenderTarget = null;\n\n\t\tthis._lodMax = 0;\n\t\tthis._cubeSize = 0;\n\t\tthis._lodPlanes = [];\n\t\tthis._sizeLods = [];\n\t\tthis._sigmas = [];\n\n\t\tthis._blurMaterial = null;\n\t\tthis._cubemapMaterial = null;\n\t\tthis._equirectMaterial = null;\n\n\t\tthis._compileMaterial( this._blurMaterial );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from a supplied Scene, which can be faster than using an\n\t * image if networking bandwidth is low. Optional sigma specifies a blur radius\n\t * in radians to be applied to the scene before PMREM generation. Optional near\n\t * and far planes ensure the scene is rendered in its entirety (the cubeCamera\n\t * is placed at the origin).\n\t */\n\tfromScene( scene, sigma = 0, near = 0.1, far = 100 ) {\n\n\t\t_oldTarget = this._renderer.getRenderTarget();\n\n\t\tthis._setSize( 256 );\n\n\t\tconst cubeUVRenderTarget = this._allocateTargets();\n\t\tcubeUVRenderTarget.depthBuffer = true;\n\n\t\tthis._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );\n\n\t\tif ( sigma > 0 ) {\n\n\t\t\tthis._blur( cubeUVRenderTarget, 0, 0, sigma );\n\n\t\t}\n\n\t\tthis._applyPMREM( cubeUVRenderTarget );\n\t\tthis._cleanup( cubeUVRenderTarget );\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an equirectangular texture, which can be either LDR\n\t * or HDR. The ideal input image size is 1k (1024 x 512),\n\t * as this matches best with the 256 x 256 cubemap output.\n\t */\n\tfromEquirectangular( equirectangular, renderTarget = null ) {\n\n\t\treturn this._fromTexture( equirectangular, renderTarget );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an cubemap texture, which can be either LDR\n\t * or HDR. The ideal input cube size is 256 x 256,\n\t * as this matches best with the 256 x 256 cubemap output.\n\t */\n\tfromCubemap( cubemap, renderTarget = null ) {\n\n\t\treturn this._fromTexture( cubemap, renderTarget );\n\n\t}\n\n\t/**\n\t * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\n\t * your texture's network fetch for increased concurrency.\n\t */\n\tcompileCubemapShader() {\n\n\t\tif ( this._cubemapMaterial === null ) {\n\n\t\t\tthis._cubemapMaterial = _getCubemapMaterial();\n\t\t\tthis._compileMaterial( this._cubemapMaterial );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\n\t * your texture's network fetch for increased concurrency.\n\t */\n\tcompileEquirectangularShader() {\n\n\t\tif ( this._equirectMaterial === null ) {\n\n\t\t\tthis._equirectMaterial = _getEquirectMaterial();\n\t\t\tthis._compileMaterial( this._equirectMaterial );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\n\t * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\n\t * one of them will cause any others to also become unusable.\n\t */\n\tdispose() {\n\n\t\tthis._dispose();\n\n\t\tif ( this._cubemapMaterial !== null ) this._cubemapMaterial.dispose();\n\t\tif ( this._equirectMaterial !== null ) this._equirectMaterial.dispose();\n\n\t}\n\n\t// private interface\n\n\t_setSize( cubeSize ) {\n\n\t\tthis._lodMax = Math.floor( Math.log2( cubeSize ) );\n\t\tthis._cubeSize = Math.pow( 2, this._lodMax );\n\n\t}\n\n\t_dispose() {\n\n\t\tif ( this._blurMaterial !== null ) this._blurMaterial.dispose();\n\n\t\tif ( this._pingPongRenderTarget !== null ) this._pingPongRenderTarget.dispose();\n\n\t\tfor ( let i = 0; i < this._lodPlanes.length; i ++ ) {\n\n\t\t\tthis._lodPlanes[ i ].dispose();\n\n\t\t}\n\n\t}\n\n\t_cleanup( outputTarget ) {\n\n\t\tthis._renderer.setRenderTarget( _oldTarget );\n\t\toutputTarget.scissorTest = false;\n\t\t_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );\n\n\t}\n\n\t_fromTexture( texture, renderTarget ) {\n\n\t\tif ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping ) {\n\n\t\t\tthis._setSize( texture.image.length === 0 ? 16 : ( texture.image[ 0 ].width || texture.image[ 0 ].image.width ) );\n\n\t\t} else { // Equirectangular\n\n\t\t\tthis._setSize( texture.image.width / 4 );\n\n\t\t}\n\n\t\t_oldTarget = this._renderer.getRenderTarget();\n\n\t\tconst cubeUVRenderTarget = renderTarget || this._allocateTargets();\n\t\tthis._textureToCubeUV( texture, cubeUVRenderTarget );\n\t\tthis._applyPMREM( cubeUVRenderTarget );\n\t\tthis._cleanup( cubeUVRenderTarget );\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t_allocateTargets() {\n\n\t\tconst width = 3 * Math.max( this._cubeSize, 16 * 7 );\n\t\tconst height = 4 * this._cubeSize;\n\n\t\tconst params = {\n\t\t\tmagFilter: LinearFilter,\n\t\t\tminFilter: LinearFilter,\n\t\t\tgenerateMipmaps: false,\n\t\t\ttype: HalfFloatType,\n\t\t\tformat: RGBAFormat,\n\t\t\tencoding: LinearEncoding,\n\t\t\tdepthBuffer: false\n\t\t};\n\n\t\tconst cubeUVRenderTarget = _createRenderTarget( width, height, params );\n\n\t\tif ( this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width ) {\n\n\t\t\tif ( this._pingPongRenderTarget !== null ) {\n\n\t\t\t\tthis._dispose();\n\n\t\t\t}\n\n\t\t\tthis._pingPongRenderTarget = _createRenderTarget( width, height, params );\n\n\t\t\tconst { _lodMax } = this;\n\t\t\t( { sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes( _lodMax ) );\n\n\t\t\tthis._blurMaterial = _getBlurShader( _lodMax, width, height );\n\n\t\t}\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t_compileMaterial( material ) {\n\n\t\tconst tmpMesh = new Mesh( this._lodPlanes[ 0 ], material );\n\t\tthis._renderer.compile( tmpMesh, _flatCamera );\n\n\t}\n\n\t_sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {\n\n\t\tconst fov = 90;\n\t\tconst aspect = 1;\n\t\tconst cubeCamera = new PerspectiveCamera( fov, aspect, near, far );\n\t\tconst upSign = [ 1, - 1, 1, 1, 1, 1 ];\n\t\tconst forwardSign = [ 1, 1, 1, - 1, - 1, - 1 ];\n\t\tconst renderer = this._renderer;\n\n\t\tconst originalAutoClear = renderer.autoClear;\n\t\tconst toneMapping = renderer.toneMapping;\n\t\trenderer.getClearColor( _clearColor );\n\n\t\trenderer.toneMapping = NoToneMapping;\n\t\trenderer.autoClear = false;\n\n\t\tconst backgroundMaterial = new MeshBasicMaterial( {\n\t\t\tname: 'PMREM.Background',\n\t\t\tside: BackSide,\n\t\t\tdepthWrite: false,\n\t\t\tdepthTest: false,\n\t\t} );\n\n\t\tconst backgroundBox = new Mesh( new BoxGeometry(), backgroundMaterial );\n\n\t\tlet useSolidColor = false;\n\t\tconst background = scene.background;\n\n\t\tif ( background ) {\n\n\t\t\tif ( background.isColor ) {\n\n\t\t\t\tbackgroundMaterial.color.copy( background );\n\t\t\t\tscene.background = null;\n\t\t\t\tuseSolidColor = true;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tbackgroundMaterial.color.copy( _clearColor );\n\t\t\tuseSolidColor = true;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst col = i % 3;\n\n\t\t\tif ( col === 0 ) {\n\n\t\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\n\t\t\t\tcubeCamera.lookAt( forwardSign[ i ], 0, 0 );\n\n\t\t\t} else if ( col === 1 ) {\n\n\t\t\t\tcubeCamera.up.set( 0, 0, upSign[ i ] );\n\t\t\t\tcubeCamera.lookAt( 0, forwardSign[ i ], 0 );\n\n\t\t\t} else {\n\n\t\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\n\t\t\t\tcubeCamera.lookAt( 0, 0, forwardSign[ i ] );\n\n\t\t\t}\n\n\t\t\tconst size = this._cubeSize;\n\n\t\t\t_setViewport( cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size );\n\n\t\t\trenderer.setRenderTarget( cubeUVRenderTarget );\n\n\t\t\tif ( useSolidColor ) {\n\n\t\t\t\trenderer.render( backgroundBox, cubeCamera );\n\n\t\t\t}\n\n\t\t\trenderer.render( scene, cubeCamera );\n\n\t\t}\n\n\t\tbackgroundBox.geometry.dispose();\n\t\tbackgroundBox.material.dispose();\n\n\t\trenderer.toneMapping = toneMapping;\n\t\trenderer.autoClear = originalAutoClear;\n\t\tscene.background = background;\n\n\t}\n\n\t_textureToCubeUV( texture, cubeUVRenderTarget ) {\n\n\t\tconst renderer = this._renderer;\n\n\t\tconst isCubeTexture = ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping );\n\n\t\tif ( isCubeTexture ) {\n\n\t\t\tif ( this._cubemapMaterial === null ) {\n\n\t\t\t\tthis._cubemapMaterial = _getCubemapMaterial();\n\n\t\t\t}\n\n\t\t\tthis._cubemapMaterial.uniforms.flipEnvMap.value = ( texture.isRenderTargetTexture === false ) ? - 1 : 1;\n\n\t\t} else {\n\n\t\t\tif ( this._equirectMaterial === null ) {\n\n\t\t\t\tthis._equirectMaterial = _getEquirectMaterial();\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;\n\t\tconst mesh = new Mesh( this._lodPlanes[ 0 ], material );\n\n\t\tconst uniforms = material.uniforms;\n\n\t\tuniforms[ 'envMap' ].value = texture;\n\n\t\tconst size = this._cubeSize;\n\n\t\t_setViewport( cubeUVRenderTarget, 0, 0, 3 * size, 2 * size );\n\n\t\trenderer.setRenderTarget( cubeUVRenderTarget );\n\t\trenderer.render( mesh, _flatCamera );\n\n\t}\n\n\t_applyPMREM( cubeUVRenderTarget ) {\n\n\t\tconst renderer = this._renderer;\n\t\tconst autoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\tfor ( let i = 1; i < this._lodPlanes.length; i ++ ) {\n\n\t\t\tconst sigma = Math.sqrt( this._sigmas[ i ] * this._sigmas[ i ] - this._sigmas[ i - 1 ] * this._sigmas[ i - 1 ] );\n\n\t\t\tconst poleAxis = _axisDirections[ ( i - 1 ) % _axisDirections.length ];\n\n\t\t\tthis._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );\n\n\t\t}\n\n\t\trenderer.autoClear = autoClear;\n\n\t}\n\n\t/**\n\t * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n\t * vertically and horizontally, but this breaks down on a cube. Here we apply\n\t * the blur latitudinally (around the poles), and then longitudinally (towards\n\t * the poles) to approximate the orthogonally-separable blur. It is least\n\t * accurate at the poles, but still does a decent job.\n\t */\n\t_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {\n\n\t\tconst pingPongRenderTarget = this._pingPongRenderTarget;\n\n\t\tthis._halfBlur(\n\t\t\tcubeUVRenderTarget,\n\t\t\tpingPongRenderTarget,\n\t\t\tlodIn,\n\t\t\tlodOut,\n\t\t\tsigma,\n\t\t\t'latitudinal',\n\t\t\tpoleAxis );\n\n\t\tthis._halfBlur(\n\t\t\tpingPongRenderTarget,\n\t\t\tcubeUVRenderTarget,\n\t\t\tlodOut,\n\t\t\tlodOut,\n\t\t\tsigma,\n\t\t\t'longitudinal',\n\t\t\tpoleAxis );\n\n\t}\n\n\t_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {\n\n\t\tconst renderer = this._renderer;\n\t\tconst blurMaterial = this._blurMaterial;\n\n\t\tif ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {\n\n\t\t\tconsole.error(\n\t\t\t\t'blur direction must be either latitudinal or longitudinal!' );\n\n\t\t}\n\n\t\t// Number of standard deviations at which to cut off the discrete approximation.\n\t\tconst STANDARD_DEVIATIONS = 3;\n\n\t\tconst blurMesh = new Mesh( this._lodPlanes[ lodOut ], blurMaterial );\n\t\tconst blurUniforms = blurMaterial.uniforms;\n\n\t\tconst pixels = this._sizeLods[ lodIn ] - 1;\n\t\tconst radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );\n\t\tconst sigmaPixels = sigmaRadians / radiansPerPixel;\n\t\tconst samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;\n\n\t\tif ( samples > MAX_SAMPLES ) {\n\n\t\t\tconsole.warn( `sigmaRadians, ${\n\t\t\t\tsigmaRadians}, is too large and will clip, as it requested ${\n\t\t\t\tsamples} samples when the maximum is set to ${MAX_SAMPLES}` );\n\n\t\t}\n\n\t\tconst weights = [];\n\t\tlet sum = 0;\n\n\t\tfor ( let i = 0; i < MAX_SAMPLES; ++ i ) {\n\n\t\t\tconst x = i / sigmaPixels;\n\t\t\tconst weight = Math.exp( - x * x / 2 );\n\t\t\tweights.push( weight );\n\n\t\t\tif ( i === 0 ) {\n\n\t\t\t\tsum += weight;\n\n\t\t\t} else if ( i < samples ) {\n\n\t\t\t\tsum += 2 * weight;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < weights.length; i ++ ) {\n\n\t\t\tweights[ i ] = weights[ i ] / sum;\n\n\t\t}\n\n\t\tblurUniforms[ 'envMap' ].value = targetIn.texture;\n\t\tblurUniforms[ 'samples' ].value = samples;\n\t\tblurUniforms[ 'weights' ].value = weights;\n\t\tblurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';\n\n\t\tif ( poleAxis ) {\n\n\t\t\tblurUniforms[ 'poleAxis' ].value = poleAxis;\n\n\t\t}\n\n\t\tconst { _lodMax } = this;\n\t\tblurUniforms[ 'dTheta' ].value = radiansPerPixel;\n\t\tblurUniforms[ 'mipInt' ].value = _lodMax - lodIn;\n\n\t\tconst outputSize = this._sizeLods[ lodOut ];\n\t\tconst x = 3 * outputSize * ( lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0 );\n\t\tconst y = 4 * ( this._cubeSize - outputSize );\n\n\t\t_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );\n\t\trenderer.setRenderTarget( targetOut );\n\t\trenderer.render( blurMesh, _flatCamera );\n\n\t}\n\n}\n\n\n\nfunction _createPlanes( lodMax ) {\n\n\tconst lodPlanes = [];\n\tconst sizeLods = [];\n\tconst sigmas = [];\n\n\tlet lod = lodMax;\n\n\tconst totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;\n\n\tfor ( let i = 0; i < totalLods; i ++ ) {\n\n\t\tconst sizeLod = Math.pow( 2, lod );\n\t\tsizeLods.push( sizeLod );\n\t\tlet sigma = 1.0 / sizeLod;\n\n\t\tif ( i > lodMax - LOD_MIN ) {\n\n\t\t\tsigma = EXTRA_LOD_SIGMA[ i - lodMax + LOD_MIN - 1 ];\n\n\t\t} else if ( i === 0 ) {\n\n\t\t\tsigma = 0;\n\n\t\t}\n\n\t\tsigmas.push( sigma );\n\n\t\tconst texelSize = 1.0 / ( sizeLod - 2 );\n\t\tconst min = - texelSize;\n\t\tconst max = 1 + texelSize;\n\t\tconst uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];\n\n\t\tconst cubeFaces = 6;\n\t\tconst vertices = 6;\n\t\tconst positionSize = 3;\n\t\tconst uvSize = 2;\n\t\tconst faceIndexSize = 1;\n\n\t\tconst position = new Float32Array( positionSize * vertices * cubeFaces );\n\t\tconst uv = new Float32Array( uvSize * vertices * cubeFaces );\n\t\tconst faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );\n\n\t\tfor ( let face = 0; face < cubeFaces; face ++ ) {\n\n\t\t\tconst x = ( face % 3 ) * 2 / 3 - 1;\n\t\t\tconst y = face > 2 ? 0 : - 1;\n\t\t\tconst coordinates = [\n\t\t\t\tx, y, 0,\n\t\t\t\tx + 2 / 3, y, 0,\n\t\t\t\tx + 2 / 3, y + 1, 0,\n\t\t\t\tx, y, 0,\n\t\t\t\tx + 2 / 3, y + 1, 0,\n\t\t\t\tx, y + 1, 0\n\t\t\t];\n\t\t\tposition.set( coordinates, positionSize * vertices * face );\n\t\t\tuv.set( uv1, uvSize * vertices * face );\n\t\t\tconst fill = [ face, face, face, face, face, face ];\n\t\t\tfaceIndex.set( fill, faceIndexSize * vertices * face );\n\n\t\t}\n\n\t\tconst planes = new BufferGeometry();\n\t\tplanes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );\n\t\tplanes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );\n\t\tplanes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );\n\t\tlodPlanes.push( planes );\n\n\t\tif ( lod > LOD_MIN ) {\n\n\t\t\tlod --;\n\n\t\t}\n\n\t}\n\n\treturn { lodPlanes, sizeLods, sigmas };\n\n}\n\nfunction _createRenderTarget( width, height, params ) {\n\n\tconst cubeUVRenderTarget = new WebGLRenderTarget( width, height, params );\n\tcubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n\tcubeUVRenderTarget.texture.name = 'PMREM.cubeUv';\n\tcubeUVRenderTarget.scissorTest = true;\n\treturn cubeUVRenderTarget;\n\n}\n\nfunction _setViewport( target, x, y, width, height ) {\n\n\ttarget.viewport.set( x, y, width, height );\n\ttarget.scissor.set( x, y, width, height );\n\n}\n\nfunction _getBlurShader( lodMax, width, height ) {\n\n\tconst weights = new Float32Array( MAX_SAMPLES );\n\tconst poleAxis = new Vector3( 0, 1, 0 );\n\tconst shaderMaterial = new ShaderMaterial( {\n\n\t\tname: 'SphericalGaussianBlur',\n\n\t\tdefines: {\n\t\t\t'n': MAX_SAMPLES,\n\t\t\t'CUBEUV_TEXEL_WIDTH': 1.0 / width,\n\t\t\t'CUBEUV_TEXEL_HEIGHT': 1.0 / height,\n\t\t\t'CUBEUV_MAX_MIP': `${lodMax}.0`,\n\t\t},\n\n\t\tuniforms: {\n\t\t\t'envMap': { value: null },\n\t\t\t'samples': { value: 1 },\n\t\t\t'weights': { value: weights },\n\t\t\t'latitudinal': { value: false },\n\t\t\t'dTheta': { value: 0 },\n\t\t\t'mipInt': { value: 0 },\n\t\t\t'poleAxis': { value: poleAxis }\n\t\t},\n\n\t\tvertexShader: _getCommonVertexShader(),\n\n\t\tfragmentShader: /* glsl */`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t`,\n\n\t\tblending: NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\n\t} );\n\n\treturn shaderMaterial;\n\n}\n\nfunction _getEquirectMaterial() {\n\n\treturn new ShaderMaterial( {\n\n\t\tname: 'EquirectangularToCubeUV',\n\n\t\tuniforms: {\n\t\t\t'envMap': { value: null }\n\t\t},\n\n\t\tvertexShader: _getCommonVertexShader(),\n\n\t\tfragmentShader: /* glsl */`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t`,\n\n\t\tblending: NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\n\t} );\n\n}\n\nfunction _getCubemapMaterial() {\n\n\treturn new ShaderMaterial( {\n\n\t\tname: 'CubemapToCubeUV',\n\n\t\tuniforms: {\n\t\t\t'envMap': { value: null },\n\t\t\t'flipEnvMap': { value: - 1 }\n\t\t},\n\n\t\tvertexShader: _getCommonVertexShader(),\n\n\t\tfragmentShader: /* glsl */`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t`,\n\n\t\tblending: NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\n\t} );\n\n}\n\nfunction _getCommonVertexShader() {\n\n\treturn /* glsl */`\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t`;\n\n}\n\nexport { PMREMGenerator };\n"],"mappings":"AAAA,SACCA,qBAAqB,EACrBC,qBAAqB,EACrBC,uBAAuB,EACvBC,cAAc,EACdC,YAAY,EACZC,aAAa,EACbC,UAAU,EACVC,UAAU,EACVC,aAAa,QACP,iBAAiB;AAExB,SAASC,eAAe,QAAQ,4BAA4B;AAC5D,SAASC,cAAc,QAAQ,2BAA2B;AAC1D,SAASC,IAAI,QAAQ,oBAAoB;AACzC,SAASC,kBAAkB,QAAQ,kCAAkC;AACrE,SAASC,iBAAiB,QAAQ,iCAAiC;AACnE,SAASC,cAAc,QAAQ,gCAAgC;AAC/D,SAASC,OAAO,QAAQ,oBAAoB;AAC5C,SAASC,KAAK,QAAQ,kBAAkB;AACxC,SAASC,iBAAiB,QAAQ,mCAAmC;AACrE,SAASC,iBAAiB,QAAQ,mCAAmC;AACrE,SAASC,WAAW,QAAQ,8BAA8B;AAC1D,SAASC,QAAQ,QAAQ,iBAAiB;AAE1C,MAAMC,OAAO,GAAG,CAAC;;AAEjB;AACA;AACA;AACA;AACA,MAAMC,eAAe,GAAG,CAAE,KAAK,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,CAAE;;AAEnE;AACA;AACA,MAAMC,WAAW,GAAG,EAAE;AAEtB,MAAMC,WAAW,GAAG,aAAc,IAAIZ,kBAAkB,EAAE;AAC1D,MAAMa,WAAW,GAAG,aAAc,IAAIT,KAAK,EAAE;AAC7C,IAAIU,UAAU,GAAG,IAAI;;AAErB;AACA,MAAMC,GAAG,GAAG,CAAE,CAAC,GAAGC,IAAI,CAACC,IAAI,CAAE,CAAC,CAAE,IAAK,CAAC;AACtC,MAAMC,OAAO,GAAG,CAAC,GAAGH,GAAG;;AAEvB;AACA;AACA,MAAMI,eAAe,GAAG,CACvB,aAAc,IAAIhB,OAAO,CAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAE,EACpC,aAAc,IAAIA,OAAO,CAAE,CAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAE,EACtC,aAAc,IAAIA,OAAO,CAAE,CAAC,EAAE,CAAC,EAAE,CAAE,CAAC,CAAE,EACtC,aAAc,IAAIA,OAAO,CAAE,CAAE,CAAC,EAAE,CAAC,EAAE,CAAE,CAAC,CAAE,EACxC,aAAc,IAAIA,OAAO,CAAE,CAAC,EAAEY,GAAG,EAAEG,OAAO,CAAE,EAC5C,aAAc,IAAIf,OAAO,CAAE,CAAC,EAAEY,GAAG,EAAE,CAAEG,OAAO,CAAE,EAC9C,aAAc,IAAIf,OAAO,CAAEe,OAAO,EAAE,CAAC,EAAEH,GAAG,CAAE,EAC5C,aAAc,IAAIZ,OAAO,CAAE,CAAEe,OAAO,EAAE,CAAC,EAAEH,GAAG,CAAE,EAC9C,aAAc,IAAIZ,OAAO,CAAEY,GAAG,EAAEG,OAAO,EAAE,CAAC,CAAE,EAC5C,aAAc,IAAIf,OAAO,CAAE,CAAEY,GAAG,EAAEG,OAAO,EAAE,CAAC,CAAE,CAAE;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAME,cAAc,CAAC;EAEpBC,WAAW,CAAEC,QAAQ,EAAG;IAEvB,IAAI,CAACC,SAAS,GAAGD,QAAQ;IACzB,IAAI,CAACE,qBAAqB,GAAG,IAAI;IAEjC,IAAI,CAACC,OAAO,GAAG,CAAC;IAChB,IAAI,CAACC,SAAS,GAAG,CAAC;IAClB,IAAI,CAACC,UAAU,GAAG,EAAE;IACpB,IAAI,CAACC,SAAS,GAAG,EAAE;IACnB,IAAI,CAACC,OAAO,GAAG,EAAE;IAEjB,IAAI,CAACC,aAAa,GAAG,IAAI;IACzB,IAAI,CAACC,gBAAgB,GAAG,IAAI;IAC5B,IAAI,CAACC,iBAAiB,GAAG,IAAI;IAE7B,IAAI,CAACC,gBAAgB,CAAE,IAAI,CAACH,aAAa,CAAE;EAE5C;;EAEA;AACD;AACA;AACA;AACA;AACA;AACA;EACCI,SAAS,CAAEC,KAAK,EAAqC;IAAA,IAAnCC,KAAK,uEAAG,CAAC;IAAA,IAAEC,IAAI,uEAAG,GAAG;IAAA,IAAEC,GAAG,uEAAG,GAAG;IAEjDxB,UAAU,GAAG,IAAI,CAACS,SAAS,CAACgB,eAAe,EAAE;IAE7C,IAAI,CAACC,QAAQ,CAAE,GAAG,CAAE;IAEpB,MAAMC,kBAAkB,GAAG,IAAI,CAACC,gBAAgB,EAAE;IAClDD,kBAAkB,CAACE,WAAW,GAAG,IAAI;IAErC,IAAI,CAACC,cAAc,CAAET,KAAK,EAAEE,IAAI,EAAEC,GAAG,EAAEG,kBAAkB,CAAE;IAE3D,IAAKL,KAAK,GAAG,CAAC,EAAG;MAEhB,IAAI,CAACS,KAAK,CAAEJ,kBAAkB,EAAE,CAAC,EAAE,CAAC,EAAEL,KAAK,CAAE;IAE9C;IAEA,IAAI,CAACU,WAAW,CAAEL,kBAAkB,CAAE;IACtC,IAAI,CAACM,QAAQ,CAAEN,kBAAkB,CAAE;IAEnC,OAAOA,kBAAkB;EAE1B;;EAEA;AACD;AACA;AACA;AACA;EACCO,mBAAmB,CAAEC,eAAe,EAAwB;IAAA,IAAtBC,YAAY,uEAAG,IAAI;IAExD,OAAO,IAAI,CAACC,YAAY,CAAEF,eAAe,EAAEC,YAAY,CAAE;EAE1D;;EAEA;AACD;AACA;AACA;AACA;EACCE,WAAW,CAAEC,OAAO,EAAwB;IAAA,IAAtBH,YAAY,uEAAG,IAAI;IAExC,OAAO,IAAI,CAACC,YAAY,CAAEE,OAAO,EAAEH,YAAY,CAAE;EAElD;;EAEA;AACD;AACA;AACA;EACCI,oBAAoB,GAAG;IAEtB,IAAK,IAAI,CAACvB,gBAAgB,KAAK,IAAI,EAAG;MAErC,IAAI,CAACA,gBAAgB,GAAGwB,mBAAmB,EAAE;MAC7C,IAAI,CAACtB,gBAAgB,CAAE,IAAI,CAACF,gBAAgB,CAAE;IAE/C;EAED;;EAEA;AACD;AACA;AACA;EACCyB,4BAA4B,GAAG;IAE9B,IAAK,IAAI,CAACxB,iBAAiB,KAAK,IAAI,EAAG;MAEtC,IAAI,CAACA,iBAAiB,GAAGyB,oBAAoB,EAAE;MAC/C,IAAI,CAACxB,gBAAgB,CAAE,IAAI,CAACD,iBAAiB,CAAE;IAEhD;EAED;;EAEA;AACD;AACA;AACA;AACA;EACC0B,OAAO,GAAG;IAET,IAAI,CAACC,QAAQ,EAAE;IAEf,IAAK,IAAI,CAAC5B,gBAAgB,KAAK,IAAI,EAAG,IAAI,CAACA,gBAAgB,CAAC2B,OAAO,EAAE;IACrE,IAAK,IAAI,CAAC1B,iBAAiB,KAAK,IAAI,EAAG,IAAI,CAACA,iBAAiB,CAAC0B,OAAO,EAAE;EAExE;;EAEA;;EAEAlB,QAAQ,CAAEoB,QAAQ,EAAG;IAEpB,IAAI,CAACnC,OAAO,GAAGT,IAAI,CAAC6C,KAAK,CAAE7C,IAAI,CAAC8C,IAAI,CAAEF,QAAQ,CAAE,CAAE;IAClD,IAAI,CAAClC,SAAS,GAAGV,IAAI,CAAC+C,GAAG,CAAE,CAAC,EAAE,IAAI,CAACtC,OAAO,CAAE;EAE7C;EAEAkC,QAAQ,GAAG;IAEV,IAAK,IAAI,CAAC7B,aAAa,KAAK,IAAI,EAAG,IAAI,CAACA,aAAa,CAAC4B,OAAO,EAAE;IAE/D,IAAK,IAAI,CAAClC,qBAAqB,KAAK,IAAI,EAAG,IAAI,CAACA,qBAAqB,CAACkC,OAAO,EAAE;IAE/E,KAAM,IAAIM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACrC,UAAU,CAACsC,MAAM,EAAED,CAAC,EAAG,EAAG;MAEnD,IAAI,CAACrC,UAAU,CAAEqC,CAAC,CAAE,CAACN,OAAO,EAAE;IAE/B;EAED;EAEAX,QAAQ,CAAEmB,YAAY,EAAG;IAExB,IAAI,CAAC3C,SAAS,CAAC4C,eAAe,CAAErD,UAAU,CAAE;IAC5CoD,YAAY,CAACE,WAAW,GAAG,KAAK;IAChCC,YAAY,CAAEH,YAAY,EAAE,CAAC,EAAE,CAAC,EAAEA,YAAY,CAACI,KAAK,EAAEJ,YAAY,CAACK,MAAM,CAAE;EAE5E;EAEApB,YAAY,CAAEqB,OAAO,EAAEtB,YAAY,EAAG;IAErC,IAAKsB,OAAO,CAACC,OAAO,KAAKrF,qBAAqB,IAAIoF,OAAO,CAACC,OAAO,KAAKpF,qBAAqB,EAAG;MAE7F,IAAI,CAACmD,QAAQ,CAAEgC,OAAO,CAACE,KAAK,CAACT,MAAM,KAAK,CAAC,GAAG,EAAE,GAAKO,OAAO,CAACE,KAAK,CAAE,CAAC,CAAE,CAACJ,KAAK,IAAIE,OAAO,CAACE,KAAK,CAAE,CAAC,CAAE,CAACA,KAAK,CAACJ,KAAO,CAAE;IAElH,CAAC,MAAM;MAAE;;MAER,IAAI,CAAC9B,QAAQ,CAAEgC,OAAO,CAACE,KAAK,CAACJ,KAAK,GAAG,CAAC,CAAE;IAEzC;IAEAxD,UAAU,GAAG,IAAI,CAACS,SAAS,CAACgB,eAAe,EAAE;IAE7C,MAAME,kBAAkB,GAAGS,YAAY,IAAI,IAAI,CAACR,gBAAgB,EAAE;IAClE,IAAI,CAACiC,gBAAgB,CAAEH,OAAO,EAAE/B,kBAAkB,CAAE;IACpD,IAAI,CAACK,WAAW,CAAEL,kBAAkB,CAAE;IACtC,IAAI,CAACM,QAAQ,CAAEN,kBAAkB,CAAE;IAEnC,OAAOA,kBAAkB;EAE1B;EAEAC,gBAAgB,GAAG;IAElB,MAAM4B,KAAK,GAAG,CAAC,GAAGtD,IAAI,CAAC4D,GAAG,CAAE,IAAI,CAAClD,SAAS,EAAE,EAAE,GAAG,CAAC,CAAE;IACpD,MAAM6C,MAAM,GAAG,CAAC,GAAG,IAAI,CAAC7C,SAAS;IAEjC,MAAMmD,MAAM,GAAG;MACdC,SAAS,EAAEtF,YAAY;MACvBuF,SAAS,EAAEvF,YAAY;MACvBwF,eAAe,EAAE,KAAK;MACtBC,IAAI,EAAErF,aAAa;MACnBsF,MAAM,EAAEvF,UAAU;MAClBwF,QAAQ,EAAE5F,cAAc;MACxBoD,WAAW,EAAE;IACd,CAAC;IAED,MAAMF,kBAAkB,GAAG2C,mBAAmB,CAAEd,KAAK,EAAEC,MAAM,EAAEM,MAAM,CAAE;IAEvE,IAAK,IAAI,CAACrD,qBAAqB,KAAK,IAAI,IAAI,IAAI,CAACA,qBAAqB,CAAC8C,KAAK,KAAKA,KAAK,EAAG;MAExF,IAAK,IAAI,CAAC9C,qBAAqB,KAAK,IAAI,EAAG;QAE1C,IAAI,CAACmC,QAAQ,EAAE;MAEhB;MAEA,IAAI,CAACnC,qBAAqB,GAAG4D,mBAAmB,CAAEd,KAAK,EAAEC,MAAM,EAAEM,MAAM,CAAE;MAEzE,MAAM;QAAEpD;MAAQ,CAAC,GAAG,IAAI;MACxB,CAAE;QAAE4D,QAAQ,EAAE,IAAI,CAACzD,SAAS;QAAE0D,SAAS,EAAE,IAAI,CAAC3D,UAAU;QAAE4D,MAAM,EAAE,IAAI,CAAC1D;MAAQ,CAAC,GAAG2D,aAAa,CAAE/D,OAAO,CAAE;MAE3G,IAAI,CAACK,aAAa,GAAG2D,cAAc,CAAEhE,OAAO,EAAE6C,KAAK,EAAEC,MAAM,CAAE;IAE9D;IAEA,OAAO9B,kBAAkB;EAE1B;EAEAR,gBAAgB,CAAEyD,QAAQ,EAAG;IAE5B,MAAMC,OAAO,GAAG,IAAI5F,IAAI,CAAE,IAAI,CAAC4B,UAAU,CAAE,CAAC,CAAE,EAAE+D,QAAQ,CAAE;IAC1D,IAAI,CAACnE,SAAS,CAACqE,OAAO,CAAED,OAAO,EAAE/E,WAAW,CAAE;EAE/C;EAEAgC,cAAc,CAAET,KAAK,EAAEE,IAAI,EAAEC,GAAG,EAAEG,kBAAkB,EAAG;IAEtD,MAAMoD,GAAG,GAAG,EAAE;IACd,MAAMC,MAAM,GAAG,CAAC;IAChB,MAAMC,UAAU,GAAG,IAAI9F,iBAAiB,CAAE4F,GAAG,EAAEC,MAAM,EAAEzD,IAAI,EAAEC,GAAG,CAAE;IAClE,MAAM0D,MAAM,GAAG,CAAE,CAAC,EAAE,CAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAE;IACrC,MAAMC,WAAW,GAAG,CAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAE,CAAC,EAAE,CAAE,CAAC,EAAE,CAAE,CAAC,CAAE;IAC9C,MAAM3E,QAAQ,GAAG,IAAI,CAACC,SAAS;IAE/B,MAAM2E,iBAAiB,GAAG5E,QAAQ,CAAC6E,SAAS;IAC5C,MAAMC,WAAW,GAAG9E,QAAQ,CAAC8E,WAAW;IACxC9E,QAAQ,CAAC+E,aAAa,CAAExF,WAAW,CAAE;IAErCS,QAAQ,CAAC8E,WAAW,GAAG3G,aAAa;IACpC6B,QAAQ,CAAC6E,SAAS,GAAG,KAAK;IAE1B,MAAMG,kBAAkB,GAAG,IAAIhG,iBAAiB,CAAE;MACjDiG,IAAI,EAAE,kBAAkB;MACxBC,IAAI,EAAEhG,QAAQ;MACdiG,UAAU,EAAE,KAAK;MACjBC,SAAS,EAAE;IACZ,CAAC,CAAE;IAEH,MAAMC,aAAa,GAAG,IAAI5G,IAAI,CAAE,IAAIQ,WAAW,EAAE,EAAE+F,kBAAkB,CAAE;IAEvE,IAAIM,aAAa,GAAG,KAAK;IACzB,MAAMC,UAAU,GAAG1E,KAAK,CAAC0E,UAAU;IAEnC,IAAKA,UAAU,EAAG;MAEjB,IAAKA,UAAU,CAACC,OAAO,EAAG;QAEzBR,kBAAkB,CAACS,KAAK,CAACC,IAAI,CAAEH,UAAU,CAAE;QAC3C1E,KAAK,CAAC0E,UAAU,GAAG,IAAI;QACvBD,aAAa,GAAG,IAAI;MAErB;IAED,CAAC,MAAM;MAENN,kBAAkB,CAACS,KAAK,CAACC,IAAI,CAAEnG,WAAW,CAAE;MAC5C+F,aAAa,GAAG,IAAI;IAErB;IAEA,KAAM,IAAI5C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAG,EAAG;MAE9B,MAAMiD,GAAG,GAAGjD,CAAC,GAAG,CAAC;MAEjB,IAAKiD,GAAG,KAAK,CAAC,EAAG;QAEhBlB,UAAU,CAACmB,EAAE,CAACC,GAAG,CAAE,CAAC,EAAEnB,MAAM,CAAEhC,CAAC,CAAE,EAAE,CAAC,CAAE;QACtC+B,UAAU,CAACqB,MAAM,CAAEnB,WAAW,CAAEjC,CAAC,CAAE,EAAE,CAAC,EAAE,CAAC,CAAE;MAE5C,CAAC,MAAM,IAAKiD,GAAG,KAAK,CAAC,EAAG;QAEvBlB,UAAU,CAACmB,EAAE,CAACC,GAAG,CAAE,CAAC,EAAE,CAAC,EAAEnB,MAAM,CAAEhC,CAAC,CAAE,CAAE;QACtC+B,UAAU,CAACqB,MAAM,CAAE,CAAC,EAAEnB,WAAW,CAAEjC,CAAC,CAAE,EAAE,CAAC,CAAE;MAE5C,CAAC,MAAM;QAEN+B,UAAU,CAACmB,EAAE,CAACC,GAAG,CAAE,CAAC,EAAEnB,MAAM,CAAEhC,CAAC,CAAE,EAAE,CAAC,CAAE;QACtC+B,UAAU,CAACqB,MAAM,CAAE,CAAC,EAAE,CAAC,EAAEnB,WAAW,CAAEjC,CAAC,CAAE,CAAE;MAE5C;MAEA,MAAMqD,IAAI,GAAG,IAAI,CAAC3F,SAAS;MAE3B2C,YAAY,CAAE5B,kBAAkB,EAAEwE,GAAG,GAAGI,IAAI,EAAErD,CAAC,GAAG,CAAC,GAAGqD,IAAI,GAAG,CAAC,EAAEA,IAAI,EAAEA,IAAI,CAAE;MAE5E/F,QAAQ,CAAC6C,eAAe,CAAE1B,kBAAkB,CAAE;MAE9C,IAAKmE,aAAa,EAAG;QAEpBtF,QAAQ,CAACgG,MAAM,CAAEX,aAAa,EAAEZ,UAAU,CAAE;MAE7C;MAEAzE,QAAQ,CAACgG,MAAM,CAAEnF,KAAK,EAAE4D,UAAU,CAAE;IAErC;IAEAY,aAAa,CAACY,QAAQ,CAAC7D,OAAO,EAAE;IAChCiD,aAAa,CAACjB,QAAQ,CAAChC,OAAO,EAAE;IAEhCpC,QAAQ,CAAC8E,WAAW,GAAGA,WAAW;IAClC9E,QAAQ,CAAC6E,SAAS,GAAGD,iBAAiB;IACtC/D,KAAK,CAAC0E,UAAU,GAAGA,UAAU;EAE9B;EAEAlC,gBAAgB,CAAEH,OAAO,EAAE/B,kBAAkB,EAAG;IAE/C,MAAMnB,QAAQ,GAAG,IAAI,CAACC,SAAS;IAE/B,MAAMiG,aAAa,GAAKhD,OAAO,CAACC,OAAO,KAAKrF,qBAAqB,IAAIoF,OAAO,CAACC,OAAO,KAAKpF,qBAAuB;IAEhH,IAAKmI,aAAa,EAAG;MAEpB,IAAK,IAAI,CAACzF,gBAAgB,KAAK,IAAI,EAAG;QAErC,IAAI,CAACA,gBAAgB,GAAGwB,mBAAmB,EAAE;MAE9C;MAEA,IAAI,CAACxB,gBAAgB,CAAC0F,QAAQ,CAACC,UAAU,CAACC,KAAK,GAAKnD,OAAO,CAACoD,qBAAqB,KAAK,KAAK,GAAK,CAAE,CAAC,GAAG,CAAC;IAExG,CAAC,MAAM;MAEN,IAAK,IAAI,CAAC5F,iBAAiB,KAAK,IAAI,EAAG;QAEtC,IAAI,CAACA,iBAAiB,GAAGyB,oBAAoB,EAAE;MAEhD;IAED;IAEA,MAAMiC,QAAQ,GAAG8B,aAAa,GAAG,IAAI,CAACzF,gBAAgB,GAAG,IAAI,CAACC,iBAAiB;IAC/E,MAAM6F,IAAI,GAAG,IAAI9H,IAAI,CAAE,IAAI,CAAC4B,UAAU,CAAE,CAAC,CAAE,EAAE+D,QAAQ,CAAE;IAEvD,MAAM+B,QAAQ,GAAG/B,QAAQ,CAAC+B,QAAQ;IAElCA,QAAQ,CAAE,QAAQ,CAAE,CAACE,KAAK,GAAGnD,OAAO;IAEpC,MAAM6C,IAAI,GAAG,IAAI,CAAC3F,SAAS;IAE3B2C,YAAY,CAAE5B,kBAAkB,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,GAAG4E,IAAI,EAAE,CAAC,GAAGA,IAAI,CAAE;IAE5D/F,QAAQ,CAAC6C,eAAe,CAAE1B,kBAAkB,CAAE;IAC9CnB,QAAQ,CAACgG,MAAM,CAAEO,IAAI,EAAEjH,WAAW,CAAE;EAErC;EAEAkC,WAAW,CAAEL,kBAAkB,EAAG;IAEjC,MAAMnB,QAAQ,GAAG,IAAI,CAACC,SAAS;IAC/B,MAAM4E,SAAS,GAAG7E,QAAQ,CAAC6E,SAAS;IACpC7E,QAAQ,CAAC6E,SAAS,GAAG,KAAK;IAE1B,KAAM,IAAInC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACrC,UAAU,CAACsC,MAAM,EAAED,CAAC,EAAG,EAAG;MAEnD,MAAM5B,KAAK,GAAGpB,IAAI,CAACC,IAAI,CAAE,IAAI,CAACY,OAAO,CAAEmC,CAAC,CAAE,GAAG,IAAI,CAACnC,OAAO,CAAEmC,CAAC,CAAE,GAAG,IAAI,CAACnC,OAAO,CAAEmC,CAAC,GAAG,CAAC,CAAE,GAAG,IAAI,CAACnC,OAAO,CAAEmC,CAAC,GAAG,CAAC,CAAE,CAAE;MAEhH,MAAM8D,QAAQ,GAAG3G,eAAe,CAAE,CAAE6C,CAAC,GAAG,CAAC,IAAK7C,eAAe,CAAC8C,MAAM,CAAE;MAEtE,IAAI,CAACpB,KAAK,CAAEJ,kBAAkB,EAAEuB,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE5B,KAAK,EAAE0F,QAAQ,CAAE;IAE5D;IAEAxG,QAAQ,CAAC6E,SAAS,GAAGA,SAAS;EAE/B;;EAEA;AACD;AACA;AACA;AACA;AACA;AACA;EACCtD,KAAK,CAAEJ,kBAAkB,EAAEsF,KAAK,EAAEC,MAAM,EAAE5F,KAAK,EAAE0F,QAAQ,EAAG;IAE3D,MAAMG,oBAAoB,GAAG,IAAI,CAACzG,qBAAqB;IAEvD,IAAI,CAAC0G,SAAS,CACbzF,kBAAkB,EAClBwF,oBAAoB,EACpBF,KAAK,EACLC,MAAM,EACN5F,KAAK,EACL,aAAa,EACb0F,QAAQ,CAAE;IAEX,IAAI,CAACI,SAAS,CACbD,oBAAoB,EACpBxF,kBAAkB,EAClBuF,MAAM,EACNA,MAAM,EACN5F,KAAK,EACL,cAAc,EACd0F,QAAQ,CAAE;EAEZ;EAEAI,SAAS,CAAEC,QAAQ,EAAEC,SAAS,EAAEL,KAAK,EAAEC,MAAM,EAAEK,YAAY,EAAEC,SAAS,EAAER,QAAQ,EAAG;IAElF,MAAMxG,QAAQ,GAAG,IAAI,CAACC,SAAS;IAC/B,MAAMgH,YAAY,GAAG,IAAI,CAACzG,aAAa;IAEvC,IAAKwG,SAAS,KAAK,aAAa,IAAIA,SAAS,KAAK,cAAc,EAAG;MAElEE,OAAO,CAACC,KAAK,CACZ,4DAA4D,CAAE;IAEhE;;IAEA;IACA,MAAMC,mBAAmB,GAAG,CAAC;IAE7B,MAAMC,QAAQ,GAAG,IAAI5I,IAAI,CAAE,IAAI,CAAC4B,UAAU,CAAEqG,MAAM,CAAE,EAAEO,YAAY,CAAE;IACpE,MAAMK,YAAY,GAAGL,YAAY,CAACd,QAAQ;IAE1C,MAAMoB,MAAM,GAAG,IAAI,CAACjH,SAAS,CAAEmG,KAAK,CAAE,GAAG,CAAC;IAC1C,MAAMe,eAAe,GAAGC,QAAQ,CAAEV,YAAY,CAAE,GAAGrH,IAAI,CAACgI,EAAE,IAAK,CAAC,GAAGH,MAAM,CAAE,GAAG,CAAC,GAAG7H,IAAI,CAACgI,EAAE,IAAK,CAAC,GAAGrI,WAAW,GAAG,CAAC,CAAE;IACnH,MAAMsI,WAAW,GAAGZ,YAAY,GAAGS,eAAe;IAClD,MAAMI,OAAO,GAAGH,QAAQ,CAAEV,YAAY,CAAE,GAAG,CAAC,GAAGrH,IAAI,CAAC6C,KAAK,CAAE6E,mBAAmB,GAAGO,WAAW,CAAE,GAAGtI,WAAW;IAE5G,IAAKuI,OAAO,GAAGvI,WAAW,EAAG;MAE5B6H,OAAO,CAACW,IAAI,CAAG,iBACdd,YAAa,iDACba,OAAQ,uCAAsCvI,WAAY,EAAC,CAAE;IAE/D;IAEA,MAAMyI,OAAO,GAAG,EAAE;IAClB,IAAIC,GAAG,GAAG,CAAC;IAEX,KAAM,IAAIrF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGrD,WAAW,EAAE,EAAGqD,CAAC,EAAG;MAExC,MAAMsF,CAAC,GAAGtF,CAAC,GAAGiF,WAAW;MACzB,MAAMM,MAAM,GAAGvI,IAAI,CAACwI,GAAG,CAAE,CAAEF,CAAC,GAAGA,CAAC,GAAG,CAAC,CAAE;MACtCF,OAAO,CAACK,IAAI,CAAEF,MAAM,CAAE;MAEtB,IAAKvF,CAAC,KAAK,CAAC,EAAG;QAEdqF,GAAG,IAAIE,MAAM;MAEd,CAAC,MAAM,IAAKvF,CAAC,GAAGkF,OAAO,EAAG;QAEzBG,GAAG,IAAI,CAAC,GAAGE,MAAM;MAElB;IAED;IAEA,KAAM,IAAIvF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoF,OAAO,CAACnF,MAAM,EAAED,CAAC,EAAG,EAAG;MAE3CoF,OAAO,CAAEpF,CAAC,CAAE,GAAGoF,OAAO,CAAEpF,CAAC,CAAE,GAAGqF,GAAG;IAElC;IAEAT,YAAY,CAAE,QAAQ,CAAE,CAACjB,KAAK,GAAGQ,QAAQ,CAAC3D,OAAO;IACjDoE,YAAY,CAAE,SAAS,CAAE,CAACjB,KAAK,GAAGuB,OAAO;IACzCN,YAAY,CAAE,SAAS,CAAE,CAACjB,KAAK,GAAGyB,OAAO;IACzCR,YAAY,CAAE,aAAa,CAAE,CAACjB,KAAK,GAAGW,SAAS,KAAK,aAAa;IAEjE,IAAKR,QAAQ,EAAG;MAEfc,YAAY,CAAE,UAAU,CAAE,CAACjB,KAAK,GAAGG,QAAQ;IAE5C;IAEA,MAAM;MAAErG;IAAQ,CAAC,GAAG,IAAI;IACxBmH,YAAY,CAAE,QAAQ,CAAE,CAACjB,KAAK,GAAGmB,eAAe;IAChDF,YAAY,CAAE,QAAQ,CAAE,CAACjB,KAAK,GAAGlG,OAAO,GAAGsG,KAAK;IAEhD,MAAM2B,UAAU,GAAG,IAAI,CAAC9H,SAAS,CAAEoG,MAAM,CAAE;IAC3C,MAAMsB,CAAC,GAAG,CAAC,GAAGI,UAAU,IAAK1B,MAAM,GAAGvG,OAAO,GAAGhB,OAAO,GAAGuH,MAAM,GAAGvG,OAAO,GAAGhB,OAAO,GAAG,CAAC,CAAE;IAC1F,MAAMkJ,CAAC,GAAG,CAAC,IAAK,IAAI,CAACjI,SAAS,GAAGgI,UAAU,CAAE;IAE7CrF,YAAY,CAAE+D,SAAS,EAAEkB,CAAC,EAAEK,CAAC,EAAE,CAAC,GAAGD,UAAU,EAAE,CAAC,GAAGA,UAAU,CAAE;IAC/DpI,QAAQ,CAAC6C,eAAe,CAAEiE,SAAS,CAAE;IACrC9G,QAAQ,CAACgG,MAAM,CAAEqB,QAAQ,EAAE/H,WAAW,CAAE;EAEzC;AAED;AAIA,SAAS4E,aAAa,CAAEoE,MAAM,EAAG;EAEhC,MAAMtE,SAAS,GAAG,EAAE;EACpB,MAAMD,QAAQ,GAAG,EAAE;EACnB,MAAME,MAAM,GAAG,EAAE;EAEjB,IAAIsE,GAAG,GAAGD,MAAM;EAEhB,MAAME,SAAS,GAAGF,MAAM,GAAGnJ,OAAO,GAAG,CAAC,GAAGC,eAAe,CAACuD,MAAM;EAE/D,KAAM,IAAID,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8F,SAAS,EAAE9F,CAAC,EAAG,EAAG;IAEtC,MAAM+F,OAAO,GAAG/I,IAAI,CAAC+C,GAAG,CAAE,CAAC,EAAE8F,GAAG,CAAE;IAClCxE,QAAQ,CAACoE,IAAI,CAAEM,OAAO,CAAE;IACxB,IAAI3H,KAAK,GAAG,GAAG,GAAG2H,OAAO;IAEzB,IAAK/F,CAAC,GAAG4F,MAAM,GAAGnJ,OAAO,EAAG;MAE3B2B,KAAK,GAAG1B,eAAe,CAAEsD,CAAC,GAAG4F,MAAM,GAAGnJ,OAAO,GAAG,CAAC,CAAE;IAEpD,CAAC,MAAM,IAAKuD,CAAC,KAAK,CAAC,EAAG;MAErB5B,KAAK,GAAG,CAAC;IAEV;IAEAmD,MAAM,CAACkE,IAAI,CAAErH,KAAK,CAAE;IAEpB,MAAM4H,SAAS,GAAG,GAAG,IAAKD,OAAO,GAAG,CAAC,CAAE;IACvC,MAAME,GAAG,GAAG,CAAED,SAAS;IACvB,MAAMpF,GAAG,GAAG,CAAC,GAAGoF,SAAS;IACzB,MAAME,GAAG,GAAG,CAAED,GAAG,EAAEA,GAAG,EAAErF,GAAG,EAAEqF,GAAG,EAAErF,GAAG,EAAEA,GAAG,EAAEqF,GAAG,EAAEA,GAAG,EAAErF,GAAG,EAAEA,GAAG,EAAEqF,GAAG,EAAErF,GAAG,CAAE;IAE1E,MAAMuF,SAAS,GAAG,CAAC;IACnB,MAAMC,QAAQ,GAAG,CAAC;IAClB,MAAMC,YAAY,GAAG,CAAC;IACtB,MAAMC,MAAM,GAAG,CAAC;IAChB,MAAMC,aAAa,GAAG,CAAC;IAEvB,MAAMC,QAAQ,GAAG,IAAIC,YAAY,CAAEJ,YAAY,GAAGD,QAAQ,GAAGD,SAAS,CAAE;IACxE,MAAMO,EAAE,GAAG,IAAID,YAAY,CAAEH,MAAM,GAAGF,QAAQ,GAAGD,SAAS,CAAE;IAC5D,MAAMQ,SAAS,GAAG,IAAIF,YAAY,CAAEF,aAAa,GAAGH,QAAQ,GAAGD,SAAS,CAAE;IAE1E,KAAM,IAAIS,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAGT,SAAS,EAAES,IAAI,EAAG,EAAG;MAE/C,MAAMtB,CAAC,GAAKsB,IAAI,GAAG,CAAC,GAAK,CAAC,GAAG,CAAC,GAAG,CAAC;MAClC,MAAMjB,CAAC,GAAGiB,IAAI,GAAG,CAAC,GAAG,CAAC,GAAG,CAAE,CAAC;MAC5B,MAAMC,WAAW,GAAG,CACnBvB,CAAC,EAAEK,CAAC,EAAE,CAAC,EACPL,CAAC,GAAG,CAAC,GAAG,CAAC,EAAEK,CAAC,EAAE,CAAC,EACfL,CAAC,GAAG,CAAC,GAAG,CAAC,EAAEK,CAAC,GAAG,CAAC,EAAE,CAAC,EACnBL,CAAC,EAAEK,CAAC,EAAE,CAAC,EACPL,CAAC,GAAG,CAAC,GAAG,CAAC,EAAEK,CAAC,GAAG,CAAC,EAAE,CAAC,EACnBL,CAAC,EAAEK,CAAC,GAAG,CAAC,EAAE,CAAC,CACX;MACDa,QAAQ,CAACrD,GAAG,CAAE0D,WAAW,EAAER,YAAY,GAAGD,QAAQ,GAAGQ,IAAI,CAAE;MAC3DF,EAAE,CAACvD,GAAG,CAAE+C,GAAG,EAAEI,MAAM,GAAGF,QAAQ,GAAGQ,IAAI,CAAE;MACvC,MAAME,IAAI,GAAG,CAAEF,IAAI,EAAEA,IAAI,EAAEA,IAAI,EAAEA,IAAI,EAAEA,IAAI,EAAEA,IAAI,CAAE;MACnDD,SAAS,CAACxD,GAAG,CAAE2D,IAAI,EAAEP,aAAa,GAAGH,QAAQ,GAAGQ,IAAI,CAAE;IAEvD;IAEA,MAAMG,MAAM,GAAG,IAAIjL,cAAc,EAAE;IACnCiL,MAAM,CAACC,YAAY,CAAE,UAAU,EAAE,IAAInL,eAAe,CAAE2K,QAAQ,EAAEH,YAAY,CAAE,CAAE;IAChFU,MAAM,CAACC,YAAY,CAAE,IAAI,EAAE,IAAInL,eAAe,CAAE6K,EAAE,EAAEJ,MAAM,CAAE,CAAE;IAC9DS,MAAM,CAACC,YAAY,CAAE,WAAW,EAAE,IAAInL,eAAe,CAAE8K,SAAS,EAAEJ,aAAa,CAAE,CAAE;IACnFjF,SAAS,CAACmE,IAAI,CAAEsB,MAAM,CAAE;IAExB,IAAKlB,GAAG,GAAGpJ,OAAO,EAAG;MAEpBoJ,GAAG,EAAG;IAEP;EAED;EAEA,OAAO;IAAEvE,SAAS;IAAED,QAAQ;IAAEE;EAAO,CAAC;AAEvC;AAEA,SAASH,mBAAmB,CAAEd,KAAK,EAAEC,MAAM,EAAEM,MAAM,EAAG;EAErD,MAAMpC,kBAAkB,GAAG,IAAIpC,iBAAiB,CAAEiE,KAAK,EAAEC,MAAM,EAAEM,MAAM,CAAE;EACzEpC,kBAAkB,CAAC+B,OAAO,CAACC,OAAO,GAAGnF,uBAAuB;EAC5DmD,kBAAkB,CAAC+B,OAAO,CAAC+B,IAAI,GAAG,cAAc;EAChD9D,kBAAkB,CAAC2B,WAAW,GAAG,IAAI;EACrC,OAAO3B,kBAAkB;AAE1B;AAEA,SAAS4B,YAAY,CAAE4G,MAAM,EAAE3B,CAAC,EAAEK,CAAC,EAAErF,KAAK,EAAEC,MAAM,EAAG;EAEpD0G,MAAM,CAACC,QAAQ,CAAC/D,GAAG,CAAEmC,CAAC,EAAEK,CAAC,EAAErF,KAAK,EAAEC,MAAM,CAAE;EAC1C0G,MAAM,CAACE,OAAO,CAAChE,GAAG,CAAEmC,CAAC,EAAEK,CAAC,EAAErF,KAAK,EAAEC,MAAM,CAAE;AAE1C;AAEA,SAASkB,cAAc,CAAEmE,MAAM,EAAEtF,KAAK,EAAEC,MAAM,EAAG;EAEhD,MAAM6E,OAAO,GAAG,IAAIqB,YAAY,CAAE9J,WAAW,CAAE;EAC/C,MAAMmH,QAAQ,GAAG,IAAI3H,OAAO,CAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAE;EACvC,MAAMiL,cAAc,GAAG,IAAIlL,cAAc,CAAE;IAE1CqG,IAAI,EAAE,uBAAuB;IAE7B8E,OAAO,EAAE;MACR,GAAG,EAAE1K,WAAW;MAChB,oBAAoB,EAAE,GAAG,GAAG2D,KAAK;MACjC,qBAAqB,EAAE,GAAG,GAAGC,MAAM;MACnC,gBAAgB,EAAG,GAAEqF,MAAO;IAC7B,CAAC;IAEDnC,QAAQ,EAAE;MACT,QAAQ,EAAE;QAAEE,KAAK,EAAE;MAAK,CAAC;MACzB,SAAS,EAAE;QAAEA,KAAK,EAAE;MAAE,CAAC;MACvB,SAAS,EAAE;QAAEA,KAAK,EAAEyB;MAAQ,CAAC;MAC7B,aAAa,EAAE;QAAEzB,KAAK,EAAE;MAAM,CAAC;MAC/B,QAAQ,EAAE;QAAEA,KAAK,EAAE;MAAE,CAAC;MACtB,QAAQ,EAAE;QAAEA,KAAK,EAAE;MAAE,CAAC;MACtB,UAAU,EAAE;QAAEA,KAAK,EAAEG;MAAS;IAC/B,CAAC;IAEDwD,YAAY,EAAEC,sBAAsB,EAAE;IAEtCC,cAAc,EAAE,UAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;IAEDC,QAAQ,EAAE/L,UAAU;IACpBgH,SAAS,EAAE,KAAK;IAChBD,UAAU,EAAE;EAEb,CAAC,CAAE;EAEH,OAAO2E,cAAc;AAEtB;AAEA,SAAS3H,oBAAoB,GAAG;EAE/B,OAAO,IAAIvD,cAAc,CAAE;IAE1BqG,IAAI,EAAE,yBAAyB;IAE/BkB,QAAQ,EAAE;MACT,QAAQ,EAAE;QAAEE,KAAK,EAAE;MAAK;IACzB,CAAC;IAED2D,YAAY,EAAEC,sBAAsB,EAAE;IAEtCC,cAAc,EAAE,UAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;IAEDC,QAAQ,EAAE/L,UAAU;IACpBgH,SAAS,EAAE,KAAK;IAChBD,UAAU,EAAE;EAEb,CAAC,CAAE;AAEJ;AAEA,SAASlD,mBAAmB,GAAG;EAE9B,OAAO,IAAIrD,cAAc,CAAE;IAE1BqG,IAAI,EAAE,iBAAiB;IAEvBkB,QAAQ,EAAE;MACT,QAAQ,EAAE;QAAEE,KAAK,EAAE;MAAK,CAAC;MACzB,YAAY,EAAE;QAAEA,KAAK,EAAE,CAAE;MAAE;IAC5B,CAAC;IAED2D,YAAY,EAAEC,sBAAsB,EAAE;IAEtCC,cAAc,EAAE,UAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;IAEDC,QAAQ,EAAE/L,UAAU;IACpBgH,SAAS,EAAE,KAAK;IAChBD,UAAU,EAAE;EAEb,CAAC,CAAE;AAEJ;AAEA,SAAS8E,sBAAsB,GAAG;EAEjC,OAAO,WAAW;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAAE;AAEF;AAEA,SAASnK,cAAc"},"metadata":{},"sourceType":"module","externalDependencies":[]}