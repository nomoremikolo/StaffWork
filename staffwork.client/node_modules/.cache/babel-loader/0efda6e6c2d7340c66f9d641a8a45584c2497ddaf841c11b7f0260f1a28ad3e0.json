{"ast":null,"code":"import { Quaternion } from '../math/Quaternion.js';\nclass PropertyMixer {\n  constructor(binding, typeName, valueSize) {\n    this.binding = binding;\n    this.valueSize = valueSize;\n    let mixFunction, mixFunctionAdditive, setIdentity;\n\n    // buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]\n    //\n    // interpolators can use .buffer as their .result\n    // the data then goes to 'incoming'\n    //\n    // 'accu0' and 'accu1' are used frame-interleaved for\n    // the cumulative result and are compared to detect\n    // changes\n    //\n    // 'orig' stores the original state of the property\n    //\n    // 'add' is used for additive cumulative results\n    //\n    // 'work' is optional and is only present for quaternion types. It is used\n    // to store intermediate quaternion multiplication results\n\n    switch (typeName) {\n      case 'quaternion':\n        mixFunction = this._slerp;\n        mixFunctionAdditive = this._slerpAdditive;\n        setIdentity = this._setAdditiveIdentityQuaternion;\n        this.buffer = new Float64Array(valueSize * 6);\n        this._workIndex = 5;\n        break;\n      case 'string':\n      case 'bool':\n        mixFunction = this._select;\n\n        // Use the regular mix function and for additive on these types,\n        // additive is not relevant for non-numeric types\n        mixFunctionAdditive = this._select;\n        setIdentity = this._setAdditiveIdentityOther;\n        this.buffer = new Array(valueSize * 5);\n        break;\n      default:\n        mixFunction = this._lerp;\n        mixFunctionAdditive = this._lerpAdditive;\n        setIdentity = this._setAdditiveIdentityNumeric;\n        this.buffer = new Float64Array(valueSize * 5);\n    }\n    this._mixBufferRegion = mixFunction;\n    this._mixBufferRegionAdditive = mixFunctionAdditive;\n    this._setIdentity = setIdentity;\n    this._origIndex = 3;\n    this._addIndex = 4;\n    this.cumulativeWeight = 0;\n    this.cumulativeWeightAdditive = 0;\n    this.useCount = 0;\n    this.referenceCount = 0;\n  }\n\n  // accumulate data in the 'incoming' region into 'accu<i>'\n  accumulate(accuIndex, weight) {\n    // note: happily accumulating nothing when weight = 0, the caller knows\n    // the weight and shouldn't have made the call in the first place\n\n    const buffer = this.buffer,\n      stride = this.valueSize,\n      offset = accuIndex * stride + stride;\n    let currentWeight = this.cumulativeWeight;\n    if (currentWeight === 0) {\n      // accuN := incoming * weight\n\n      for (let i = 0; i !== stride; ++i) {\n        buffer[offset + i] = buffer[i];\n      }\n      currentWeight = weight;\n    } else {\n      // accuN := accuN + incoming * weight\n\n      currentWeight += weight;\n      const mix = weight / currentWeight;\n      this._mixBufferRegion(buffer, offset, 0, mix, stride);\n    }\n    this.cumulativeWeight = currentWeight;\n  }\n\n  // accumulate data in the 'incoming' region into 'add'\n  accumulateAdditive(weight) {\n    const buffer = this.buffer,\n      stride = this.valueSize,\n      offset = stride * this._addIndex;\n    if (this.cumulativeWeightAdditive === 0) {\n      // add = identity\n\n      this._setIdentity();\n    }\n\n    // add := add + incoming * weight\n\n    this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);\n    this.cumulativeWeightAdditive += weight;\n  }\n\n  // apply the state of 'accu<i>' to the binding when accus differ\n  apply(accuIndex) {\n    const stride = this.valueSize,\n      buffer = this.buffer,\n      offset = accuIndex * stride + stride,\n      weight = this.cumulativeWeight,\n      weightAdditive = this.cumulativeWeightAdditive,\n      binding = this.binding;\n    this.cumulativeWeight = 0;\n    this.cumulativeWeightAdditive = 0;\n    if (weight < 1) {\n      // accuN := accuN + original * ( 1 - cumulativeWeight )\n\n      const originalValueOffset = stride * this._origIndex;\n      this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);\n    }\n    if (weightAdditive > 0) {\n      // accuN := accuN + additive accuN\n\n      this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);\n    }\n    for (let i = stride, e = stride + stride; i !== e; ++i) {\n      if (buffer[i] !== buffer[i + stride]) {\n        // value has changed -> update scene graph\n\n        binding.setValue(buffer, offset);\n        break;\n      }\n    }\n  }\n\n  // remember the state of the bound property and copy it to both accus\n  saveOriginalState() {\n    const binding = this.binding;\n    const buffer = this.buffer,\n      stride = this.valueSize,\n      originalValueOffset = stride * this._origIndex;\n    binding.getValue(buffer, originalValueOffset);\n\n    // accu[0..1] := orig -- initially detect changes against the original\n    for (let i = stride, e = originalValueOffset; i !== e; ++i) {\n      buffer[i] = buffer[originalValueOffset + i % stride];\n    }\n\n    // Add to identity for additive\n    this._setIdentity();\n    this.cumulativeWeight = 0;\n    this.cumulativeWeightAdditive = 0;\n  }\n\n  // apply the state previously taken via 'saveOriginalState' to the binding\n  restoreOriginalState() {\n    const originalValueOffset = this.valueSize * 3;\n    this.binding.setValue(this.buffer, originalValueOffset);\n  }\n  _setAdditiveIdentityNumeric() {\n    const startIndex = this._addIndex * this.valueSize;\n    const endIndex = startIndex + this.valueSize;\n    for (let i = startIndex; i < endIndex; i++) {\n      this.buffer[i] = 0;\n    }\n  }\n  _setAdditiveIdentityQuaternion() {\n    this._setAdditiveIdentityNumeric();\n    this.buffer[this._addIndex * this.valueSize + 3] = 1;\n  }\n  _setAdditiveIdentityOther() {\n    const startIndex = this._origIndex * this.valueSize;\n    const targetIndex = this._addIndex * this.valueSize;\n    for (let i = 0; i < this.valueSize; i++) {\n      this.buffer[targetIndex + i] = this.buffer[startIndex + i];\n    }\n  }\n\n  // mix functions\n\n  _select(buffer, dstOffset, srcOffset, t, stride) {\n    if (t >= 0.5) {\n      for (let i = 0; i !== stride; ++i) {\n        buffer[dstOffset + i] = buffer[srcOffset + i];\n      }\n    }\n  }\n  _slerp(buffer, dstOffset, srcOffset, t) {\n    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);\n  }\n  _slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {\n    const workOffset = this._workIndex * stride;\n\n    // Store result in intermediate buffer offset\n    Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);\n\n    // Slerp to the intermediate result\n    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);\n  }\n  _lerp(buffer, dstOffset, srcOffset, t, stride) {\n    const s = 1 - t;\n    for (let i = 0; i !== stride; ++i) {\n      const j = dstOffset + i;\n      buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;\n    }\n  }\n  _lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {\n    for (let i = 0; i !== stride; ++i) {\n      const j = dstOffset + i;\n      buffer[j] = buffer[j] + buffer[srcOffset + i] * t;\n    }\n  }\n}\nexport { PropertyMixer };","map":{"version":3,"names":["Quaternion","PropertyMixer","constructor","binding","typeName","valueSize","mixFunction","mixFunctionAdditive","setIdentity","_slerp","_slerpAdditive","_setAdditiveIdentityQuaternion","buffer","Float64Array","_workIndex","_select","_setAdditiveIdentityOther","Array","_lerp","_lerpAdditive","_setAdditiveIdentityNumeric","_mixBufferRegion","_mixBufferRegionAdditive","_setIdentity","_origIndex","_addIndex","cumulativeWeight","cumulativeWeightAdditive","useCount","referenceCount","accumulate","accuIndex","weight","stride","offset","currentWeight","i","mix","accumulateAdditive","apply","weightAdditive","originalValueOffset","e","setValue","saveOriginalState","getValue","restoreOriginalState","startIndex","endIndex","targetIndex","dstOffset","srcOffset","t","slerpFlat","workOffset","multiplyQuaternionsFlat","s","j"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/animation/PropertyMixer.js"],"sourcesContent":["import { Quaternion } from '../math/Quaternion.js';\n\nclass PropertyMixer {\n\n\tconstructor( binding, typeName, valueSize ) {\n\n\t\tthis.binding = binding;\n\t\tthis.valueSize = valueSize;\n\n\t\tlet mixFunction,\n\t\t\tmixFunctionAdditive,\n\t\t\tsetIdentity;\n\n\t\t// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]\n\t\t//\n\t\t// interpolators can use .buffer as their .result\n\t\t// the data then goes to 'incoming'\n\t\t//\n\t\t// 'accu0' and 'accu1' are used frame-interleaved for\n\t\t// the cumulative result and are compared to detect\n\t\t// changes\n\t\t//\n\t\t// 'orig' stores the original state of the property\n\t\t//\n\t\t// 'add' is used for additive cumulative results\n\t\t//\n\t\t// 'work' is optional and is only present for quaternion types. It is used\n\t\t// to store intermediate quaternion multiplication results\n\n\t\tswitch ( typeName ) {\n\n\t\t\tcase 'quaternion':\n\t\t\t\tmixFunction = this._slerp;\n\t\t\t\tmixFunctionAdditive = this._slerpAdditive;\n\t\t\t\tsetIdentity = this._setAdditiveIdentityQuaternion;\n\n\t\t\t\tthis.buffer = new Float64Array( valueSize * 6 );\n\t\t\t\tthis._workIndex = 5;\n\t\t\t\tbreak;\n\n\t\t\tcase 'string':\n\t\t\tcase 'bool':\n\t\t\t\tmixFunction = this._select;\n\n\t\t\t\t// Use the regular mix function and for additive on these types,\n\t\t\t\t// additive is not relevant for non-numeric types\n\t\t\t\tmixFunctionAdditive = this._select;\n\n\t\t\t\tsetIdentity = this._setAdditiveIdentityOther;\n\n\t\t\t\tthis.buffer = new Array( valueSize * 5 );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tmixFunction = this._lerp;\n\t\t\t\tmixFunctionAdditive = this._lerpAdditive;\n\t\t\t\tsetIdentity = this._setAdditiveIdentityNumeric;\n\n\t\t\t\tthis.buffer = new Float64Array( valueSize * 5 );\n\n\t\t}\n\n\t\tthis._mixBufferRegion = mixFunction;\n\t\tthis._mixBufferRegionAdditive = mixFunctionAdditive;\n\t\tthis._setIdentity = setIdentity;\n\t\tthis._origIndex = 3;\n\t\tthis._addIndex = 4;\n\n\t\tthis.cumulativeWeight = 0;\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t\tthis.useCount = 0;\n\t\tthis.referenceCount = 0;\n\n\t}\n\n\t// accumulate data in the 'incoming' region into 'accu<i>'\n\taccumulate( accuIndex, weight ) {\n\n\t\t// note: happily accumulating nothing when weight = 0, the caller knows\n\t\t// the weight and shouldn't have made the call in the first place\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = accuIndex * stride + stride;\n\n\t\tlet currentWeight = this.cumulativeWeight;\n\n\t\tif ( currentWeight === 0 ) {\n\n\t\t\t// accuN := incoming * weight\n\n\t\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\n\n\t\t\t}\n\n\t\t\tcurrentWeight = weight;\n\n\t\t} else {\n\n\t\t\t// accuN := accuN + incoming * weight\n\n\t\t\tcurrentWeight += weight;\n\t\t\tconst mix = weight / currentWeight;\n\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\n\n\t\t}\n\n\t\tthis.cumulativeWeight = currentWeight;\n\n\t}\n\n\t// accumulate data in the 'incoming' region into 'add'\n\taccumulateAdditive( weight ) {\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = stride * this._addIndex;\n\n\t\tif ( this.cumulativeWeightAdditive === 0 ) {\n\n\t\t\t// add = identity\n\n\t\t\tthis._setIdentity();\n\n\t\t}\n\n\t\t// add := add + incoming * weight\n\n\t\tthis._mixBufferRegionAdditive( buffer, offset, 0, weight, stride );\n\t\tthis.cumulativeWeightAdditive += weight;\n\n\t}\n\n\t// apply the state of 'accu<i>' to the binding when accus differ\n\tapply( accuIndex ) {\n\n\t\tconst stride = this.valueSize,\n\t\t\tbuffer = this.buffer,\n\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\tweight = this.cumulativeWeight,\n\t\t\tweightAdditive = this.cumulativeWeightAdditive,\n\n\t\t\tbinding = this.binding;\n\n\t\tthis.cumulativeWeight = 0;\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t\tif ( weight < 1 ) {\n\n\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\n\n\t\t\tconst originalValueOffset = stride * this._origIndex;\n\n\t\t\tthis._mixBufferRegion(\n\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\n\n\t\t}\n\n\t\tif ( weightAdditive > 0 ) {\n\n\t\t\t// accuN := accuN + additive accuN\n\n\t\t\tthis._mixBufferRegionAdditive( buffer, offset, this._addIndex * stride, 1, stride );\n\n\t\t}\n\n\t\tfor ( let i = stride, e = stride + stride; i !== e; ++ i ) {\n\n\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\n\n\t\t\t\t// value has changed -> update scene graph\n\n\t\t\t\tbinding.setValue( buffer, offset );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// remember the state of the bound property and copy it to both accus\n\tsaveOriginalState() {\n\n\t\tconst binding = this.binding;\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\n\t\t\toriginalValueOffset = stride * this._origIndex;\n\n\t\tbinding.getValue( buffer, originalValueOffset );\n\n\t\t// accu[0..1] := orig -- initially detect changes against the original\n\t\tfor ( let i = stride, e = originalValueOffset; i !== e; ++ i ) {\n\n\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\n\n\t\t}\n\n\t\t// Add to identity for additive\n\t\tthis._setIdentity();\n\n\t\tthis.cumulativeWeight = 0;\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t}\n\n\t// apply the state previously taken via 'saveOriginalState' to the binding\n\trestoreOriginalState() {\n\n\t\tconst originalValueOffset = this.valueSize * 3;\n\t\tthis.binding.setValue( this.buffer, originalValueOffset );\n\n\t}\n\n\t_setAdditiveIdentityNumeric() {\n\n\t\tconst startIndex = this._addIndex * this.valueSize;\n\t\tconst endIndex = startIndex + this.valueSize;\n\n\t\tfor ( let i = startIndex; i < endIndex; i ++ ) {\n\n\t\t\tthis.buffer[ i ] = 0;\n\n\t\t}\n\n\t}\n\n\t_setAdditiveIdentityQuaternion() {\n\n\t\tthis._setAdditiveIdentityNumeric();\n\t\tthis.buffer[ this._addIndex * this.valueSize + 3 ] = 1;\n\n\t}\n\n\t_setAdditiveIdentityOther() {\n\n\t\tconst startIndex = this._origIndex * this.valueSize;\n\t\tconst targetIndex = this._addIndex * this.valueSize;\n\n\t\tfor ( let i = 0; i < this.valueSize; i ++ ) {\n\n\t\t\tthis.buffer[ targetIndex + i ] = this.buffer[ startIndex + i ];\n\n\t\t}\n\n\t}\n\n\n\t// mix functions\n\n\t_select( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tif ( t >= 0.5 ) {\n\n\t\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_slerp( buffer, dstOffset, srcOffset, t ) {\n\n\t\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );\n\n\t}\n\n\t_slerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tconst workOffset = this._workIndex * stride;\n\n\t\t// Store result in intermediate buffer offset\n\t\tQuaternion.multiplyQuaternionsFlat( buffer, workOffset, buffer, dstOffset, buffer, srcOffset );\n\n\t\t// Slerp to the intermediate result\n\t\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t );\n\n\t}\n\n\t_lerp( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tconst s = 1 - t;\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tconst j = dstOffset + i;\n\n\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\n\n\t\t}\n\n\t}\n\n\t_lerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tconst j = dstOffset + i;\n\n\t\t\tbuffer[ j ] = buffer[ j ] + buffer[ srcOffset + i ] * t;\n\n\t\t}\n\n\t}\n\n}\n\n\nexport { PropertyMixer };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}