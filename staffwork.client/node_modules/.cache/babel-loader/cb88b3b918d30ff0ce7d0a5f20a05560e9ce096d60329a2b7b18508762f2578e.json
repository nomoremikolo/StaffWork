{"ast":null,"code":"import { Vector3 } from './Vector3.js';\nclass Box3 {\n  constructor() {\n    let min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3(+Infinity, +Infinity, +Infinity);\n    let max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3(-Infinity, -Infinity, -Infinity);\n    this.isBox3 = true;\n    this.min = min;\n    this.max = max;\n  }\n  set(min, max) {\n    this.min.copy(min);\n    this.max.copy(max);\n    return this;\n  }\n  setFromArray(array) {\n    let minX = +Infinity;\n    let minY = +Infinity;\n    let minZ = +Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    let maxZ = -Infinity;\n    for (let i = 0, l = array.length; i < l; i += 3) {\n      const x = array[i];\n      const y = array[i + 1];\n      const z = array[i + 2];\n      if (x < minX) minX = x;\n      if (y < minY) minY = y;\n      if (z < minZ) minZ = z;\n      if (x > maxX) maxX = x;\n      if (y > maxY) maxY = y;\n      if (z > maxZ) maxZ = z;\n    }\n    this.min.set(minX, minY, minZ);\n    this.max.set(maxX, maxY, maxZ);\n    return this;\n  }\n  setFromBufferAttribute(attribute) {\n    let minX = +Infinity;\n    let minY = +Infinity;\n    let minZ = +Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    let maxZ = -Infinity;\n    for (let i = 0, l = attribute.count; i < l; i++) {\n      const x = attribute.getX(i);\n      const y = attribute.getY(i);\n      const z = attribute.getZ(i);\n      if (x < minX) minX = x;\n      if (y < minY) minY = y;\n      if (z < minZ) minZ = z;\n      if (x > maxX) maxX = x;\n      if (y > maxY) maxY = y;\n      if (z > maxZ) maxZ = z;\n    }\n    this.min.set(minX, minY, minZ);\n    this.max.set(maxX, maxY, maxZ);\n    return this;\n  }\n  setFromPoints(points) {\n    this.makeEmpty();\n    for (let i = 0, il = points.length; i < il; i++) {\n      this.expandByPoint(points[i]);\n    }\n    return this;\n  }\n  setFromCenterAndSize(center, size) {\n    const halfSize = _vector.copy(size).multiplyScalar(0.5);\n    this.min.copy(center).sub(halfSize);\n    this.max.copy(center).add(halfSize);\n    return this;\n  }\n  setFromObject(object) {\n    let precise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this.makeEmpty();\n    return this.expandByObject(object, precise);\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  copy(box) {\n    this.min.copy(box.min);\n    this.max.copy(box.max);\n    return this;\n  }\n  makeEmpty() {\n    this.min.x = this.min.y = this.min.z = +Infinity;\n    this.max.x = this.max.y = this.max.z = -Infinity;\n    return this;\n  }\n  isEmpty() {\n    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;\n  }\n  getCenter(target) {\n    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);\n  }\n  getSize(target) {\n    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);\n  }\n  expandByPoint(point) {\n    this.min.min(point);\n    this.max.max(point);\n    return this;\n  }\n  expandByVector(vector) {\n    this.min.sub(vector);\n    this.max.add(vector);\n    return this;\n  }\n  expandByScalar(scalar) {\n    this.min.addScalar(-scalar);\n    this.max.addScalar(scalar);\n    return this;\n  }\n  expandByObject(object) {\n    let precise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    // Computes the world-axis-aligned bounding box of an object (including its children),\n    // accounting for both the object's, and children's, world transforms\n\n    object.updateWorldMatrix(false, false);\n    const geometry = object.geometry;\n    if (geometry !== undefined) {\n      if (precise && geometry.attributes != undefined && geometry.attributes.position !== undefined) {\n        const position = geometry.attributes.position;\n        for (let i = 0, l = position.count; i < l; i++) {\n          _vector.fromBufferAttribute(position, i).applyMatrix4(object.matrixWorld);\n          this.expandByPoint(_vector);\n        }\n      } else {\n        if (geometry.boundingBox === null) {\n          geometry.computeBoundingBox();\n        }\n        _box.copy(geometry.boundingBox);\n        _box.applyMatrix4(object.matrixWorld);\n        this.union(_box);\n      }\n    }\n    const children = object.children;\n    for (let i = 0, l = children.length; i < l; i++) {\n      this.expandByObject(children[i], precise);\n    }\n    return this;\n  }\n  containsPoint(point) {\n    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;\n  }\n  containsBox(box) {\n    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;\n  }\n  getParameter(point, target) {\n    // This can potentially have a divide by zero if the box\n    // has a size dimension of 0.\n\n    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));\n  }\n  intersectsBox(box) {\n    // using 6 splitting planes to rule out intersections.\n    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;\n  }\n  intersectsSphere(sphere) {\n    // Find the point on the AABB closest to the sphere center.\n    this.clampPoint(sphere.center, _vector);\n\n    // If that point is inside the sphere, the AABB and sphere intersect.\n    return _vector.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;\n  }\n  intersectsPlane(plane) {\n    // We compute the minimum and maximum dot product values. If those values\n    // are on the same side (back or front) of the plane, then there is no intersection.\n\n    let min, max;\n    if (plane.normal.x > 0) {\n      min = plane.normal.x * this.min.x;\n      max = plane.normal.x * this.max.x;\n    } else {\n      min = plane.normal.x * this.max.x;\n      max = plane.normal.x * this.min.x;\n    }\n    if (plane.normal.y > 0) {\n      min += plane.normal.y * this.min.y;\n      max += plane.normal.y * this.max.y;\n    } else {\n      min += plane.normal.y * this.max.y;\n      max += plane.normal.y * this.min.y;\n    }\n    if (plane.normal.z > 0) {\n      min += plane.normal.z * this.min.z;\n      max += plane.normal.z * this.max.z;\n    } else {\n      min += plane.normal.z * this.max.z;\n      max += plane.normal.z * this.min.z;\n    }\n    return min <= -plane.constant && max >= -plane.constant;\n  }\n  intersectsTriangle(triangle) {\n    if (this.isEmpty()) {\n      return false;\n    }\n\n    // compute box center and extents\n    this.getCenter(_center);\n    _extents.subVectors(this.max, _center);\n\n    // translate triangle to aabb origin\n    _v0.subVectors(triangle.a, _center);\n    _v1.subVectors(triangle.b, _center);\n    _v2.subVectors(triangle.c, _center);\n\n    // compute edge vectors for triangle\n    _f0.subVectors(_v1, _v0);\n    _f1.subVectors(_v2, _v1);\n    _f2.subVectors(_v0, _v2);\n\n    // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb\n    // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation\n    // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)\n    let axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];\n    if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {\n      return false;\n    }\n\n    // test 3 face normals from the aabb\n    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {\n      return false;\n    }\n\n    // finally testing the face normal of the triangle\n    // use already existing triangle edge vectors here\n    _triangleNormal.crossVectors(_f0, _f1);\n    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];\n    return satForAxes(axes, _v0, _v1, _v2, _extents);\n  }\n  clampPoint(point, target) {\n    return target.copy(point).clamp(this.min, this.max);\n  }\n  distanceToPoint(point) {\n    const clampedPoint = _vector.copy(point).clamp(this.min, this.max);\n    return clampedPoint.sub(point).length();\n  }\n  getBoundingSphere(target) {\n    this.getCenter(target.center);\n    target.radius = this.getSize(_vector).length() * 0.5;\n    return target;\n  }\n  intersect(box) {\n    this.min.max(box.min);\n    this.max.min(box.max);\n\n    // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n    if (this.isEmpty()) this.makeEmpty();\n    return this;\n  }\n  union(box) {\n    this.min.min(box.min);\n    this.max.max(box.max);\n    return this;\n  }\n  applyMatrix4(matrix) {\n    // transform of empty box is an empty box.\n    if (this.isEmpty()) return this;\n\n    // NOTE: I am using a binary pattern to specify all 2^3 combinations below\n    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000\n    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001\n    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010\n    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011\n    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100\n    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101\n    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110\n    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111\n\n    this.setFromPoints(_points);\n    return this;\n  }\n  translate(offset) {\n    this.min.add(offset);\n    this.max.add(offset);\n    return this;\n  }\n  equals(box) {\n    return box.min.equals(this.min) && box.max.equals(this.max);\n  }\n}\nconst _points = [/*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3()];\nconst _vector = /*@__PURE__*/new Vector3();\nconst _box = /*@__PURE__*/new Box3();\n\n// triangle centered vertices\n\nconst _v0 = /*@__PURE__*/new Vector3();\nconst _v1 = /*@__PURE__*/new Vector3();\nconst _v2 = /*@__PURE__*/new Vector3();\n\n// triangle edge vectors\n\nconst _f0 = /*@__PURE__*/new Vector3();\nconst _f1 = /*@__PURE__*/new Vector3();\nconst _f2 = /*@__PURE__*/new Vector3();\nconst _center = /*@__PURE__*/new Vector3();\nconst _extents = /*@__PURE__*/new Vector3();\nconst _triangleNormal = /*@__PURE__*/new Vector3();\nconst _testAxis = /*@__PURE__*/new Vector3();\nfunction satForAxes(axes, v0, v1, v2, extents) {\n  for (let i = 0, j = axes.length - 3; i <= j; i += 3) {\n    _testAxis.fromArray(axes, i);\n    // project the aabb onto the separating axis\n    const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);\n    // project all 3 vertices of the triangle onto the separating axis\n    const p0 = v0.dot(_testAxis);\n    const p1 = v1.dot(_testAxis);\n    const p2 = v2.dot(_testAxis);\n    // actual test, basically see if either of the most extreme of the triangle points intersects r\n    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {\n      // points of the projected triangle are outside the projected half-length of the aabb\n      // the axis is separating and we can exit\n      return false;\n    }\n  }\n  return true;\n}\nexport { Box3 };","map":{"version":3,"names":["Vector3","Box3","constructor","min","Infinity","max","isBox3","set","copy","setFromArray","array","minX","minY","minZ","maxX","maxY","maxZ","i","l","length","x","y","z","setFromBufferAttribute","attribute","count","getX","getY","getZ","setFromPoints","points","makeEmpty","il","expandByPoint","setFromCenterAndSize","center","size","halfSize","_vector","multiplyScalar","sub","add","setFromObject","object","precise","expandByObject","clone","box","isEmpty","getCenter","target","addVectors","getSize","subVectors","point","expandByVector","vector","expandByScalar","scalar","addScalar","updateWorldMatrix","geometry","undefined","attributes","position","fromBufferAttribute","applyMatrix4","matrixWorld","boundingBox","computeBoundingBox","_box","union","children","containsPoint","containsBox","getParameter","intersectsBox","intersectsSphere","sphere","clampPoint","distanceToSquared","radius","intersectsPlane","plane","normal","constant","intersectsTriangle","triangle","_center","_extents","_v0","a","_v1","b","_v2","c","_f0","_f1","_f2","axes","satForAxes","_triangleNormal","crossVectors","clamp","distanceToPoint","clampedPoint","getBoundingSphere","intersect","matrix","_points","translate","offset","equals","_testAxis","v0","v1","v2","extents","j","fromArray","r","Math","abs","p0","dot","p1","p2"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/math/Box3.js"],"sourcesContent":["import { Vector3 } from './Vector3.js';\n\nclass Box3 {\n\n\tconstructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {\n\n\t\tthis.isBox3 = true;\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tset( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromArray( array ) {\n\n\t\tlet minX = + Infinity;\n\t\tlet minY = + Infinity;\n\t\tlet minZ = + Infinity;\n\n\t\tlet maxX = - Infinity;\n\t\tlet maxY = - Infinity;\n\t\tlet maxZ = - Infinity;\n\n\t\tfor ( let i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\tconst x = array[ i ];\n\t\t\tconst y = array[ i + 1 ];\n\t\t\tconst z = array[ i + 2 ];\n\n\t\t\tif ( x < minX ) minX = x;\n\t\t\tif ( y < minY ) minY = y;\n\t\t\tif ( z < minZ ) minZ = z;\n\n\t\t\tif ( x > maxX ) maxX = x;\n\t\t\tif ( y > maxY ) maxY = y;\n\t\t\tif ( z > maxZ ) maxZ = z;\n\n\t\t}\n\n\t\tthis.min.set( minX, minY, minZ );\n\t\tthis.max.set( maxX, maxY, maxZ );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromBufferAttribute( attribute ) {\n\n\t\tlet minX = + Infinity;\n\t\tlet minY = + Infinity;\n\t\tlet minZ = + Infinity;\n\n\t\tlet maxX = - Infinity;\n\t\tlet maxY = - Infinity;\n\t\tlet maxZ = - Infinity;\n\n\t\tfor ( let i = 0, l = attribute.count; i < l; i ++ ) {\n\n\t\t\tconst x = attribute.getX( i );\n\t\t\tconst y = attribute.getY( i );\n\t\t\tconst z = attribute.getZ( i );\n\n\t\t\tif ( x < minX ) minX = x;\n\t\t\tif ( y < minY ) minY = y;\n\t\t\tif ( z < minZ ) minZ = z;\n\n\t\t\tif ( x > maxX ) maxX = x;\n\t\t\tif ( y > maxY ) maxY = y;\n\t\t\tif ( z > maxZ ) maxZ = z;\n\n\t\t}\n\n\t\tthis.min.set( minX, minY, minZ );\n\t\tthis.max.set( maxX, maxY, maxZ );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( let i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCenterAndSize( center, size ) {\n\n\t\tconst halfSize = _vector.copy( size ).multiplyScalar( 0.5 );\n\n\t\tthis.min.copy( center ).sub( halfSize );\n\t\tthis.max.copy( center ).add( halfSize );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromObject( object, precise = false ) {\n\n\t\tthis.makeEmpty();\n\n\t\treturn this.expandByObject( object, precise );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t}\n\n\tmakeEmpty() {\n\n\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\n\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\n\n\t\treturn this;\n\n\t}\n\n\tisEmpty() {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\n\n\t}\n\n\tgetCenter( target ) {\n\n\t\treturn this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t}\n\n\tgetSize( target ) {\n\n\t\treturn this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );\n\n\t}\n\n\texpandByPoint( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t}\n\n\texpandByVector( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t}\n\n\texpandByScalar( scalar ) {\n\n\t\tthis.min.addScalar( - scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t}\n\n\texpandByObject( object, precise = false ) {\n\n\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t\t// accounting for both the object's, and children's, world transforms\n\n\t\tobject.updateWorldMatrix( false, false );\n\n\t\tconst geometry = object.geometry;\n\n\t\tif ( geometry !== undefined ) {\n\n\t\t\tif ( precise && geometry.attributes != undefined && geometry.attributes.position !== undefined ) {\n\n\t\t\t\tconst position = geometry.attributes.position;\n\t\t\t\tfor ( let i = 0, l = position.count; i < l; i ++ ) {\n\n\t\t\t\t\t_vector.fromBufferAttribute( position, i ).applyMatrix4( object.matrixWorld );\n\t\t\t\t\tthis.expandByPoint( _vector );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( geometry.boundingBox === null ) {\n\n\t\t\t\t\tgeometry.computeBoundingBox();\n\n\t\t\t\t}\n\n\t\t\t\t_box.copy( geometry.boundingBox );\n\t\t\t\t_box.applyMatrix4( object.matrixWorld );\n\n\t\t\t\tthis.union( _box );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tthis.expandByObject( children[ i ], precise );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\treturn point.x < this.min.x || point.x > this.max.x ||\n\t\t\tpoint.y < this.min.y || point.y > this.max.y ||\n\t\t\tpoint.z < this.min.z || point.z > this.max.z ? false : true;\n\n\t}\n\n\tcontainsBox( box ) {\n\n\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\n\t\t\tthis.min.y <= box.min.y && box.max.y <= this.max.y &&\n\t\t\tthis.min.z <= box.min.z && box.max.z <= this.max.z;\n\n\t}\n\n\tgetParameter( point, target ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\treturn target.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\n\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\n\t\t);\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\t// using 6 splitting planes to rule out intersections.\n\t\treturn box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\tbox.max.y < this.min.y || box.min.y > this.max.y ||\n\t\t\tbox.max.z < this.min.z || box.min.z > this.max.z ? false : true;\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\t// Find the point on the AABB closest to the sphere center.\n\t\tthis.clampPoint( sphere.center, _vector );\n\n\t\t// If that point is inside the sphere, the AABB and sphere intersect.\n\t\treturn _vector.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t}\n\n\tintersectsPlane( plane ) {\n\n\t\t// We compute the minimum and maximum dot product values. If those values\n\t\t// are on the same side (back or front) of the plane, then there is no intersection.\n\n\t\tlet min, max;\n\n\t\tif ( plane.normal.x > 0 ) {\n\n\t\t\tmin = plane.normal.x * this.min.x;\n\t\t\tmax = plane.normal.x * this.max.x;\n\n\t\t} else {\n\n\t\t\tmin = plane.normal.x * this.max.x;\n\t\t\tmax = plane.normal.x * this.min.x;\n\n\t\t}\n\n\t\tif ( plane.normal.y > 0 ) {\n\n\t\t\tmin += plane.normal.y * this.min.y;\n\t\t\tmax += plane.normal.y * this.max.y;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.y * this.max.y;\n\t\t\tmax += plane.normal.y * this.min.y;\n\n\t\t}\n\n\t\tif ( plane.normal.z > 0 ) {\n\n\t\t\tmin += plane.normal.z * this.min.z;\n\t\t\tmax += plane.normal.z * this.max.z;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.z * this.max.z;\n\t\t\tmax += plane.normal.z * this.min.z;\n\n\t\t}\n\n\t\treturn ( min <= - plane.constant && max >= - plane.constant );\n\n\t}\n\n\tintersectsTriangle( triangle ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// compute box center and extents\n\t\tthis.getCenter( _center );\n\t\t_extents.subVectors( this.max, _center );\n\n\t\t// translate triangle to aabb origin\n\t\t_v0.subVectors( triangle.a, _center );\n\t\t_v1.subVectors( triangle.b, _center );\n\t\t_v2.subVectors( triangle.c, _center );\n\n\t\t// compute edge vectors for triangle\n\t\t_f0.subVectors( _v1, _v0 );\n\t\t_f1.subVectors( _v2, _v1 );\n\t\t_f2.subVectors( _v0, _v2 );\n\n\t\t// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb\n\t\t// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation\n\t\t// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)\n\t\tlet axes = [\n\t\t\t0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,\n\t\t\t_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,\n\t\t\t- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0\n\t\t];\n\t\tif ( ! satForAxes( axes, _v0, _v1, _v2, _extents ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// test 3 face normals from the aabb\n\t\taxes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];\n\t\tif ( ! satForAxes( axes, _v0, _v1, _v2, _extents ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// finally testing the face normal of the triangle\n\t\t// use already existing triangle edge vectors here\n\t\t_triangleNormal.crossVectors( _f0, _f1 );\n\t\taxes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];\n\n\t\treturn satForAxes( axes, _v0, _v1, _v2, _extents );\n\n\t}\n\n\tclampPoint( point, target ) {\n\n\t\treturn target.copy( point ).clamp( this.min, this.max );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\tconst clampedPoint = _vector.copy( point ).clamp( this.min, this.max );\n\n\t\treturn clampedPoint.sub( point ).length();\n\n\t}\n\n\tgetBoundingSphere( target ) {\n\n\t\tthis.getCenter( target.center );\n\n\t\ttarget.radius = this.getSize( _vector ).length() * 0.5;\n\n\t\treturn target;\n\n\t}\n\n\tintersect( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\t\tif ( this.isEmpty() ) this.makeEmpty();\n\n\t\treturn this;\n\n\t}\n\n\tunion( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\t// transform of empty box is an empty box.\n\t\tif ( this.isEmpty() ) return this;\n\n\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\t\t_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\n\t\t_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\n\t\t_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\n\t\t_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\n\t\t_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\n\t\t_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\n\t\t_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\n\t\t_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111\n\n\t\tthis.setFromPoints( _points );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t}\n\n\tequals( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t}\n\n}\n\nconst _points = [\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3()\n];\n\nconst _vector = /*@__PURE__*/ new Vector3();\n\nconst _box = /*@__PURE__*/ new Box3();\n\n// triangle centered vertices\n\nconst _v0 = /*@__PURE__*/ new Vector3();\nconst _v1 = /*@__PURE__*/ new Vector3();\nconst _v2 = /*@__PURE__*/ new Vector3();\n\n// triangle edge vectors\n\nconst _f0 = /*@__PURE__*/ new Vector3();\nconst _f1 = /*@__PURE__*/ new Vector3();\nconst _f2 = /*@__PURE__*/ new Vector3();\n\nconst _center = /*@__PURE__*/ new Vector3();\nconst _extents = /*@__PURE__*/ new Vector3();\nconst _triangleNormal = /*@__PURE__*/ new Vector3();\nconst _testAxis = /*@__PURE__*/ new Vector3();\n\nfunction satForAxes( axes, v0, v1, v2, extents ) {\n\n\tfor ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {\n\n\t\t_testAxis.fromArray( axes, i );\n\t\t// project the aabb onto the separating axis\n\t\tconst r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );\n\t\t// project all 3 vertices of the triangle onto the separating axis\n\t\tconst p0 = v0.dot( _testAxis );\n\t\tconst p1 = v1.dot( _testAxis );\n\t\tconst p2 = v2.dot( _testAxis );\n\t\t// actual test, basically see if either of the most extreme of the triangle points intersects r\n\t\tif ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\n\n\t\t\t// points of the projected triangle are outside the projected half-length of the aabb\n\t\t\t// the axis is separating and we can exit\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\treturn true;\n\n}\n\nexport { Box3 };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}