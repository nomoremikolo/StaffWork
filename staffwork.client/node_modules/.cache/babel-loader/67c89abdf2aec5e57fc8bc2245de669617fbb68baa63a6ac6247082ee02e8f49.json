{"ast":null,"code":"import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\nclass PolyhedronGeometry extends BufferGeometry {\n  constructor() {\n    let vertices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let indices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    let detail = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    super();\n    this.type = 'PolyhedronGeometry';\n    this.parameters = {\n      vertices: vertices,\n      indices: indices,\n      radius: radius,\n      detail: detail\n    };\n\n    // default buffer data\n\n    const vertexBuffer = [];\n    const uvBuffer = [];\n\n    // the subdivision creates the vertex buffer data\n\n    subdivide(detail);\n\n    // all vertices should lie on a conceptual sphere with a given radius\n\n    applyRadius(radius);\n\n    // finally, create the uv data\n\n    generateUVs();\n\n    // build non-indexed geometry\n\n    this.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));\n    if (detail === 0) {\n      this.computeVertexNormals(); // flat normals\n    } else {\n      this.normalizeNormals(); // smooth normals\n    }\n\n    // helper functions\n\n    function subdivide(detail) {\n      const a = new Vector3();\n      const b = new Vector3();\n      const c = new Vector3();\n\n      // iterate over all faces and apply a subdivision with the given detail value\n\n      for (let i = 0; i < indices.length; i += 3) {\n        // get the vertices of the face\n\n        getVertexByIndex(indices[i + 0], a);\n        getVertexByIndex(indices[i + 1], b);\n        getVertexByIndex(indices[i + 2], c);\n\n        // perform subdivision\n\n        subdivideFace(a, b, c, detail);\n      }\n    }\n    function subdivideFace(a, b, c, detail) {\n      const cols = detail + 1;\n\n      // we use this multidimensional array as a data structure for creating the subdivision\n\n      const v = [];\n\n      // construct all of the vertices for this subdivision\n\n      for (let i = 0; i <= cols; i++) {\n        v[i] = [];\n        const aj = a.clone().lerp(c, i / cols);\n        const bj = b.clone().lerp(c, i / cols);\n        const rows = cols - i;\n        for (let j = 0; j <= rows; j++) {\n          if (j === 0 && i === cols) {\n            v[i][j] = aj;\n          } else {\n            v[i][j] = aj.clone().lerp(bj, j / rows);\n          }\n        }\n      }\n\n      // construct all of the faces\n\n      for (let i = 0; i < cols; i++) {\n        for (let j = 0; j < 2 * (cols - i) - 1; j++) {\n          const k = Math.floor(j / 2);\n          if (j % 2 === 0) {\n            pushVertex(v[i][k + 1]);\n            pushVertex(v[i + 1][k]);\n            pushVertex(v[i][k]);\n          } else {\n            pushVertex(v[i][k + 1]);\n            pushVertex(v[i + 1][k + 1]);\n            pushVertex(v[i + 1][k]);\n          }\n        }\n      }\n    }\n    function applyRadius(radius) {\n      const vertex = new Vector3();\n\n      // iterate over the entire buffer and apply the radius to each vertex\n\n      for (let i = 0; i < vertexBuffer.length; i += 3) {\n        vertex.x = vertexBuffer[i + 0];\n        vertex.y = vertexBuffer[i + 1];\n        vertex.z = vertexBuffer[i + 2];\n        vertex.normalize().multiplyScalar(radius);\n        vertexBuffer[i + 0] = vertex.x;\n        vertexBuffer[i + 1] = vertex.y;\n        vertexBuffer[i + 2] = vertex.z;\n      }\n    }\n    function generateUVs() {\n      const vertex = new Vector3();\n      for (let i = 0; i < vertexBuffer.length; i += 3) {\n        vertex.x = vertexBuffer[i + 0];\n        vertex.y = vertexBuffer[i + 1];\n        vertex.z = vertexBuffer[i + 2];\n        const u = azimuth(vertex) / 2 / Math.PI + 0.5;\n        const v = inclination(vertex) / Math.PI + 0.5;\n        uvBuffer.push(u, 1 - v);\n      }\n      correctUVs();\n      correctSeam();\n    }\n    function correctSeam() {\n      // handle case when face straddles the seam, see #3269\n\n      for (let i = 0; i < uvBuffer.length; i += 6) {\n        // uv data of a single face\n\n        const x0 = uvBuffer[i + 0];\n        const x1 = uvBuffer[i + 2];\n        const x2 = uvBuffer[i + 4];\n        const max = Math.max(x0, x1, x2);\n        const min = Math.min(x0, x1, x2);\n\n        // 0.9 is somewhat arbitrary\n\n        if (max > 0.9 && min < 0.1) {\n          if (x0 < 0.2) uvBuffer[i + 0] += 1;\n          if (x1 < 0.2) uvBuffer[i + 2] += 1;\n          if (x2 < 0.2) uvBuffer[i + 4] += 1;\n        }\n      }\n    }\n    function pushVertex(vertex) {\n      vertexBuffer.push(vertex.x, vertex.y, vertex.z);\n    }\n    function getVertexByIndex(index, vertex) {\n      const stride = index * 3;\n      vertex.x = vertices[stride + 0];\n      vertex.y = vertices[stride + 1];\n      vertex.z = vertices[stride + 2];\n    }\n    function correctUVs() {\n      const a = new Vector3();\n      const b = new Vector3();\n      const c = new Vector3();\n      const centroid = new Vector3();\n      const uvA = new Vector2();\n      const uvB = new Vector2();\n      const uvC = new Vector2();\n      for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {\n        a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);\n        b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);\n        c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);\n        uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);\n        uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);\n        uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);\n        centroid.copy(a).add(b).add(c).divideScalar(3);\n        const azi = azimuth(centroid);\n        correctUV(uvA, j + 0, a, azi);\n        correctUV(uvB, j + 2, b, azi);\n        correctUV(uvC, j + 4, c, azi);\n      }\n    }\n    function correctUV(uv, stride, vector, azimuth) {\n      if (azimuth < 0 && uv.x === 1) {\n        uvBuffer[stride] = uv.x - 1;\n      }\n      if (vector.x === 0 && vector.z === 0) {\n        uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;\n      }\n    }\n\n    // Angle around the Y axis, counter-clockwise when looking from above.\n\n    function azimuth(vector) {\n      return Math.atan2(vector.z, -vector.x);\n    }\n\n    // Angle above the XZ plane.\n\n    function inclination(vector) {\n      return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));\n    }\n  }\n  static fromJSON(data) {\n    return new PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);\n  }\n}\nexport { PolyhedronGeometry };","map":{"version":3,"names":["BufferGeometry","Float32BufferAttribute","Vector3","Vector2","PolyhedronGeometry","constructor","vertices","indices","radius","detail","type","parameters","vertexBuffer","uvBuffer","subdivide","applyRadius","generateUVs","setAttribute","slice","computeVertexNormals","normalizeNormals","a","b","c","i","length","getVertexByIndex","subdivideFace","cols","v","aj","clone","lerp","bj","rows","j","k","Math","floor","pushVertex","vertex","x","y","z","normalize","multiplyScalar","u","azimuth","PI","inclination","push","correctUVs","correctSeam","x0","x1","x2","max","min","index","stride","centroid","uvA","uvB","uvC","set","copy","add","divideScalar","azi","correctUV","uv","vector","atan2","sqrt","fromJSON","data","details"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/geometries/PolyhedronGeometry.js"],"sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\n\nclass PolyhedronGeometry extends BufferGeometry {\n\n\tconstructor( vertices = [], indices = [], radius = 1, detail = 0 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'PolyhedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tvertices: vertices,\n\t\t\tindices: indices,\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\t// default buffer data\n\n\t\tconst vertexBuffer = [];\n\t\tconst uvBuffer = [];\n\n\t\t// the subdivision creates the vertex buffer data\n\n\t\tsubdivide( detail );\n\n\t\t// all vertices should lie on a conceptual sphere with a given radius\n\n\t\tapplyRadius( radius );\n\n\t\t// finally, create the uv data\n\n\t\tgenerateUVs();\n\n\t\t// build non-indexed geometry\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );\n\n\t\tif ( detail === 0 ) {\n\n\t\t\tthis.computeVertexNormals(); // flat normals\n\n\t\t} else {\n\n\t\t\tthis.normalizeNormals(); // smooth normals\n\n\t\t}\n\n\t\t// helper functions\n\n\t\tfunction subdivide( detail ) {\n\n\t\t\tconst a = new Vector3();\n\t\t\tconst b = new Vector3();\n\t\t\tconst c = new Vector3();\n\n\t\t\t// iterate over all faces and apply a subdivision with the given detail value\n\n\t\t\tfor ( let i = 0; i < indices.length; i += 3 ) {\n\n\t\t\t\t// get the vertices of the face\n\n\t\t\t\tgetVertexByIndex( indices[ i + 0 ], a );\n\t\t\t\tgetVertexByIndex( indices[ i + 1 ], b );\n\t\t\t\tgetVertexByIndex( indices[ i + 2 ], c );\n\n\t\t\t\t// perform subdivision\n\n\t\t\t\tsubdivideFace( a, b, c, detail );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction subdivideFace( a, b, c, detail ) {\n\n\t\t\tconst cols = detail + 1;\n\n\t\t\t// we use this multidimensional array as a data structure for creating the subdivision\n\n\t\t\tconst v = [];\n\n\t\t\t// construct all of the vertices for this subdivision\n\n\t\t\tfor ( let i = 0; i <= cols; i ++ ) {\n\n\t\t\t\tv[ i ] = [];\n\n\t\t\t\tconst aj = a.clone().lerp( c, i / cols );\n\t\t\t\tconst bj = b.clone().lerp( c, i / cols );\n\n\t\t\t\tconst rows = cols - i;\n\n\t\t\t\tfor ( let j = 0; j <= rows; j ++ ) {\n\n\t\t\t\t\tif ( j === 0 && i === cols ) {\n\n\t\t\t\t\t\tv[ i ][ j ] = aj;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv[ i ][ j ] = aj.clone().lerp( bj, j / rows );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// construct all of the faces\n\n\t\t\tfor ( let i = 0; i < cols; i ++ ) {\n\n\t\t\t\tfor ( let j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\n\n\t\t\t\t\tconst k = Math.floor( j / 2 );\n\n\t\t\t\t\tif ( j % 2 === 0 ) {\n\n\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\t\t\t\t\t\tpushVertex( v[ i ][ k ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction applyRadius( radius ) {\n\n\t\t\tconst vertex = new Vector3();\n\n\t\t\t// iterate over the entire buffer and apply the radius to each vertex\n\n\t\t\tfor ( let i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\t\tvertex.normalize().multiplyScalar( radius );\n\n\t\t\t\tvertexBuffer[ i + 0 ] = vertex.x;\n\t\t\t\tvertexBuffer[ i + 1 ] = vertex.y;\n\t\t\t\tvertexBuffer[ i + 2 ] = vertex.z;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateUVs() {\n\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tfor ( let i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\t\tconst u = azimuth( vertex ) / 2 / Math.PI + 0.5;\n\t\t\t\tconst v = inclination( vertex ) / Math.PI + 0.5;\n\t\t\t\tuvBuffer.push( u, 1 - v );\n\n\t\t\t}\n\n\t\t\tcorrectUVs();\n\n\t\t\tcorrectSeam();\n\n\t\t}\n\n\t\tfunction correctSeam() {\n\n\t\t\t// handle case when face straddles the seam, see #3269\n\n\t\t\tfor ( let i = 0; i < uvBuffer.length; i += 6 ) {\n\n\t\t\t\t// uv data of a single face\n\n\t\t\t\tconst x0 = uvBuffer[ i + 0 ];\n\t\t\t\tconst x1 = uvBuffer[ i + 2 ];\n\t\t\t\tconst x2 = uvBuffer[ i + 4 ];\n\n\t\t\t\tconst max = Math.max( x0, x1, x2 );\n\t\t\t\tconst min = Math.min( x0, x1, x2 );\n\n\t\t\t\t// 0.9 is somewhat arbitrary\n\n\t\t\t\tif ( max > 0.9 && min < 0.1 ) {\n\n\t\t\t\t\tif ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;\n\t\t\t\t\tif ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;\n\t\t\t\t\tif ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction pushVertex( vertex ) {\n\n\t\t\tvertexBuffer.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t\tfunction getVertexByIndex( index, vertex ) {\n\n\t\t\tconst stride = index * 3;\n\n\t\t\tvertex.x = vertices[ stride + 0 ];\n\t\t\tvertex.y = vertices[ stride + 1 ];\n\t\t\tvertex.z = vertices[ stride + 2 ];\n\n\t\t}\n\n\t\tfunction correctUVs() {\n\n\t\t\tconst a = new Vector3();\n\t\t\tconst b = new Vector3();\n\t\t\tconst c = new Vector3();\n\n\t\t\tconst centroid = new Vector3();\n\n\t\t\tconst uvA = new Vector2();\n\t\t\tconst uvB = new Vector2();\n\t\t\tconst uvC = new Vector2();\n\n\t\t\tfor ( let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {\n\n\t\t\t\ta.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );\n\t\t\t\tb.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );\n\t\t\t\tc.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );\n\n\t\t\t\tuvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );\n\t\t\t\tuvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );\n\t\t\t\tuvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );\n\n\t\t\t\tcentroid.copy( a ).add( b ).add( c ).divideScalar( 3 );\n\n\t\t\t\tconst azi = azimuth( centroid );\n\n\t\t\t\tcorrectUV( uvA, j + 0, a, azi );\n\t\t\t\tcorrectUV( uvB, j + 2, b, azi );\n\t\t\t\tcorrectUV( uvC, j + 4, c, azi );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction correctUV( uv, stride, vector, azimuth ) {\n\n\t\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {\n\n\t\t\t\tuvBuffer[ stride ] = uv.x - 1;\n\n\t\t\t}\n\n\t\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {\n\n\t\t\t\tuvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Angle around the Y axis, counter-clockwise when looking from above.\n\n\t\tfunction azimuth( vector ) {\n\n\t\t\treturn Math.atan2( vector.z, - vector.x );\n\n\t\t}\n\n\n\t\t// Angle above the XZ plane.\n\n\t\tfunction inclination( vector ) {\n\n\t\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\n\n\t\t}\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new PolyhedronGeometry( data.vertices, data.indices, data.radius, data.details );\n\n\t}\n\n}\n\nexport { PolyhedronGeometry };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}