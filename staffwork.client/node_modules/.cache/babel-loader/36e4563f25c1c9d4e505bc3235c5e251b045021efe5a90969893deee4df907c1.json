{"ast":null,"code":"import { InstancedBufferAttribute } from '../core/InstancedBufferAttribute.js';\nimport { Mesh } from './Mesh.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nconst _instanceLocalMatrix = /*@__PURE__*/new Matrix4();\nconst _instanceWorldMatrix = /*@__PURE__*/new Matrix4();\nconst _instanceIntersects = [];\nconst _identity = /*@__PURE__*/new Matrix4();\nconst _mesh = /*@__PURE__*/new Mesh();\nclass InstancedMesh extends Mesh {\n  constructor(geometry, material, count) {\n    super(geometry, material);\n    this.isInstancedMesh = true;\n    this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);\n    this.instanceColor = null;\n    this.count = count;\n    this.frustumCulled = false;\n    for (let i = 0; i < count; i++) {\n      this.setMatrixAt(i, _identity);\n    }\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.instanceMatrix.copy(source.instanceMatrix);\n    if (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();\n    this.count = source.count;\n    return this;\n  }\n  getColorAt(index, color) {\n    color.fromArray(this.instanceColor.array, index * 3);\n  }\n  getMatrixAt(index, matrix) {\n    matrix.fromArray(this.instanceMatrix.array, index * 16);\n  }\n  raycast(raycaster, intersects) {\n    const matrixWorld = this.matrixWorld;\n    const raycastTimes = this.count;\n    _mesh.geometry = this.geometry;\n    _mesh.material = this.material;\n    if (_mesh.material === undefined) return;\n    for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {\n      // calculate the world matrix for each instance\n\n      this.getMatrixAt(instanceId, _instanceLocalMatrix);\n      _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);\n\n      // the mesh represents this single instance\n\n      _mesh.matrixWorld = _instanceWorldMatrix;\n      _mesh.raycast(raycaster, _instanceIntersects);\n\n      // process the result of raycast\n\n      for (let i = 0, l = _instanceIntersects.length; i < l; i++) {\n        const intersect = _instanceIntersects[i];\n        intersect.instanceId = instanceId;\n        intersect.object = this;\n        intersects.push(intersect);\n      }\n      _instanceIntersects.length = 0;\n    }\n  }\n  setColorAt(index, color) {\n    if (this.instanceColor === null) {\n      this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3);\n    }\n    color.toArray(this.instanceColor.array, index * 3);\n  }\n  setMatrixAt(index, matrix) {\n    matrix.toArray(this.instanceMatrix.array, index * 16);\n  }\n  updateMorphTargets() {}\n  dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n}\nexport { InstancedMesh };","map":{"version":3,"names":["InstancedBufferAttribute","Mesh","Matrix4","_instanceLocalMatrix","_instanceWorldMatrix","_instanceIntersects","_identity","_mesh","InstancedMesh","constructor","geometry","material","count","isInstancedMesh","instanceMatrix","Float32Array","instanceColor","frustumCulled","i","setMatrixAt","copy","source","recursive","clone","getColorAt","index","color","fromArray","array","getMatrixAt","matrix","raycast","raycaster","intersects","matrixWorld","raycastTimes","undefined","instanceId","multiplyMatrices","l","length","intersect","object","push","setColorAt","toArray","updateMorphTargets","dispose","dispatchEvent","type"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/objects/InstancedMesh.js"],"sourcesContent":["import { InstancedBufferAttribute } from '../core/InstancedBufferAttribute.js';\nimport { Mesh } from './Mesh.js';\nimport { Matrix4 } from '../math/Matrix4.js';\n\nconst _instanceLocalMatrix = /*@__PURE__*/ new Matrix4();\nconst _instanceWorldMatrix = /*@__PURE__*/ new Matrix4();\n\nconst _instanceIntersects = [];\n\nconst _identity = /*@__PURE__*/ new Matrix4();\nconst _mesh = /*@__PURE__*/ new Mesh();\n\nclass InstancedMesh extends Mesh {\n\n\tconstructor( geometry, material, count ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isInstancedMesh = true;\n\n\t\tthis.instanceMatrix = new InstancedBufferAttribute( new Float32Array( count * 16 ), 16 );\n\t\tthis.instanceColor = null;\n\n\t\tthis.count = count;\n\n\t\tthis.frustumCulled = false;\n\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tthis.setMatrixAt( i, _identity );\n\n\t\t}\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.instanceMatrix.copy( source.instanceMatrix );\n\n\t\tif ( source.instanceColor !== null ) this.instanceColor = source.instanceColor.clone();\n\n\t\tthis.count = source.count;\n\n\t\treturn this;\n\n\t}\n\n\tgetColorAt( index, color ) {\n\n\t\tcolor.fromArray( this.instanceColor.array, index * 3 );\n\n\t}\n\n\tgetMatrixAt( index, matrix ) {\n\n\t\tmatrix.fromArray( this.instanceMatrix.array, index * 16 );\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst raycastTimes = this.count;\n\n\t\t_mesh.geometry = this.geometry;\n\t\t_mesh.material = this.material;\n\n\t\tif ( _mesh.material === undefined ) return;\n\n\t\tfor ( let instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {\n\n\t\t\t// calculate the world matrix for each instance\n\n\t\t\tthis.getMatrixAt( instanceId, _instanceLocalMatrix );\n\n\t\t\t_instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );\n\n\t\t\t// the mesh represents this single instance\n\n\t\t\t_mesh.matrixWorld = _instanceWorldMatrix;\n\n\t\t\t_mesh.raycast( raycaster, _instanceIntersects );\n\n\t\t\t// process the result of raycast\n\n\t\t\tfor ( let i = 0, l = _instanceIntersects.length; i < l; i ++ ) {\n\n\t\t\t\tconst intersect = _instanceIntersects[ i ];\n\t\t\t\tintersect.instanceId = instanceId;\n\t\t\t\tintersect.object = this;\n\t\t\t\tintersects.push( intersect );\n\n\t\t\t}\n\n\t\t\t_instanceIntersects.length = 0;\n\n\t\t}\n\n\t}\n\n\tsetColorAt( index, color ) {\n\n\t\tif ( this.instanceColor === null ) {\n\n\t\t\tthis.instanceColor = new InstancedBufferAttribute( new Float32Array( this.instanceMatrix.count * 3 ), 3 );\n\n\t\t}\n\n\t\tcolor.toArray( this.instanceColor.array, index * 3 );\n\n\t}\n\n\tsetMatrixAt( index, matrix ) {\n\n\t\tmatrix.toArray( this.instanceMatrix.array, index * 16 );\n\n\t}\n\n\tupdateMorphTargets() {\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n}\n\nexport { InstancedMesh };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}