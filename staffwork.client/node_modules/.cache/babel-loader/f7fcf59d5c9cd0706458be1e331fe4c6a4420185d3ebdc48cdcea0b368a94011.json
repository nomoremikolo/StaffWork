{"ast":null,"code":"import { Color } from '../../math/Color.js';\nimport { Matrix4 } from '../../math/Matrix4.js';\nimport { Vector2 } from '../../math/Vector2.js';\nimport { Vector3 } from '../../math/Vector3.js';\nimport { UniformsLib } from '../shaders/UniformsLib.js';\nfunction UniformsCache() {\n  const lights = {};\n  return {\n    get: function (light) {\n      if (lights[light.id] !== undefined) {\n        return lights[light.id];\n      }\n      let uniforms;\n      switch (light.type) {\n        case 'DirectionalLight':\n          uniforms = {\n            direction: new Vector3(),\n            color: new Color()\n          };\n          break;\n        case 'SpotLight':\n          uniforms = {\n            position: new Vector3(),\n            direction: new Vector3(),\n            color: new Color(),\n            distance: 0,\n            coneCos: 0,\n            penumbraCos: 0,\n            decay: 0\n          };\n          break;\n        case 'PointLight':\n          uniforms = {\n            position: new Vector3(),\n            color: new Color(),\n            distance: 0,\n            decay: 0\n          };\n          break;\n        case 'HemisphereLight':\n          uniforms = {\n            direction: new Vector3(),\n            skyColor: new Color(),\n            groundColor: new Color()\n          };\n          break;\n        case 'RectAreaLight':\n          uniforms = {\n            color: new Color(),\n            position: new Vector3(),\n            halfWidth: new Vector3(),\n            halfHeight: new Vector3()\n          };\n          break;\n      }\n      lights[light.id] = uniforms;\n      return uniforms;\n    }\n  };\n}\nfunction ShadowUniformsCache() {\n  const lights = {};\n  return {\n    get: function (light) {\n      if (lights[light.id] !== undefined) {\n        return lights[light.id];\n      }\n      let uniforms;\n      switch (light.type) {\n        case 'DirectionalLight':\n          uniforms = {\n            shadowBias: 0,\n            shadowNormalBias: 0,\n            shadowRadius: 1,\n            shadowMapSize: new Vector2()\n          };\n          break;\n        case 'SpotLight':\n          uniforms = {\n            shadowBias: 0,\n            shadowNormalBias: 0,\n            shadowRadius: 1,\n            shadowMapSize: new Vector2()\n          };\n          break;\n        case 'PointLight':\n          uniforms = {\n            shadowBias: 0,\n            shadowNormalBias: 0,\n            shadowRadius: 1,\n            shadowMapSize: new Vector2(),\n            shadowCameraNear: 1,\n            shadowCameraFar: 1000\n          };\n          break;\n\n        // TODO (abelnation): set RectAreaLight shadow uniforms\n      }\n\n      lights[light.id] = uniforms;\n      return uniforms;\n    }\n  };\n}\nlet nextVersion = 0;\nfunction shadowCastingAndTexturingLightsFirst(lightA, lightB) {\n  return (lightB.castShadow ? 2 : 0) - (lightA.castShadow ? 2 : 0) + (lightB.map ? 1 : 0) - (lightA.map ? 1 : 0);\n}\nfunction WebGLLights(extensions, capabilities) {\n  const cache = new UniformsCache();\n  const shadowCache = ShadowUniformsCache();\n  const state = {\n    version: 0,\n    hash: {\n      directionalLength: -1,\n      pointLength: -1,\n      spotLength: -1,\n      rectAreaLength: -1,\n      hemiLength: -1,\n      numDirectionalShadows: -1,\n      numPointShadows: -1,\n      numSpotShadows: -1,\n      numSpotMaps: -1\n    },\n    ambient: [0, 0, 0],\n    probe: [],\n    directional: [],\n    directionalShadow: [],\n    directionalShadowMap: [],\n    directionalShadowMatrix: [],\n    spot: [],\n    spotLightMap: [],\n    spotShadow: [],\n    spotShadowMap: [],\n    spotLightMatrix: [],\n    rectArea: [],\n    rectAreaLTC1: null,\n    rectAreaLTC2: null,\n    point: [],\n    pointShadow: [],\n    pointShadowMap: [],\n    pointShadowMatrix: [],\n    hemi: [],\n    numSpotLightShadowsWithMaps: 0\n  };\n  for (let i = 0; i < 9; i++) state.probe.push(new Vector3());\n  const vector3 = new Vector3();\n  const matrix4 = new Matrix4();\n  const matrix42 = new Matrix4();\n  function setup(lights, physicallyCorrectLights) {\n    let r = 0,\n      g = 0,\n      b = 0;\n    for (let i = 0; i < 9; i++) state.probe[i].set(0, 0, 0);\n    let directionalLength = 0;\n    let pointLength = 0;\n    let spotLength = 0;\n    let rectAreaLength = 0;\n    let hemiLength = 0;\n    let numDirectionalShadows = 0;\n    let numPointShadows = 0;\n    let numSpotShadows = 0;\n    let numSpotMaps = 0;\n    let numSpotShadowsWithMaps = 0;\n\n    // ordering : [shadow casting + map texturing, map texturing, shadow casting, none ]\n    lights.sort(shadowCastingAndTexturingLightsFirst);\n\n    // artist-friendly light intensity scaling factor\n    const scaleFactor = physicallyCorrectLights !== true ? Math.PI : 1;\n    for (let i = 0, l = lights.length; i < l; i++) {\n      const light = lights[i];\n      const color = light.color;\n      const intensity = light.intensity;\n      const distance = light.distance;\n      const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;\n      if (light.isAmbientLight) {\n        r += color.r * intensity * scaleFactor;\n        g += color.g * intensity * scaleFactor;\n        b += color.b * intensity * scaleFactor;\n      } else if (light.isLightProbe) {\n        for (let j = 0; j < 9; j++) {\n          state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);\n        }\n      } else if (light.isDirectionalLight) {\n        const uniforms = cache.get(light);\n        uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);\n        if (light.castShadow) {\n          const shadow = light.shadow;\n          const shadowUniforms = shadowCache.get(light);\n          shadowUniforms.shadowBias = shadow.bias;\n          shadowUniforms.shadowNormalBias = shadow.normalBias;\n          shadowUniforms.shadowRadius = shadow.radius;\n          shadowUniforms.shadowMapSize = shadow.mapSize;\n          state.directionalShadow[directionalLength] = shadowUniforms;\n          state.directionalShadowMap[directionalLength] = shadowMap;\n          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;\n          numDirectionalShadows++;\n        }\n        state.directional[directionalLength] = uniforms;\n        directionalLength++;\n      } else if (light.isSpotLight) {\n        const uniforms = cache.get(light);\n        uniforms.position.setFromMatrixPosition(light.matrixWorld);\n        uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor);\n        uniforms.distance = distance;\n        uniforms.coneCos = Math.cos(light.angle);\n        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));\n        uniforms.decay = light.decay;\n        state.spot[spotLength] = uniforms;\n        const shadow = light.shadow;\n        if (light.map) {\n          state.spotLightMap[numSpotMaps] = light.map;\n          numSpotMaps++;\n\n          // make sure the lightMatrix is up to date\n          // TODO : do it if required only\n          shadow.updateMatrices(light);\n          if (light.castShadow) numSpotShadowsWithMaps++;\n        }\n        state.spotLightMatrix[spotLength] = shadow.matrix;\n        if (light.castShadow) {\n          const shadowUniforms = shadowCache.get(light);\n          shadowUniforms.shadowBias = shadow.bias;\n          shadowUniforms.shadowNormalBias = shadow.normalBias;\n          shadowUniforms.shadowRadius = shadow.radius;\n          shadowUniforms.shadowMapSize = shadow.mapSize;\n          state.spotShadow[spotLength] = shadowUniforms;\n          state.spotShadowMap[spotLength] = shadowMap;\n          numSpotShadows++;\n        }\n        spotLength++;\n      } else if (light.isRectAreaLight) {\n        const uniforms = cache.get(light);\n        uniforms.color.copy(color).multiplyScalar(intensity);\n        uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);\n        uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);\n        state.rectArea[rectAreaLength] = uniforms;\n        rectAreaLength++;\n      } else if (light.isPointLight) {\n        const uniforms = cache.get(light);\n        uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);\n        uniforms.distance = light.distance;\n        uniforms.decay = light.decay;\n        if (light.castShadow) {\n          const shadow = light.shadow;\n          const shadowUniforms = shadowCache.get(light);\n          shadowUniforms.shadowBias = shadow.bias;\n          shadowUniforms.shadowNormalBias = shadow.normalBias;\n          shadowUniforms.shadowRadius = shadow.radius;\n          shadowUniforms.shadowMapSize = shadow.mapSize;\n          shadowUniforms.shadowCameraNear = shadow.camera.near;\n          shadowUniforms.shadowCameraFar = shadow.camera.far;\n          state.pointShadow[pointLength] = shadowUniforms;\n          state.pointShadowMap[pointLength] = shadowMap;\n          state.pointShadowMatrix[pointLength] = light.shadow.matrix;\n          numPointShadows++;\n        }\n        state.point[pointLength] = uniforms;\n        pointLength++;\n      } else if (light.isHemisphereLight) {\n        const uniforms = cache.get(light);\n        uniforms.skyColor.copy(light.color).multiplyScalar(intensity * scaleFactor);\n        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity * scaleFactor);\n        state.hemi[hemiLength] = uniforms;\n        hemiLength++;\n      }\n    }\n    if (rectAreaLength > 0) {\n      if (capabilities.isWebGL2) {\n        // WebGL 2\n\n        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;\n        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;\n      } else {\n        // WebGL 1\n\n        if (extensions.has('OES_texture_float_linear') === true) {\n          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;\n          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;\n        } else if (extensions.has('OES_texture_half_float_linear') === true) {\n          state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;\n          state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;\n        } else {\n          console.error('THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.');\n        }\n      }\n    }\n    state.ambient[0] = r;\n    state.ambient[1] = g;\n    state.ambient[2] = b;\n    const hash = state.hash;\n    if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows || hash.numSpotMaps !== numSpotMaps) {\n      state.directional.length = directionalLength;\n      state.spot.length = spotLength;\n      state.rectArea.length = rectAreaLength;\n      state.point.length = pointLength;\n      state.hemi.length = hemiLength;\n      state.directionalShadow.length = numDirectionalShadows;\n      state.directionalShadowMap.length = numDirectionalShadows;\n      state.pointShadow.length = numPointShadows;\n      state.pointShadowMap.length = numPointShadows;\n      state.spotShadow.length = numSpotShadows;\n      state.spotShadowMap.length = numSpotShadows;\n      state.directionalShadowMatrix.length = numDirectionalShadows;\n      state.pointShadowMatrix.length = numPointShadows;\n      state.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;\n      state.spotLightMap.length = numSpotMaps;\n      state.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;\n      hash.directionalLength = directionalLength;\n      hash.pointLength = pointLength;\n      hash.spotLength = spotLength;\n      hash.rectAreaLength = rectAreaLength;\n      hash.hemiLength = hemiLength;\n      hash.numDirectionalShadows = numDirectionalShadows;\n      hash.numPointShadows = numPointShadows;\n      hash.numSpotShadows = numSpotShadows;\n      hash.numSpotMaps = numSpotMaps;\n      state.version = nextVersion++;\n    }\n  }\n  function setupView(lights, camera) {\n    let directionalLength = 0;\n    let pointLength = 0;\n    let spotLength = 0;\n    let rectAreaLength = 0;\n    let hemiLength = 0;\n    const viewMatrix = camera.matrixWorldInverse;\n    for (let i = 0, l = lights.length; i < l; i++) {\n      const light = lights[i];\n      if (light.isDirectionalLight) {\n        const uniforms = state.directional[directionalLength];\n        uniforms.direction.setFromMatrixPosition(light.matrixWorld);\n        vector3.setFromMatrixPosition(light.target.matrixWorld);\n        uniforms.direction.sub(vector3);\n        uniforms.direction.transformDirection(viewMatrix);\n        directionalLength++;\n      } else if (light.isSpotLight) {\n        const uniforms = state.spot[spotLength];\n        uniforms.position.setFromMatrixPosition(light.matrixWorld);\n        uniforms.position.applyMatrix4(viewMatrix);\n        uniforms.direction.setFromMatrixPosition(light.matrixWorld);\n        vector3.setFromMatrixPosition(light.target.matrixWorld);\n        uniforms.direction.sub(vector3);\n        uniforms.direction.transformDirection(viewMatrix);\n        spotLength++;\n      } else if (light.isRectAreaLight) {\n        const uniforms = state.rectArea[rectAreaLength];\n        uniforms.position.setFromMatrixPosition(light.matrixWorld);\n        uniforms.position.applyMatrix4(viewMatrix);\n\n        // extract local rotation of light to derive width/height half vectors\n        matrix42.identity();\n        matrix4.copy(light.matrixWorld);\n        matrix4.premultiply(viewMatrix);\n        matrix42.extractRotation(matrix4);\n        uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);\n        uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);\n        uniforms.halfWidth.applyMatrix4(matrix42);\n        uniforms.halfHeight.applyMatrix4(matrix42);\n        rectAreaLength++;\n      } else if (light.isPointLight) {\n        const uniforms = state.point[pointLength];\n        uniforms.position.setFromMatrixPosition(light.matrixWorld);\n        uniforms.position.applyMatrix4(viewMatrix);\n        pointLength++;\n      } else if (light.isHemisphereLight) {\n        const uniforms = state.hemi[hemiLength];\n        uniforms.direction.setFromMatrixPosition(light.matrixWorld);\n        uniforms.direction.transformDirection(viewMatrix);\n        hemiLength++;\n      }\n    }\n  }\n  return {\n    setup: setup,\n    setupView: setupView,\n    state: state\n  };\n}\nexport { WebGLLights };","map":{"version":3,"names":["Color","Matrix4","Vector2","Vector3","UniformsLib","UniformsCache","lights","get","light","id","undefined","uniforms","type","direction","color","position","distance","coneCos","penumbraCos","decay","skyColor","groundColor","halfWidth","halfHeight","ShadowUniformsCache","shadowBias","shadowNormalBias","shadowRadius","shadowMapSize","shadowCameraNear","shadowCameraFar","nextVersion","shadowCastingAndTexturingLightsFirst","lightA","lightB","castShadow","map","WebGLLights","extensions","capabilities","cache","shadowCache","state","version","hash","directionalLength","pointLength","spotLength","rectAreaLength","hemiLength","numDirectionalShadows","numPointShadows","numSpotShadows","numSpotMaps","ambient","probe","directional","directionalShadow","directionalShadowMap","directionalShadowMatrix","spot","spotLightMap","spotShadow","spotShadowMap","spotLightMatrix","rectArea","rectAreaLTC1","rectAreaLTC2","point","pointShadow","pointShadowMap","pointShadowMatrix","hemi","numSpotLightShadowsWithMaps","i","push","vector3","matrix4","matrix42","setup","physicallyCorrectLights","r","g","b","set","numSpotShadowsWithMaps","sort","scaleFactor","Math","PI","l","length","intensity","shadowMap","shadow","texture","isAmbientLight","isLightProbe","j","addScaledVector","sh","coefficients","isDirectionalLight","copy","multiplyScalar","shadowUniforms","bias","normalBias","radius","mapSize","matrix","isSpotLight","setFromMatrixPosition","matrixWorld","cos","angle","penumbra","updateMatrices","isRectAreaLight","width","height","isPointLight","camera","near","far","isHemisphereLight","isWebGL2","LTC_FLOAT_1","LTC_FLOAT_2","has","LTC_HALF_1","LTC_HALF_2","console","error","setupView","viewMatrix","matrixWorldInverse","target","sub","transformDirection","applyMatrix4","identity","premultiply","extractRotation"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/renderers/webgl/WebGLLights.js"],"sourcesContent":["import { Color } from '../../math/Color.js';\nimport { Matrix4 } from '../../math/Matrix4.js';\nimport { Vector2 } from '../../math/Vector2.js';\nimport { Vector3 } from '../../math/Vector3.js';\nimport { UniformsLib } from '../shaders/UniformsLib.js';\n\nfunction UniformsCache() {\n\n\tconst lights = {};\n\n\treturn {\n\n\t\tget: function ( light ) {\n\n\t\t\tif ( lights[ light.id ] !== undefined ) {\n\n\t\t\t\treturn lights[ light.id ];\n\n\t\t\t}\n\n\t\t\tlet uniforms;\n\n\t\t\tswitch ( light.type ) {\n\n\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\tcolor: new Color()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SpotLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\tconeCos: 0,\n\t\t\t\t\t\tpenumbraCos: 0,\n\t\t\t\t\t\tdecay: 0\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\tdecay: 0\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'HemisphereLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\tskyColor: new Color(),\n\t\t\t\t\t\tgroundColor: new Color()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'RectAreaLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\thalfWidth: new Vector3(),\n\t\t\t\t\t\thalfHeight: new Vector3()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tlights[ light.id ] = uniforms;\n\n\t\t\treturn uniforms;\n\n\t\t}\n\n\t};\n\n}\n\nfunction ShadowUniformsCache() {\n\n\tconst lights = {};\n\n\treturn {\n\n\t\tget: function ( light ) {\n\n\t\t\tif ( lights[ light.id ] !== undefined ) {\n\n\t\t\t\treturn lights[ light.id ];\n\n\t\t\t}\n\n\t\t\tlet uniforms;\n\n\t\t\tswitch ( light.type ) {\n\n\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\tshadowNormalBias: 0,\n\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SpotLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\tshadowNormalBias: 0,\n\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\tshadowNormalBias: 0,\n\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\tshadowMapSize: new Vector2(),\n\t\t\t\t\t\tshadowCameraNear: 1,\n\t\t\t\t\t\tshadowCameraFar: 1000\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\t// TODO (abelnation): set RectAreaLight shadow uniforms\n\n\t\t\t}\n\n\t\t\tlights[ light.id ] = uniforms;\n\n\t\t\treturn uniforms;\n\n\t\t}\n\n\t};\n\n}\n\n\n\nlet nextVersion = 0;\n\nfunction shadowCastingAndTexturingLightsFirst( lightA, lightB ) {\n\n\treturn ( lightB.castShadow ? 2 : 0 ) - ( lightA.castShadow ? 2 : 0 ) + ( lightB.map ? 1 : 0 ) - ( lightA.map ? 1 : 0 );\n\n}\n\nfunction WebGLLights( extensions, capabilities ) {\n\n\tconst cache = new UniformsCache();\n\n\tconst shadowCache = ShadowUniformsCache();\n\n\tconst state = {\n\n\t\tversion: 0,\n\n\t\thash: {\n\t\t\tdirectionalLength: - 1,\n\t\t\tpointLength: - 1,\n\t\t\tspotLength: - 1,\n\t\t\trectAreaLength: - 1,\n\t\t\themiLength: - 1,\n\n\t\t\tnumDirectionalShadows: - 1,\n\t\t\tnumPointShadows: - 1,\n\t\t\tnumSpotShadows: - 1,\n\t\t\tnumSpotMaps: - 1\n\t\t},\n\n\t\tambient: [ 0, 0, 0 ],\n\t\tprobe: [],\n\t\tdirectional: [],\n\t\tdirectionalShadow: [],\n\t\tdirectionalShadowMap: [],\n\t\tdirectionalShadowMatrix: [],\n\t\tspot: [],\n\t\tspotLightMap: [],\n\t\tspotShadow: [],\n\t\tspotShadowMap: [],\n\t\tspotLightMatrix: [],\n\t\trectArea: [],\n\t\trectAreaLTC1: null,\n\t\trectAreaLTC2: null,\n\t\tpoint: [],\n\t\tpointShadow: [],\n\t\tpointShadowMap: [],\n\t\tpointShadowMatrix: [],\n\t\themi: [],\n\t\tnumSpotLightShadowsWithMaps: 0\n\n\t};\n\n\tfor ( let i = 0; i < 9; i ++ ) state.probe.push( new Vector3() );\n\n\tconst vector3 = new Vector3();\n\tconst matrix4 = new Matrix4();\n\tconst matrix42 = new Matrix4();\n\n\tfunction setup( lights, physicallyCorrectLights ) {\n\n\t\tlet r = 0, g = 0, b = 0;\n\n\t\tfor ( let i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );\n\n\t\tlet directionalLength = 0;\n\t\tlet pointLength = 0;\n\t\tlet spotLength = 0;\n\t\tlet rectAreaLength = 0;\n\t\tlet hemiLength = 0;\n\n\t\tlet numDirectionalShadows = 0;\n\t\tlet numPointShadows = 0;\n\t\tlet numSpotShadows = 0;\n\t\tlet numSpotMaps = 0;\n\t\tlet numSpotShadowsWithMaps = 0;\n\n\t\t// ordering : [shadow casting + map texturing, map texturing, shadow casting, none ]\n\t\tlights.sort( shadowCastingAndTexturingLightsFirst );\n\n\t\t// artist-friendly light intensity scaling factor\n\t\tconst scaleFactor = ( physicallyCorrectLights !== true ) ? Math.PI : 1;\n\n\t\tfor ( let i = 0, l = lights.length; i < l; i ++ ) {\n\n\t\t\tconst light = lights[ i ];\n\n\t\t\tconst color = light.color;\n\t\t\tconst intensity = light.intensity;\n\t\t\tconst distance = light.distance;\n\n\t\t\tconst shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;\n\n\t\t\tif ( light.isAmbientLight ) {\n\n\t\t\t\tr += color.r * intensity * scaleFactor;\n\t\t\t\tg += color.g * intensity * scaleFactor;\n\t\t\t\tb += color.b * intensity * scaleFactor;\n\n\t\t\t} else if ( light.isLightProbe ) {\n\n\t\t\t\tfor ( let j = 0; j < 9; j ++ ) {\n\n\t\t\t\t\tstate.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );\n\n\t\t\t\t}\n\n\t\t\t} else if ( light.isDirectionalLight ) {\n\n\t\t\t\tconst uniforms = cache.get( light );\n\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity * scaleFactor );\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tconst shadow = light.shadow;\n\n\t\t\t\t\tconst shadowUniforms = shadowCache.get( light );\n\n\t\t\t\t\tshadowUniforms.shadowBias = shadow.bias;\n\t\t\t\t\tshadowUniforms.shadowNormalBias = shadow.normalBias;\n\t\t\t\t\tshadowUniforms.shadowRadius = shadow.radius;\n\t\t\t\t\tshadowUniforms.shadowMapSize = shadow.mapSize;\n\n\t\t\t\t\tstate.directionalShadow[ directionalLength ] = shadowUniforms;\n\t\t\t\t\tstate.directionalShadowMap[ directionalLength ] = shadowMap;\n\t\t\t\t\tstate.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\n\n\t\t\t\t\tnumDirectionalShadows ++;\n\n\t\t\t\t}\n\n\t\t\t\tstate.directional[ directionalLength ] = uniforms;\n\n\t\t\t\tdirectionalLength ++;\n\n\t\t\t} else if ( light.isSpotLight ) {\n\n\t\t\t\tconst uniforms = cache.get( light );\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\n\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity * scaleFactor );\n\t\t\t\tuniforms.distance = distance;\n\n\t\t\t\tuniforms.coneCos = Math.cos( light.angle );\n\t\t\t\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\n\t\t\t\tuniforms.decay = light.decay;\n\n\t\t\t\tstate.spot[ spotLength ] = uniforms;\n\n\t\t\t\tconst shadow = light.shadow;\n\n\t\t\t\tif ( light.map ) {\n\n\t\t\t\t\tstate.spotLightMap[ numSpotMaps ] = light.map;\n\t\t\t\t\tnumSpotMaps ++;\n\n\t\t\t\t\t// make sure the lightMatrix is up to date\n\t\t\t\t\t// TODO : do it if required only\n\t\t\t\t\tshadow.updateMatrices( light );\n\n\t\t\t\t\tif ( light.castShadow ) numSpotShadowsWithMaps ++;\n\n\t\t\t\t}\n\n\t\t\t\tstate.spotLightMatrix[ spotLength ] = shadow.matrix;\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tconst shadowUniforms = shadowCache.get( light );\n\n\t\t\t\t\tshadowUniforms.shadowBias = shadow.bias;\n\t\t\t\t\tshadowUniforms.shadowNormalBias = shadow.normalBias;\n\t\t\t\t\tshadowUniforms.shadowRadius = shadow.radius;\n\t\t\t\t\tshadowUniforms.shadowMapSize = shadow.mapSize;\n\n\t\t\t\t\tstate.spotShadow[ spotLength ] = shadowUniforms;\n\t\t\t\t\tstate.spotShadowMap[ spotLength ] = shadowMap;\n\n\t\t\t\t\tnumSpotShadows ++;\n\n\t\t\t\t}\n\n\t\t\t\tspotLength ++;\n\n\t\t\t} else if ( light.isRectAreaLight ) {\n\n\t\t\t\tconst uniforms = cache.get( light );\n\n\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\n\n\t\t\t\tuniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );\n\t\t\t\tuniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );\n\n\t\t\t\tstate.rectArea[ rectAreaLength ] = uniforms;\n\n\t\t\t\trectAreaLength ++;\n\n\t\t\t} else if ( light.isPointLight ) {\n\n\t\t\t\tconst uniforms = cache.get( light );\n\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity * scaleFactor );\n\t\t\t\tuniforms.distance = light.distance;\n\t\t\t\tuniforms.decay = light.decay;\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tconst shadow = light.shadow;\n\n\t\t\t\t\tconst shadowUniforms = shadowCache.get( light );\n\n\t\t\t\t\tshadowUniforms.shadowBias = shadow.bias;\n\t\t\t\t\tshadowUniforms.shadowNormalBias = shadow.normalBias;\n\t\t\t\t\tshadowUniforms.shadowRadius = shadow.radius;\n\t\t\t\t\tshadowUniforms.shadowMapSize = shadow.mapSize;\n\t\t\t\t\tshadowUniforms.shadowCameraNear = shadow.camera.near;\n\t\t\t\t\tshadowUniforms.shadowCameraFar = shadow.camera.far;\n\n\t\t\t\t\tstate.pointShadow[ pointLength ] = shadowUniforms;\n\t\t\t\t\tstate.pointShadowMap[ pointLength ] = shadowMap;\n\t\t\t\t\tstate.pointShadowMatrix[ pointLength ] = light.shadow.matrix;\n\n\t\t\t\t\tnumPointShadows ++;\n\n\t\t\t\t}\n\n\t\t\t\tstate.point[ pointLength ] = uniforms;\n\n\t\t\t\tpointLength ++;\n\n\t\t\t} else if ( light.isHemisphereLight ) {\n\n\t\t\t\tconst uniforms = cache.get( light );\n\n\t\t\t\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity * scaleFactor );\n\t\t\t\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity * scaleFactor );\n\n\t\t\t\tstate.hemi[ hemiLength ] = uniforms;\n\n\t\t\t\themiLength ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( rectAreaLength > 0 ) {\n\n\t\t\tif ( capabilities.isWebGL2 ) {\n\n\t\t\t\t// WebGL 2\n\n\t\t\t\tstate.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;\n\t\t\t\tstate.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;\n\n\t\t\t} else {\n\n\t\t\t\t// WebGL 1\n\n\t\t\t\tif ( extensions.has( 'OES_texture_float_linear' ) === true ) {\n\n\t\t\t\t\tstate.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;\n\t\t\t\t\tstate.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;\n\n\t\t\t\t} else if ( extensions.has( 'OES_texture_half_float_linear' ) === true ) {\n\n\t\t\t\t\tstate.rectAreaLTC1 = UniformsLib.LTC_HALF_1;\n\t\t\t\t\tstate.rectAreaLTC2 = UniformsLib.LTC_HALF_2;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.ambient[ 0 ] = r;\n\t\tstate.ambient[ 1 ] = g;\n\t\tstate.ambient[ 2 ] = b;\n\n\t\tconst hash = state.hash;\n\n\t\tif ( hash.directionalLength !== directionalLength ||\n\t\t\thash.pointLength !== pointLength ||\n\t\t\thash.spotLength !== spotLength ||\n\t\t\thash.rectAreaLength !== rectAreaLength ||\n\t\t\thash.hemiLength !== hemiLength ||\n\t\t\thash.numDirectionalShadows !== numDirectionalShadows ||\n\t\t\thash.numPointShadows !== numPointShadows ||\n\t\t\thash.numSpotShadows !== numSpotShadows ||\n\t\t\thash.numSpotMaps !== numSpotMaps ) {\n\n\t\t\tstate.directional.length = directionalLength;\n\t\t\tstate.spot.length = spotLength;\n\t\t\tstate.rectArea.length = rectAreaLength;\n\t\t\tstate.point.length = pointLength;\n\t\t\tstate.hemi.length = hemiLength;\n\n\t\t\tstate.directionalShadow.length = numDirectionalShadows;\n\t\t\tstate.directionalShadowMap.length = numDirectionalShadows;\n\t\t\tstate.pointShadow.length = numPointShadows;\n\t\t\tstate.pointShadowMap.length = numPointShadows;\n\t\t\tstate.spotShadow.length = numSpotShadows;\n\t\t\tstate.spotShadowMap.length = numSpotShadows;\n\t\t\tstate.directionalShadowMatrix.length = numDirectionalShadows;\n\t\t\tstate.pointShadowMatrix.length = numPointShadows;\n\t\t\tstate.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;\n\t\t\tstate.spotLightMap.length = numSpotMaps;\n\t\t\tstate.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;\n\n\t\t\thash.directionalLength = directionalLength;\n\t\t\thash.pointLength = pointLength;\n\t\t\thash.spotLength = spotLength;\n\t\t\thash.rectAreaLength = rectAreaLength;\n\t\t\thash.hemiLength = hemiLength;\n\n\t\t\thash.numDirectionalShadows = numDirectionalShadows;\n\t\t\thash.numPointShadows = numPointShadows;\n\t\t\thash.numSpotShadows = numSpotShadows;\n\t\t\thash.numSpotMaps = numSpotMaps;\n\n\t\t\tstate.version = nextVersion ++;\n\n\t\t}\n\n\t}\n\n\tfunction setupView( lights, camera ) {\n\n\t\tlet directionalLength = 0;\n\t\tlet pointLength = 0;\n\t\tlet spotLength = 0;\n\t\tlet rectAreaLength = 0;\n\t\tlet hemiLength = 0;\n\n\t\tconst viewMatrix = camera.matrixWorldInverse;\n\n\t\tfor ( let i = 0, l = lights.length; i < l; i ++ ) {\n\n\t\t\tconst light = lights[ i ];\n\n\t\t\tif ( light.isDirectionalLight ) {\n\n\t\t\t\tconst uniforms = state.directional[ directionalLength ];\n\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tvector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\tuniforms.direction.sub( vector3 );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\tdirectionalLength ++;\n\n\t\t\t} else if ( light.isSpotLight ) {\n\n\t\t\t\tconst uniforms = state.spot[ spotLength ];\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tvector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\tuniforms.direction.sub( vector3 );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\tspotLength ++;\n\n\t\t\t} else if ( light.isRectAreaLight ) {\n\n\t\t\t\tconst uniforms = state.rectArea[ rectAreaLength ];\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\t// extract local rotation of light to derive width/height half vectors\n\t\t\t\tmatrix42.identity();\n\t\t\t\tmatrix4.copy( light.matrixWorld );\n\t\t\t\tmatrix4.premultiply( viewMatrix );\n\t\t\t\tmatrix42.extractRotation( matrix4 );\n\n\t\t\t\tuniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );\n\t\t\t\tuniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );\n\n\t\t\t\tuniforms.halfWidth.applyMatrix4( matrix42 );\n\t\t\t\tuniforms.halfHeight.applyMatrix4( matrix42 );\n\n\t\t\t\trectAreaLength ++;\n\n\t\t\t} else if ( light.isPointLight ) {\n\n\t\t\t\tconst uniforms = state.point[ pointLength ];\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\tpointLength ++;\n\n\t\t\t} else if ( light.isHemisphereLight ) {\n\n\t\t\t\tconst uniforms = state.hemi[ hemiLength ];\n\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\themiLength ++;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn {\n\t\tsetup: setup,\n\t\tsetupView: setupView,\n\t\tstate: state\n\t};\n\n}\n\n\nexport { WebGLLights };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}