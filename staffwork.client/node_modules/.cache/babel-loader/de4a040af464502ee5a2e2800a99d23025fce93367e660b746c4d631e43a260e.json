{"ast":null,"code":"import { Sphere } from '../math/Sphere.js';\nimport { Ray } from '../math/Ray.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Object3D } from '../core/Object3D.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { PointsMaterial } from '../materials/PointsMaterial.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nconst _inverseMatrix = /*@__PURE__*/new Matrix4();\nconst _ray = /*@__PURE__*/new Ray();\nconst _sphere = /*@__PURE__*/new Sphere();\nconst _position = /*@__PURE__*/new Vector3();\nclass Points extends Object3D {\n  constructor() {\n    let geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new BufferGeometry();\n    let material = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new PointsMaterial();\n    super();\n    this.isPoints = true;\n    this.type = 'Points';\n    this.geometry = geometry;\n    this.material = material;\n    this.updateMorphTargets();\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.material = source.material;\n    this.geometry = source.geometry;\n    return this;\n  }\n  raycast(raycaster, intersects) {\n    const geometry = this.geometry;\n    const matrixWorld = this.matrixWorld;\n    const threshold = raycaster.params.Points.threshold;\n    const drawRange = geometry.drawRange;\n\n    // Checking boundingSphere distance to ray\n\n    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n    _sphere.copy(geometry.boundingSphere);\n    _sphere.applyMatrix4(matrixWorld);\n    _sphere.radius += threshold;\n    if (raycaster.ray.intersectsSphere(_sphere) === false) return;\n\n    //\n\n    _inverseMatrix.copy(matrixWorld).invert();\n    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);\n    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);\n    const localThresholdSq = localThreshold * localThreshold;\n    const index = geometry.index;\n    const attributes = geometry.attributes;\n    const positionAttribute = attributes.position;\n    if (index !== null) {\n      const start = Math.max(0, drawRange.start);\n      const end = Math.min(index.count, drawRange.start + drawRange.count);\n      for (let i = start, il = end; i < il; i++) {\n        const a = index.getX(i);\n        _position.fromBufferAttribute(positionAttribute, a);\n        testPoint(_position, a, localThresholdSq, matrixWorld, raycaster, intersects, this);\n      }\n    } else {\n      const start = Math.max(0, drawRange.start);\n      const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n      for (let i = start, l = end; i < l; i++) {\n        _position.fromBufferAttribute(positionAttribute, i);\n        testPoint(_position, i, localThresholdSq, matrixWorld, raycaster, intersects, this);\n      }\n    }\n  }\n  updateMorphTargets() {\n    const geometry = this.geometry;\n    const morphAttributes = geometry.morphAttributes;\n    const keys = Object.keys(morphAttributes);\n    if (keys.length > 0) {\n      const morphAttribute = morphAttributes[keys[0]];\n      if (morphAttribute !== undefined) {\n        this.morphTargetInfluences = [];\n        this.morphTargetDictionary = {};\n        for (let m = 0, ml = morphAttribute.length; m < ml; m++) {\n          const name = morphAttribute[m].name || String(m);\n          this.morphTargetInfluences.push(0);\n          this.morphTargetDictionary[name] = m;\n        }\n      }\n    }\n  }\n}\nfunction testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {\n  const rayPointDistanceSq = _ray.distanceSqToPoint(point);\n  if (rayPointDistanceSq < localThresholdSq) {\n    const intersectPoint = new Vector3();\n    _ray.closestPointToPoint(point, intersectPoint);\n    intersectPoint.applyMatrix4(matrixWorld);\n    const distance = raycaster.ray.origin.distanceTo(intersectPoint);\n    if (distance < raycaster.near || distance > raycaster.far) return;\n    intersects.push({\n      distance: distance,\n      distanceToRay: Math.sqrt(rayPointDistanceSq),\n      point: intersectPoint,\n      index: index,\n      face: null,\n      object: object\n    });\n  }\n}\nexport { Points };","map":{"version":3,"names":["Sphere","Ray","Matrix4","Object3D","Vector3","PointsMaterial","BufferGeometry","_inverseMatrix","_ray","_sphere","_position","Points","constructor","geometry","material","isPoints","type","updateMorphTargets","copy","source","recursive","raycast","raycaster","intersects","matrixWorld","threshold","params","drawRange","boundingSphere","computeBoundingSphere","applyMatrix4","radius","ray","intersectsSphere","invert","localThreshold","scale","x","y","z","localThresholdSq","index","attributes","positionAttribute","position","start","Math","max","end","min","count","i","il","a","getX","fromBufferAttribute","testPoint","l","morphAttributes","keys","Object","length","morphAttribute","undefined","morphTargetInfluences","morphTargetDictionary","m","ml","name","String","push","point","object","rayPointDistanceSq","distanceSqToPoint","intersectPoint","closestPointToPoint","distance","origin","distanceTo","near","far","distanceToRay","sqrt","face"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/objects/Points.js"],"sourcesContent":["import { Sphere } from '../math/Sphere.js';\nimport { Ray } from '../math/Ray.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Object3D } from '../core/Object3D.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { PointsMaterial } from '../materials/PointsMaterial.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\n\nconst _inverseMatrix = /*@__PURE__*/ new Matrix4();\nconst _ray = /*@__PURE__*/ new Ray();\nconst _sphere = /*@__PURE__*/ new Sphere();\nconst _position = /*@__PURE__*/ new Vector3();\n\nclass Points extends Object3D {\n\n\tconstructor( geometry = new BufferGeometry(), material = new PointsMaterial() ) {\n\n\t\tsuper();\n\n\t\tthis.isPoints = true;\n\n\t\tthis.type = 'Points';\n\n\t\tthis.geometry = geometry;\n\t\tthis.material = material;\n\n\t\tthis.updateMorphTargets();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.material = source.material;\n\t\tthis.geometry = source.geometry;\n\n\t\treturn this;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst threshold = raycaster.params.Points.threshold;\n\t\tconst drawRange = geometry.drawRange;\n\n\t\t// Checking boundingSphere distance to ray\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere.copy( geometry.boundingSphere );\n\t\t_sphere.applyMatrix4( matrixWorld );\n\t\t_sphere.radius += threshold;\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;\n\n\t\t//\n\n\t\t_inverseMatrix.copy( matrixWorld ).invert();\n\t\t_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );\n\n\t\tconst localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\tconst localThresholdSq = localThreshold * localThreshold;\n\n\t\tconst index = geometry.index;\n\t\tconst attributes = geometry.attributes;\n\t\tconst positionAttribute = attributes.position;\n\n\t\tif ( index !== null ) {\n\n\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\tconst end = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( let i = start, il = end; i < il; i ++ ) {\n\n\t\t\t\tconst a = index.getX( i );\n\n\t\t\t\t_position.fromBufferAttribute( positionAttribute, a );\n\n\t\t\t\ttestPoint( _position, a, localThresholdSq, matrixWorld, raycaster, intersects, this );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\tconst end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( let i = start, l = end; i < l; i ++ ) {\n\n\t\t\t\t_position.fromBufferAttribute( positionAttribute, i );\n\n\t\t\t\ttestPoint( _position, i, localThresholdSq, matrixWorld, raycaster, intersects, this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tupdateMorphTargets() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst morphAttributes = geometry.morphAttributes;\n\t\tconst keys = Object.keys( morphAttributes );\n\n\t\tif ( keys.length > 0 ) {\n\n\t\t\tconst morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\tfor ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\tconst name = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nfunction testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {\n\n\tconst rayPointDistanceSq = _ray.distanceSqToPoint( point );\n\n\tif ( rayPointDistanceSq < localThresholdSq ) {\n\n\t\tconst intersectPoint = new Vector3();\n\n\t\t_ray.closestPointToPoint( point, intersectPoint );\n\t\tintersectPoint.applyMatrix4( matrixWorld );\n\n\t\tconst distance = raycaster.ray.origin.distanceTo( intersectPoint );\n\n\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\t\tintersects.push( {\n\n\t\t\tdistance: distance,\n\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\n\t\t\tpoint: intersectPoint,\n\t\t\tindex: index,\n\t\t\tface: null,\n\t\t\tobject: object\n\n\t\t} );\n\n\t}\n\n}\n\nexport { Points };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}