{"ast":null,"code":"import { UVMapping, CubeReflectionMapping, CubeRefractionMapping, EquirectangularReflectionMapping, EquirectangularRefractionMapping, CubeUVReflectionMapping, RepeatWrapping, ClampToEdgeWrapping, MirroredRepeatWrapping, NearestFilter, NearestMipmapNearestFilter, NearestMipmapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipmapLinearFilter } from '../constants.js';\nimport { InstancedBufferAttribute } from '../core/InstancedBufferAttribute.js';\nimport { Color } from '../math/Color.js';\nimport { Object3D } from '../core/Object3D.js';\nimport { Group } from '../objects/Group.js';\nimport { InstancedMesh } from '../objects/InstancedMesh.js';\nimport { Sprite } from '../objects/Sprite.js';\nimport { Points } from '../objects/Points.js';\nimport { Line } from '../objects/Line.js';\nimport { LineLoop } from '../objects/LineLoop.js';\nimport { LineSegments } from '../objects/LineSegments.js';\nimport { LOD } from '../objects/LOD.js';\nimport { Mesh } from '../objects/Mesh.js';\nimport { SkinnedMesh } from '../objects/SkinnedMesh.js';\nimport { Bone } from '../objects/Bone.js';\nimport { Skeleton } from '../objects/Skeleton.js';\nimport { Shape } from '../extras/core/Shape.js';\nimport { Fog } from '../scenes/Fog.js';\nimport { FogExp2 } from '../scenes/FogExp2.js';\nimport { HemisphereLight } from '../lights/HemisphereLight.js';\nimport { SpotLight } from '../lights/SpotLight.js';\nimport { PointLight } from '../lights/PointLight.js';\nimport { DirectionalLight } from '../lights/DirectionalLight.js';\nimport { AmbientLight } from '../lights/AmbientLight.js';\nimport { RectAreaLight } from '../lights/RectAreaLight.js';\nimport { LightProbe } from '../lights/LightProbe.js';\nimport { OrthographicCamera } from '../cameras/OrthographicCamera.js';\nimport { PerspectiveCamera } from '../cameras/PerspectiveCamera.js';\nimport { Scene } from '../scenes/Scene.js';\nimport { CubeTexture } from '../textures/CubeTexture.js';\nimport { Texture } from '../textures/Texture.js';\nimport { Source } from '../textures/Source.js';\nimport { DataTexture } from '../textures/DataTexture.js';\nimport { ImageLoader } from './ImageLoader.js';\nimport { LoadingManager } from './LoadingManager.js';\nimport { AnimationClip } from '../animation/AnimationClip.js';\nimport { MaterialLoader } from './MaterialLoader.js';\nimport { LoaderUtils } from './LoaderUtils.js';\nimport { BufferGeometryLoader } from './BufferGeometryLoader.js';\nimport { Loader } from './Loader.js';\nimport { FileLoader } from './FileLoader.js';\nimport * as Geometries from '../geometries/Geometries.js';\nimport { getTypedArray } from '../utils.js';\nclass ObjectLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;\n    this.resourcePath = this.resourcePath || path;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (text) {\n      let json = null;\n      try {\n        json = JSON.parse(text);\n      } catch (error) {\n        if (onError !== undefined) onError(error);\n        console.error('THREE:ObjectLoader: Can\\'t parse ' + url + '.', error.message);\n        return;\n      }\n      const metadata = json.metadata;\n      if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {\n        if (onError !== undefined) onError(new Error('THREE.ObjectLoader: Can\\'t load ' + url));\n        console.error('THREE.ObjectLoader: Can\\'t load ' + url);\n        return;\n      }\n      scope.parse(json, onLoad);\n    }, onProgress, onError);\n  }\n  async loadAsync(url, onProgress) {\n    const scope = this;\n    const path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;\n    this.resourcePath = this.resourcePath || path;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    const text = await loader.loadAsync(url, onProgress);\n    const json = JSON.parse(text);\n    const metadata = json.metadata;\n    if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {\n      throw new Error('THREE.ObjectLoader: Can\\'t load ' + url);\n    }\n    return await scope.parseAsync(json);\n  }\n  parse(json, onLoad) {\n    const animations = this.parseAnimations(json.animations);\n    const shapes = this.parseShapes(json.shapes);\n    const geometries = this.parseGeometries(json.geometries, shapes);\n    const images = this.parseImages(json.images, function () {\n      if (onLoad !== undefined) onLoad(object);\n    });\n    const textures = this.parseTextures(json.textures, images);\n    const materials = this.parseMaterials(json.materials, textures);\n    const object = this.parseObject(json.object, geometries, materials, textures, animations);\n    const skeletons = this.parseSkeletons(json.skeletons, object);\n    this.bindSkeletons(object, skeletons);\n\n    //\n\n    if (onLoad !== undefined) {\n      let hasImages = false;\n      for (const uuid in images) {\n        if (images[uuid].data instanceof HTMLImageElement) {\n          hasImages = true;\n          break;\n        }\n      }\n      if (hasImages === false) onLoad(object);\n    }\n    return object;\n  }\n  async parseAsync(json) {\n    const animations = this.parseAnimations(json.animations);\n    const shapes = this.parseShapes(json.shapes);\n    const geometries = this.parseGeometries(json.geometries, shapes);\n    const images = await this.parseImagesAsync(json.images);\n    const textures = this.parseTextures(json.textures, images);\n    const materials = this.parseMaterials(json.materials, textures);\n    const object = this.parseObject(json.object, geometries, materials, textures, animations);\n    const skeletons = this.parseSkeletons(json.skeletons, object);\n    this.bindSkeletons(object, skeletons);\n    return object;\n  }\n  parseShapes(json) {\n    const shapes = {};\n    if (json !== undefined) {\n      for (let i = 0, l = json.length; i < l; i++) {\n        const shape = new Shape().fromJSON(json[i]);\n        shapes[shape.uuid] = shape;\n      }\n    }\n    return shapes;\n  }\n  parseSkeletons(json, object) {\n    const skeletons = {};\n    const bones = {};\n\n    // generate bone lookup table\n\n    object.traverse(function (child) {\n      if (child.isBone) bones[child.uuid] = child;\n    });\n\n    // create skeletons\n\n    if (json !== undefined) {\n      for (let i = 0, l = json.length; i < l; i++) {\n        const skeleton = new Skeleton().fromJSON(json[i], bones);\n        skeletons[skeleton.uuid] = skeleton;\n      }\n    }\n    return skeletons;\n  }\n  parseGeometries(json, shapes) {\n    const geometries = {};\n    if (json !== undefined) {\n      const bufferGeometryLoader = new BufferGeometryLoader();\n      for (let i = 0, l = json.length; i < l; i++) {\n        let geometry;\n        const data = json[i];\n        switch (data.type) {\n          case 'BufferGeometry':\n          case 'InstancedBufferGeometry':\n            geometry = bufferGeometryLoader.parse(data);\n            break;\n          default:\n            if (data.type in Geometries) {\n              geometry = Geometries[data.type].fromJSON(data, shapes);\n            } else {\n              console.warn(`THREE.ObjectLoader: Unsupported geometry type \"${data.type}\"`);\n            }\n        }\n        geometry.uuid = data.uuid;\n        if (data.name !== undefined) geometry.name = data.name;\n        if (geometry.isBufferGeometry === true && data.userData !== undefined) geometry.userData = data.userData;\n        geometries[data.uuid] = geometry;\n      }\n    }\n    return geometries;\n  }\n  parseMaterials(json, textures) {\n    const cache = {}; // MultiMaterial\n    const materials = {};\n    if (json !== undefined) {\n      const loader = new MaterialLoader();\n      loader.setTextures(textures);\n      for (let i = 0, l = json.length; i < l; i++) {\n        const data = json[i];\n        if (cache[data.uuid] === undefined) {\n          cache[data.uuid] = loader.parse(data);\n        }\n        materials[data.uuid] = cache[data.uuid];\n      }\n    }\n    return materials;\n  }\n  parseAnimations(json) {\n    const animations = {};\n    if (json !== undefined) {\n      for (let i = 0; i < json.length; i++) {\n        const data = json[i];\n        const clip = AnimationClip.parse(data);\n        animations[clip.uuid] = clip;\n      }\n    }\n    return animations;\n  }\n  parseImages(json, onLoad) {\n    const scope = this;\n    const images = {};\n    let loader;\n    function loadImage(url) {\n      scope.manager.itemStart(url);\n      return loader.load(url, function () {\n        scope.manager.itemEnd(url);\n      }, undefined, function () {\n        scope.manager.itemError(url);\n        scope.manager.itemEnd(url);\n      });\n    }\n    function deserializeImage(image) {\n      if (typeof image === 'string') {\n        const url = image;\n        const path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test(url) ? url : scope.resourcePath + url;\n        return loadImage(path);\n      } else {\n        if (image.data) {\n          return {\n            data: getTypedArray(image.type, image.data),\n            width: image.width,\n            height: image.height\n          };\n        } else {\n          return null;\n        }\n      }\n    }\n    if (json !== undefined && json.length > 0) {\n      const manager = new LoadingManager(onLoad);\n      loader = new ImageLoader(manager);\n      loader.setCrossOrigin(this.crossOrigin);\n      for (let i = 0, il = json.length; i < il; i++) {\n        const image = json[i];\n        const url = image.url;\n        if (Array.isArray(url)) {\n          // load array of images e.g CubeTexture\n\n          const imageArray = [];\n          for (let j = 0, jl = url.length; j < jl; j++) {\n            const currentUrl = url[j];\n            const deserializedImage = deserializeImage(currentUrl);\n            if (deserializedImage !== null) {\n              if (deserializedImage instanceof HTMLImageElement) {\n                imageArray.push(deserializedImage);\n              } else {\n                // special case: handle array of data textures for cube textures\n\n                imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));\n              }\n            }\n          }\n          images[image.uuid] = new Source(imageArray);\n        } else {\n          // load single image\n\n          const deserializedImage = deserializeImage(image.url);\n          images[image.uuid] = new Source(deserializedImage);\n        }\n      }\n    }\n    return images;\n  }\n  async parseImagesAsync(json) {\n    const scope = this;\n    const images = {};\n    let loader;\n    async function deserializeImage(image) {\n      if (typeof image === 'string') {\n        const url = image;\n        const path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test(url) ? url : scope.resourcePath + url;\n        return await loader.loadAsync(path);\n      } else {\n        if (image.data) {\n          return {\n            data: getTypedArray(image.type, image.data),\n            width: image.width,\n            height: image.height\n          };\n        } else {\n          return null;\n        }\n      }\n    }\n    if (json !== undefined && json.length > 0) {\n      loader = new ImageLoader(this.manager);\n      loader.setCrossOrigin(this.crossOrigin);\n      for (let i = 0, il = json.length; i < il; i++) {\n        const image = json[i];\n        const url = image.url;\n        if (Array.isArray(url)) {\n          // load array of images e.g CubeTexture\n\n          const imageArray = [];\n          for (let j = 0, jl = url.length; j < jl; j++) {\n            const currentUrl = url[j];\n            const deserializedImage = await deserializeImage(currentUrl);\n            if (deserializedImage !== null) {\n              if (deserializedImage instanceof HTMLImageElement) {\n                imageArray.push(deserializedImage);\n              } else {\n                // special case: handle array of data textures for cube textures\n\n                imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));\n              }\n            }\n          }\n          images[image.uuid] = new Source(imageArray);\n        } else {\n          // load single image\n\n          const deserializedImage = await deserializeImage(image.url);\n          images[image.uuid] = new Source(deserializedImage);\n        }\n      }\n    }\n    return images;\n  }\n  parseTextures(json, images) {\n    function parseConstant(value, type) {\n      if (typeof value === 'number') return value;\n      console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);\n      return type[value];\n    }\n    const textures = {};\n    if (json !== undefined) {\n      for (let i = 0, l = json.length; i < l; i++) {\n        const data = json[i];\n        if (data.image === undefined) {\n          console.warn('THREE.ObjectLoader: No \"image\" specified for', data.uuid);\n        }\n        if (images[data.image] === undefined) {\n          console.warn('THREE.ObjectLoader: Undefined image', data.image);\n        }\n        const source = images[data.image];\n        const image = source.data;\n        let texture;\n        if (Array.isArray(image)) {\n          texture = new CubeTexture();\n          if (image.length === 6) texture.needsUpdate = true;\n        } else {\n          if (image && image.data) {\n            texture = new DataTexture();\n          } else {\n            texture = new Texture();\n          }\n          if (image) texture.needsUpdate = true; // textures can have undefined image data\n        }\n\n        texture.source = source;\n        texture.uuid = data.uuid;\n        if (data.name !== undefined) texture.name = data.name;\n        if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);\n        if (data.offset !== undefined) texture.offset.fromArray(data.offset);\n        if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);\n        if (data.center !== undefined) texture.center.fromArray(data.center);\n        if (data.rotation !== undefined) texture.rotation = data.rotation;\n        if (data.wrap !== undefined) {\n          texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);\n          texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);\n        }\n        if (data.format !== undefined) texture.format = data.format;\n        if (data.type !== undefined) texture.type = data.type;\n        if (data.encoding !== undefined) texture.encoding = data.encoding;\n        if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);\n        if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);\n        if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;\n        if (data.flipY !== undefined) texture.flipY = data.flipY;\n        if (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha;\n        if (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment;\n        if (data.userData !== undefined) texture.userData = data.userData;\n        textures[data.uuid] = texture;\n      }\n    }\n    return textures;\n  }\n  parseObject(data, geometries, materials, textures, animations) {\n    let object;\n    function getGeometry(name) {\n      if (geometries[name] === undefined) {\n        console.warn('THREE.ObjectLoader: Undefined geometry', name);\n      }\n      return geometries[name];\n    }\n    function getMaterial(name) {\n      if (name === undefined) return undefined;\n      if (Array.isArray(name)) {\n        const array = [];\n        for (let i = 0, l = name.length; i < l; i++) {\n          const uuid = name[i];\n          if (materials[uuid] === undefined) {\n            console.warn('THREE.ObjectLoader: Undefined material', uuid);\n          }\n          array.push(materials[uuid]);\n        }\n        return array;\n      }\n      if (materials[name] === undefined) {\n        console.warn('THREE.ObjectLoader: Undefined material', name);\n      }\n      return materials[name];\n    }\n    function getTexture(uuid) {\n      if (textures[uuid] === undefined) {\n        console.warn('THREE.ObjectLoader: Undefined texture', uuid);\n      }\n      return textures[uuid];\n    }\n    let geometry, material;\n    switch (data.type) {\n      case 'Scene':\n        object = new Scene();\n        if (data.background !== undefined) {\n          if (Number.isInteger(data.background)) {\n            object.background = new Color(data.background);\n          } else {\n            object.background = getTexture(data.background);\n          }\n        }\n        if (data.environment !== undefined) {\n          object.environment = getTexture(data.environment);\n        }\n        if (data.fog !== undefined) {\n          if (data.fog.type === 'Fog') {\n            object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);\n          } else if (data.fog.type === 'FogExp2') {\n            object.fog = new FogExp2(data.fog.color, data.fog.density);\n          }\n        }\n        if (data.backgroundBlurriness !== undefined) object.backgroundBlurriness = data.backgroundBlurriness;\n        break;\n      case 'PerspectiveCamera':\n        object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);\n        if (data.focus !== undefined) object.focus = data.focus;\n        if (data.zoom !== undefined) object.zoom = data.zoom;\n        if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;\n        if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;\n        if (data.view !== undefined) object.view = Object.assign({}, data.view);\n        break;\n      case 'OrthographicCamera':\n        object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);\n        if (data.zoom !== undefined) object.zoom = data.zoom;\n        if (data.view !== undefined) object.view = Object.assign({}, data.view);\n        break;\n      case 'AmbientLight':\n        object = new AmbientLight(data.color, data.intensity);\n        break;\n      case 'DirectionalLight':\n        object = new DirectionalLight(data.color, data.intensity);\n        break;\n      case 'PointLight':\n        object = new PointLight(data.color, data.intensity, data.distance, data.decay);\n        break;\n      case 'RectAreaLight':\n        object = new RectAreaLight(data.color, data.intensity, data.width, data.height);\n        break;\n      case 'SpotLight':\n        object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);\n        break;\n      case 'HemisphereLight':\n        object = new HemisphereLight(data.color, data.groundColor, data.intensity);\n        break;\n      case 'LightProbe':\n        object = new LightProbe().fromJSON(data);\n        break;\n      case 'SkinnedMesh':\n        geometry = getGeometry(data.geometry);\n        material = getMaterial(data.material);\n        object = new SkinnedMesh(geometry, material);\n        if (data.bindMode !== undefined) object.bindMode = data.bindMode;\n        if (data.bindMatrix !== undefined) object.bindMatrix.fromArray(data.bindMatrix);\n        if (data.skeleton !== undefined) object.skeleton = data.skeleton;\n        break;\n      case 'Mesh':\n        geometry = getGeometry(data.geometry);\n        material = getMaterial(data.material);\n        object = new Mesh(geometry, material);\n        break;\n      case 'InstancedMesh':\n        geometry = getGeometry(data.geometry);\n        material = getMaterial(data.material);\n        const count = data.count;\n        const instanceMatrix = data.instanceMatrix;\n        const instanceColor = data.instanceColor;\n        object = new InstancedMesh(geometry, material, count);\n        object.instanceMatrix = new InstancedBufferAttribute(new Float32Array(instanceMatrix.array), 16);\n        if (instanceColor !== undefined) object.instanceColor = new InstancedBufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize);\n        break;\n      case 'LOD':\n        object = new LOD();\n        break;\n      case 'Line':\n        object = new Line(getGeometry(data.geometry), getMaterial(data.material));\n        break;\n      case 'LineLoop':\n        object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));\n        break;\n      case 'LineSegments':\n        object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));\n        break;\n      case 'PointCloud':\n      case 'Points':\n        object = new Points(getGeometry(data.geometry), getMaterial(data.material));\n        break;\n      case 'Sprite':\n        object = new Sprite(getMaterial(data.material));\n        break;\n      case 'Group':\n        object = new Group();\n        break;\n      case 'Bone':\n        object = new Bone();\n        break;\n      default:\n        object = new Object3D();\n    }\n    object.uuid = data.uuid;\n    if (data.name !== undefined) object.name = data.name;\n    if (data.matrix !== undefined) {\n      object.matrix.fromArray(data.matrix);\n      if (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;\n      if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);\n    } else {\n      if (data.position !== undefined) object.position.fromArray(data.position);\n      if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);\n      if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);\n      if (data.scale !== undefined) object.scale.fromArray(data.scale);\n    }\n    if (data.castShadow !== undefined) object.castShadow = data.castShadow;\n    if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;\n    if (data.shadow) {\n      if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;\n      if (data.shadow.normalBias !== undefined) object.shadow.normalBias = data.shadow.normalBias;\n      if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;\n      if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);\n      if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);\n    }\n    if (data.visible !== undefined) object.visible = data.visible;\n    if (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;\n    if (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;\n    if (data.userData !== undefined) object.userData = data.userData;\n    if (data.layers !== undefined) object.layers.mask = data.layers;\n    if (data.children !== undefined) {\n      const children = data.children;\n      for (let i = 0; i < children.length; i++) {\n        object.add(this.parseObject(children[i], geometries, materials, textures, animations));\n      }\n    }\n    if (data.animations !== undefined) {\n      const objectAnimations = data.animations;\n      for (let i = 0; i < objectAnimations.length; i++) {\n        const uuid = objectAnimations[i];\n        object.animations.push(animations[uuid]);\n      }\n    }\n    if (data.type === 'LOD') {\n      if (data.autoUpdate !== undefined) object.autoUpdate = data.autoUpdate;\n      const levels = data.levels;\n      for (let l = 0; l < levels.length; l++) {\n        const level = levels[l];\n        const child = object.getObjectByProperty('uuid', level.object);\n        if (child !== undefined) {\n          object.addLevel(child, level.distance, level.hysteresis);\n        }\n      }\n    }\n    return object;\n  }\n  bindSkeletons(object, skeletons) {\n    if (Object.keys(skeletons).length === 0) return;\n    object.traverse(function (child) {\n      if (child.isSkinnedMesh === true && child.skeleton !== undefined) {\n        const skeleton = skeletons[child.skeleton];\n        if (skeleton === undefined) {\n          console.warn('THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton);\n        } else {\n          child.bind(skeleton, child.bindMatrix);\n        }\n      }\n    });\n  }\n}\nconst TEXTURE_MAPPING = {\n  UVMapping: UVMapping,\n  CubeReflectionMapping: CubeReflectionMapping,\n  CubeRefractionMapping: CubeRefractionMapping,\n  EquirectangularReflectionMapping: EquirectangularReflectionMapping,\n  EquirectangularRefractionMapping: EquirectangularRefractionMapping,\n  CubeUVReflectionMapping: CubeUVReflectionMapping\n};\nconst TEXTURE_WRAPPING = {\n  RepeatWrapping: RepeatWrapping,\n  ClampToEdgeWrapping: ClampToEdgeWrapping,\n  MirroredRepeatWrapping: MirroredRepeatWrapping\n};\nconst TEXTURE_FILTER = {\n  NearestFilter: NearestFilter,\n  NearestMipmapNearestFilter: NearestMipmapNearestFilter,\n  NearestMipmapLinearFilter: NearestMipmapLinearFilter,\n  LinearFilter: LinearFilter,\n  LinearMipmapNearestFilter: LinearMipmapNearestFilter,\n  LinearMipmapLinearFilter: LinearMipmapLinearFilter\n};\nexport { ObjectLoader };","map":{"version":3,"names":["UVMapping","CubeReflectionMapping","CubeRefractionMapping","EquirectangularReflectionMapping","EquirectangularRefractionMapping","CubeUVReflectionMapping","RepeatWrapping","ClampToEdgeWrapping","MirroredRepeatWrapping","NearestFilter","NearestMipmapNearestFilter","NearestMipmapLinearFilter","LinearFilter","LinearMipmapNearestFilter","LinearMipmapLinearFilter","InstancedBufferAttribute","Color","Object3D","Group","InstancedMesh","Sprite","Points","Line","LineLoop","LineSegments","LOD","Mesh","SkinnedMesh","Bone","Skeleton","Shape","Fog","FogExp2","HemisphereLight","SpotLight","PointLight","DirectionalLight","AmbientLight","RectAreaLight","LightProbe","OrthographicCamera","PerspectiveCamera","Scene","CubeTexture","Texture","Source","DataTexture","ImageLoader","LoadingManager","AnimationClip","MaterialLoader","LoaderUtils","BufferGeometryLoader","Loader","FileLoader","Geometries","getTypedArray","ObjectLoader","constructor","manager","load","url","onLoad","onProgress","onError","scope","path","extractUrlBase","resourcePath","loader","setPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","json","JSON","parse","error","undefined","console","message","metadata","type","toLowerCase","Error","loadAsync","parseAsync","animations","parseAnimations","shapes","parseShapes","geometries","parseGeometries","images","parseImages","object","textures","parseTextures","materials","parseMaterials","parseObject","skeletons","parseSkeletons","bindSkeletons","hasImages","uuid","data","HTMLImageElement","parseImagesAsync","i","l","length","shape","fromJSON","bones","traverse","child","isBone","skeleton","bufferGeometryLoader","geometry","warn","name","isBufferGeometry","userData","cache","setTextures","clip","loadImage","itemStart","itemEnd","itemError","deserializeImage","image","test","width","height","setCrossOrigin","crossOrigin","il","Array","isArray","imageArray","j","jl","currentUrl","deserializedImage","push","parseConstant","value","source","texture","needsUpdate","mapping","TEXTURE_MAPPING","offset","fromArray","repeat","center","rotation","wrap","wrapS","TEXTURE_WRAPPING","wrapT","format","encoding","minFilter","TEXTURE_FILTER","magFilter","anisotropy","flipY","premultiplyAlpha","unpackAlignment","getGeometry","getMaterial","array","getTexture","material","background","Number","isInteger","environment","fog","color","near","far","density","backgroundBlurriness","fov","aspect","focus","zoom","filmGauge","filmOffset","view","Object","assign","left","right","top","bottom","intensity","distance","decay","angle","penumbra","groundColor","bindMode","bindMatrix","count","instanceMatrix","instanceColor","Float32Array","itemSize","matrix","matrixAutoUpdate","decompose","position","quaternion","scale","castShadow","receiveShadow","shadow","bias","normalBias","radius","mapSize","camera","visible","frustumCulled","renderOrder","layers","mask","children","add","objectAnimations","autoUpdate","levels","level","getObjectByProperty","addLevel","hysteresis","keys","isSkinnedMesh","bind"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/loaders/ObjectLoader.js"],"sourcesContent":["import {\n\tUVMapping,\n\tCubeReflectionMapping,\n\tCubeRefractionMapping,\n\tEquirectangularReflectionMapping,\n\tEquirectangularRefractionMapping,\n\tCubeUVReflectionMapping,\n\n\tRepeatWrapping,\n\tClampToEdgeWrapping,\n\tMirroredRepeatWrapping,\n\n\tNearestFilter,\n\tNearestMipmapNearestFilter,\n\tNearestMipmapLinearFilter,\n\tLinearFilter,\n\tLinearMipmapNearestFilter,\n\tLinearMipmapLinearFilter\n} from '../constants.js';\nimport { InstancedBufferAttribute } from '../core/InstancedBufferAttribute.js';\nimport { Color } from '../math/Color.js';\nimport { Object3D } from '../core/Object3D.js';\nimport { Group } from '../objects/Group.js';\nimport { InstancedMesh } from '../objects/InstancedMesh.js';\nimport { Sprite } from '../objects/Sprite.js';\nimport { Points } from '../objects/Points.js';\nimport { Line } from '../objects/Line.js';\nimport { LineLoop } from '../objects/LineLoop.js';\nimport { LineSegments } from '../objects/LineSegments.js';\nimport { LOD } from '../objects/LOD.js';\nimport { Mesh } from '../objects/Mesh.js';\nimport { SkinnedMesh } from '../objects/SkinnedMesh.js';\nimport { Bone } from '../objects/Bone.js';\nimport { Skeleton } from '../objects/Skeleton.js';\nimport { Shape } from '../extras/core/Shape.js';\nimport { Fog } from '../scenes/Fog.js';\nimport { FogExp2 } from '../scenes/FogExp2.js';\nimport { HemisphereLight } from '../lights/HemisphereLight.js';\nimport { SpotLight } from '../lights/SpotLight.js';\nimport { PointLight } from '../lights/PointLight.js';\nimport { DirectionalLight } from '../lights/DirectionalLight.js';\nimport { AmbientLight } from '../lights/AmbientLight.js';\nimport { RectAreaLight } from '../lights/RectAreaLight.js';\nimport { LightProbe } from '../lights/LightProbe.js';\nimport { OrthographicCamera } from '../cameras/OrthographicCamera.js';\nimport { PerspectiveCamera } from '../cameras/PerspectiveCamera.js';\nimport { Scene } from '../scenes/Scene.js';\nimport { CubeTexture } from '../textures/CubeTexture.js';\nimport { Texture } from '../textures/Texture.js';\nimport { Source } from '../textures/Source.js';\nimport { DataTexture } from '../textures/DataTexture.js';\nimport { ImageLoader } from './ImageLoader.js';\nimport { LoadingManager } from './LoadingManager.js';\nimport { AnimationClip } from '../animation/AnimationClip.js';\nimport { MaterialLoader } from './MaterialLoader.js';\nimport { LoaderUtils } from './LoaderUtils.js';\nimport { BufferGeometryLoader } from './BufferGeometryLoader.js';\nimport { Loader } from './Loader.js';\nimport { FileLoader } from './FileLoader.js';\nimport * as Geometries from '../geometries/Geometries.js';\nimport { getTypedArray } from '../utils.js';\n\nclass ObjectLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;\n\t\tthis.resourcePath = this.resourcePath || path;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tlet json = null;\n\n\t\t\ttry {\n\n\t\t\t\tjson = JSON.parse( text );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tif ( onError !== undefined ) onError( error );\n\n\t\t\t\tconsole.error( 'THREE:ObjectLoader: Can\\'t parse ' + url + '.', error.message );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tconst metadata = json.metadata;\n\n\t\t\tif ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {\n\n\t\t\t\tif ( onError !== undefined ) onError( new Error( 'THREE.ObjectLoader: Can\\'t load ' + url ) );\n\n\t\t\t\tconsole.error( 'THREE.ObjectLoader: Can\\'t load ' + url );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tscope.parse( json, onLoad );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tasync loadAsync( url, onProgress ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;\n\t\tthis.resourcePath = this.resourcePath || path;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tconst text = await loader.loadAsync( url, onProgress );\n\n\t\tconst json = JSON.parse( text );\n\n\t\tconst metadata = json.metadata;\n\n\t\tif ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {\n\n\t\t\tthrow new Error( 'THREE.ObjectLoader: Can\\'t load ' + url );\n\n\t\t}\n\n\t\treturn await scope.parseAsync( json );\n\n\t}\n\n\tparse( json, onLoad ) {\n\n\t\tconst animations = this.parseAnimations( json.animations );\n\t\tconst shapes = this.parseShapes( json.shapes );\n\t\tconst geometries = this.parseGeometries( json.geometries, shapes );\n\n\t\tconst images = this.parseImages( json.images, function () {\n\n\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\n\t\t} );\n\n\t\tconst textures = this.parseTextures( json.textures, images );\n\t\tconst materials = this.parseMaterials( json.materials, textures );\n\n\t\tconst object = this.parseObject( json.object, geometries, materials, textures, animations );\n\t\tconst skeletons = this.parseSkeletons( json.skeletons, object );\n\n\t\tthis.bindSkeletons( object, skeletons );\n\n\t\t//\n\n\t\tif ( onLoad !== undefined ) {\n\n\t\t\tlet hasImages = false;\n\n\t\t\tfor ( const uuid in images ) {\n\n\t\t\t\tif ( images[ uuid ].data instanceof HTMLImageElement ) {\n\n\t\t\t\t\thasImages = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasImages === false ) onLoad( object );\n\n\t\t}\n\n\t\treturn object;\n\n\t}\n\n\tasync parseAsync( json ) {\n\n\t\tconst animations = this.parseAnimations( json.animations );\n\t\tconst shapes = this.parseShapes( json.shapes );\n\t\tconst geometries = this.parseGeometries( json.geometries, shapes );\n\n\t\tconst images = await this.parseImagesAsync( json.images );\n\n\t\tconst textures = this.parseTextures( json.textures, images );\n\t\tconst materials = this.parseMaterials( json.materials, textures );\n\n\t\tconst object = this.parseObject( json.object, geometries, materials, textures, animations );\n\t\tconst skeletons = this.parseSkeletons( json.skeletons, object );\n\n\t\tthis.bindSkeletons( object, skeletons );\n\n\t\treturn object;\n\n\t}\n\n\tparseShapes( json ) {\n\n\t\tconst shapes = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst shape = new Shape().fromJSON( json[ i ] );\n\n\t\t\t\tshapes[ shape.uuid ] = shape;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn shapes;\n\n\t}\n\n\tparseSkeletons( json, object ) {\n\n\t\tconst skeletons = {};\n\t\tconst bones = {};\n\n\t\t// generate bone lookup table\n\n\t\tobject.traverse( function ( child ) {\n\n\t\t\tif ( child.isBone ) bones[ child.uuid ] = child;\n\n\t\t} );\n\n\t\t// create skeletons\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst skeleton = new Skeleton().fromJSON( json[ i ], bones );\n\n\t\t\t\tskeletons[ skeleton.uuid ] = skeleton;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn skeletons;\n\n\t}\n\n\tparseGeometries( json, shapes ) {\n\n\t\tconst geometries = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tconst bufferGeometryLoader = new BufferGeometryLoader();\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tlet geometry;\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tswitch ( data.type ) {\n\n\t\t\t\t\tcase 'BufferGeometry':\n\t\t\t\t\tcase 'InstancedBufferGeometry':\n\n\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tif ( data.type in Geometries ) {\n\n\t\t\t\t\t\t\tgeometry = Geometries[ data.type ].fromJSON( data, shapes );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconsole.warn( `THREE.ObjectLoader: Unsupported geometry type \"${ data.type }\"` );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\n\t\t\t\tif ( geometry.isBufferGeometry === true && data.userData !== undefined ) geometry.userData = data.userData;\n\n\t\t\t\tgeometries[ data.uuid ] = geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn geometries;\n\n\t}\n\n\tparseMaterials( json, textures ) {\n\n\t\tconst cache = {}; // MultiMaterial\n\t\tconst materials = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tconst loader = new MaterialLoader();\n\t\t\tloader.setTextures( textures );\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tif ( cache[ data.uuid ] === undefined ) {\n\n\t\t\t\t\tcache[ data.uuid ] = loader.parse( data );\n\n\t\t\t\t}\n\n\t\t\t\tmaterials[ data.uuid ] = cache[ data.uuid ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn materials;\n\n\t}\n\n\tparseAnimations( json ) {\n\n\t\tconst animations = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( let i = 0; i < json.length; i ++ ) {\n\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tconst clip = AnimationClip.parse( data );\n\n\t\t\t\tanimations[ clip.uuid ] = clip;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn animations;\n\n\t}\n\n\tparseImages( json, onLoad ) {\n\n\t\tconst scope = this;\n\t\tconst images = {};\n\n\t\tlet loader;\n\n\t\tfunction loadImage( url ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\treturn loader.load( url, function () {\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, undefined, function () {\n\n\t\t\t\tscope.manager.itemError( url );\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t} );\n\n\t\t}\n\n\t\tfunction deserializeImage( image ) {\n\n\t\t\tif ( typeof image === 'string' ) {\n\n\t\t\t\tconst url = image;\n\n\t\t\t\tconst path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( url ) ? url : scope.resourcePath + url;\n\n\t\t\t\treturn loadImage( path );\n\n\t\t\t} else {\n\n\t\t\t\tif ( image.data ) {\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdata: getTypedArray( image.type, image.data ),\n\t\t\t\t\t\twidth: image.width,\n\t\t\t\t\t\theight: image.height\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( json !== undefined && json.length > 0 ) {\n\n\t\t\tconst manager = new LoadingManager( onLoad );\n\n\t\t\tloader = new ImageLoader( manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\tfor ( let i = 0, il = json.length; i < il; i ++ ) {\n\n\t\t\t\tconst image = json[ i ];\n\t\t\t\tconst url = image.url;\n\n\t\t\t\tif ( Array.isArray( url ) ) {\n\n\t\t\t\t\t// load array of images e.g CubeTexture\n\n\t\t\t\t\tconst imageArray = [];\n\n\t\t\t\t\tfor ( let j = 0, jl = url.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tconst currentUrl = url[ j ];\n\n\t\t\t\t\t\tconst deserializedImage = deserializeImage( currentUrl );\n\n\t\t\t\t\t\tif ( deserializedImage !== null ) {\n\n\t\t\t\t\t\t\tif ( deserializedImage instanceof HTMLImageElement ) {\n\n\t\t\t\t\t\t\t\timageArray.push( deserializedImage );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// special case: handle array of data textures for cube textures\n\n\t\t\t\t\t\t\t\timageArray.push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\timages[ image.uuid ] = new Source( imageArray );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// load single image\n\n\t\t\t\t\tconst deserializedImage = deserializeImage( image.url );\n\t\t\t\t\timages[ image.uuid ] = new Source( deserializedImage );\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn images;\n\n\t}\n\n\tasync parseImagesAsync( json ) {\n\n\t\tconst scope = this;\n\t\tconst images = {};\n\n\t\tlet loader;\n\n\t\tasync function deserializeImage( image ) {\n\n\t\t\tif ( typeof image === 'string' ) {\n\n\t\t\t\tconst url = image;\n\n\t\t\t\tconst path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( url ) ? url : scope.resourcePath + url;\n\n\t\t\t\treturn await loader.loadAsync( path );\n\n\t\t\t} else {\n\n\t\t\t\tif ( image.data ) {\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdata: getTypedArray( image.type, image.data ),\n\t\t\t\t\t\twidth: image.width,\n\t\t\t\t\t\theight: image.height\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( json !== undefined && json.length > 0 ) {\n\n\t\t\tloader = new ImageLoader( this.manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\tfor ( let i = 0, il = json.length; i < il; i ++ ) {\n\n\t\t\t\tconst image = json[ i ];\n\t\t\t\tconst url = image.url;\n\n\t\t\t\tif ( Array.isArray( url ) ) {\n\n\t\t\t\t\t// load array of images e.g CubeTexture\n\n\t\t\t\t\tconst imageArray = [];\n\n\t\t\t\t\tfor ( let j = 0, jl = url.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tconst currentUrl = url[ j ];\n\n\t\t\t\t\t\tconst deserializedImage = await deserializeImage( currentUrl );\n\n\t\t\t\t\t\tif ( deserializedImage !== null ) {\n\n\t\t\t\t\t\t\tif ( deserializedImage instanceof HTMLImageElement ) {\n\n\t\t\t\t\t\t\t\timageArray.push( deserializedImage );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// special case: handle array of data textures for cube textures\n\n\t\t\t\t\t\t\t\timageArray.push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\timages[ image.uuid ] = new Source( imageArray );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// load single image\n\n\t\t\t\t\tconst deserializedImage = await deserializeImage( image.url );\n\t\t\t\t\timages[ image.uuid ] = new Source( deserializedImage );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn images;\n\n\t}\n\n\tparseTextures( json, images ) {\n\n\t\tfunction parseConstant( value, type ) {\n\n\t\t\tif ( typeof value === 'number' ) return value;\n\n\t\t\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\n\n\t\t\treturn type[ value ];\n\n\t\t}\n\n\t\tconst textures = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tif ( data.image === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\n\n\t\t\t\t}\n\n\t\t\t\tif ( images[ data.image ] === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\n\n\t\t\t\t}\n\n\t\t\t\tconst source = images[ data.image ];\n\t\t\t\tconst image = source.data;\n\n\t\t\t\tlet texture;\n\n\t\t\t\tif ( Array.isArray( image ) ) {\n\n\t\t\t\t\ttexture = new CubeTexture();\n\n\t\t\t\t\tif ( image.length === 6 ) texture.needsUpdate = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( image && image.data ) {\n\n\t\t\t\t\t\ttexture = new DataTexture();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttexture = new Texture();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( image ) texture.needsUpdate = true; // textures can have undefined image data\n\n\t\t\t\t}\n\n\t\t\t\ttexture.source = source;\n\n\t\t\t\ttexture.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\n\n\t\t\t\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );\n\n\t\t\t\tif ( data.offset !== undefined ) texture.offset.fromArray( data.offset );\n\t\t\t\tif ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );\n\t\t\t\tif ( data.center !== undefined ) texture.center.fromArray( data.center );\n\t\t\t\tif ( data.rotation !== undefined ) texture.rotation = data.rotation;\n\n\t\t\t\tif ( data.wrap !== undefined ) {\n\n\t\t\t\t\ttexture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );\n\t\t\t\t\ttexture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.format !== undefined ) texture.format = data.format;\n\t\t\t\tif ( data.type !== undefined ) texture.type = data.type;\n\t\t\t\tif ( data.encoding !== undefined ) texture.encoding = data.encoding;\n\n\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );\n\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );\n\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\n\n\t\t\t\tif ( data.flipY !== undefined ) texture.flipY = data.flipY;\n\n\t\t\t\tif ( data.premultiplyAlpha !== undefined ) texture.premultiplyAlpha = data.premultiplyAlpha;\n\t\t\t\tif ( data.unpackAlignment !== undefined ) texture.unpackAlignment = data.unpackAlignment;\n\n\t\t\t\tif ( data.userData !== undefined ) texture.userData = data.userData;\n\n\t\t\t\ttextures[ data.uuid ] = texture;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn textures;\n\n\t}\n\n\tparseObject( data, geometries, materials, textures, animations ) {\n\n\t\tlet object;\n\n\t\tfunction getGeometry( name ) {\n\n\t\t\tif ( geometries[ name ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\n\n\t\t\t}\n\n\t\t\treturn geometries[ name ];\n\n\t\t}\n\n\t\tfunction getMaterial( name ) {\n\n\t\t\tif ( name === undefined ) return undefined;\n\n\t\t\tif ( Array.isArray( name ) ) {\n\n\t\t\t\tconst array = [];\n\n\t\t\t\tfor ( let i = 0, l = name.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst uuid = name[ i ];\n\n\t\t\t\t\tif ( materials[ uuid ] === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', uuid );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tarray.push( materials[ uuid ] );\n\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\n\t\t\t}\n\n\t\t\tif ( materials[ name ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\n\n\t\t\t}\n\n\t\t\treturn materials[ name ];\n\n\t\t}\n\n\t\tfunction getTexture( uuid ) {\n\n\t\t\tif ( textures[ uuid ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined texture', uuid );\n\n\t\t\t}\n\n\t\t\treturn textures[ uuid ];\n\n\t\t}\n\n\t\tlet geometry, material;\n\n\t\tswitch ( data.type ) {\n\n\t\t\tcase 'Scene':\n\n\t\t\t\tobject = new Scene();\n\n\t\t\t\tif ( data.background !== undefined ) {\n\n\t\t\t\t\tif ( Number.isInteger( data.background ) ) {\n\n\t\t\t\t\t\tobject.background = new Color( data.background );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tobject.background = getTexture( data.background );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.environment !== undefined ) {\n\n\t\t\t\t\tobject.environment = getTexture( data.environment );\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.fog !== undefined ) {\n\n\t\t\t\t\tif ( data.fog.type === 'Fog' ) {\n\n\t\t\t\t\t\tobject.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );\n\n\t\t\t\t\t} else if ( data.fog.type === 'FogExp2' ) {\n\n\t\t\t\t\t\tobject.fog = new FogExp2( data.fog.color, data.fog.density );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.backgroundBlurriness !== undefined ) object.backgroundBlurriness = data.backgroundBlurriness;\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'PerspectiveCamera':\n\n\t\t\t\tobject = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\n\n\t\t\t\tif ( data.focus !== undefined ) object.focus = data.focus;\n\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\n\t\t\t\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\n\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'OrthographicCamera':\n\n\t\t\t\tobject = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\n\n\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'AmbientLight':\n\n\t\t\t\tobject = new AmbientLight( data.color, data.intensity );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'DirectionalLight':\n\n\t\t\t\tobject = new DirectionalLight( data.color, data.intensity );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'PointLight':\n\n\t\t\t\tobject = new PointLight( data.color, data.intensity, data.distance, data.decay );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'RectAreaLight':\n\n\t\t\t\tobject = new RectAreaLight( data.color, data.intensity, data.width, data.height );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'SpotLight':\n\n\t\t\t\tobject = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'HemisphereLight':\n\n\t\t\t\tobject = new HemisphereLight( data.color, data.groundColor, data.intensity );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LightProbe':\n\n\t\t\t\tobject = new LightProbe().fromJSON( data );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'SkinnedMesh':\n\n\t\t\t\tgeometry = getGeometry( data.geometry );\n\t\t\t \tmaterial = getMaterial( data.material );\n\n\t\t\t\tobject = new SkinnedMesh( geometry, material );\n\n\t\t\t\tif ( data.bindMode !== undefined ) object.bindMode = data.bindMode;\n\t\t\t\tif ( data.bindMatrix !== undefined ) object.bindMatrix.fromArray( data.bindMatrix );\n\t\t\t\tif ( data.skeleton !== undefined ) object.skeleton = data.skeleton;\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Mesh':\n\n\t\t\t\tgeometry = getGeometry( data.geometry );\n\t\t\t\tmaterial = getMaterial( data.material );\n\n\t\t\t\tobject = new Mesh( geometry, material );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'InstancedMesh':\n\n\t\t\t\tgeometry = getGeometry( data.geometry );\n\t\t\t\tmaterial = getMaterial( data.material );\n\t\t\t\tconst count = data.count;\n\t\t\t\tconst instanceMatrix = data.instanceMatrix;\n\t\t\t\tconst instanceColor = data.instanceColor;\n\n\t\t\t\tobject = new InstancedMesh( geometry, material, count );\n\t\t\t\tobject.instanceMatrix = new InstancedBufferAttribute( new Float32Array( instanceMatrix.array ), 16 );\n\t\t\t\tif ( instanceColor !== undefined ) object.instanceColor = new InstancedBufferAttribute( new Float32Array( instanceColor.array ), instanceColor.itemSize );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LOD':\n\n\t\t\t\tobject = new LOD();\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Line':\n\n\t\t\t\tobject = new Line( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LineLoop':\n\n\t\t\t\tobject = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LineSegments':\n\n\t\t\t\tobject = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'PointCloud':\n\t\t\tcase 'Points':\n\n\t\t\t\tobject = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Sprite':\n\n\t\t\t\tobject = new Sprite( getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Group':\n\n\t\t\t\tobject = new Group();\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Bone':\n\n\t\t\t\tobject = new Bone();\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tobject = new Object3D();\n\n\t\t}\n\n\t\tobject.uuid = data.uuid;\n\n\t\tif ( data.name !== undefined ) object.name = data.name;\n\n\t\tif ( data.matrix !== undefined ) {\n\n\t\t\tobject.matrix.fromArray( data.matrix );\n\n\t\t\tif ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate;\n\t\t\tif ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t} else {\n\n\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\n\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\n\t\t\tif ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );\n\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\n\n\t\t}\n\n\t\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\n\t\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\n\n\t\tif ( data.shadow ) {\n\n\t\t\tif ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;\n\t\t\tif ( data.shadow.normalBias !== undefined ) object.shadow.normalBias = data.shadow.normalBias;\n\t\t\tif ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;\n\t\t\tif ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );\n\t\t\tif ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );\n\n\t\t}\n\n\t\tif ( data.visible !== undefined ) object.visible = data.visible;\n\t\tif ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled;\n\t\tif ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder;\n\t\tif ( data.userData !== undefined ) object.userData = data.userData;\n\t\tif ( data.layers !== undefined ) object.layers.mask = data.layers;\n\n\t\tif ( data.children !== undefined ) {\n\n\t\t\tconst children = data.children;\n\n\t\t\tfor ( let i = 0; i < children.length; i ++ ) {\n\n\t\t\t\tobject.add( this.parseObject( children[ i ], geometries, materials, textures, animations ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( data.animations !== undefined ) {\n\n\t\t\tconst objectAnimations = data.animations;\n\n\t\t\tfor ( let i = 0; i < objectAnimations.length; i ++ ) {\n\n\t\t\t\tconst uuid = objectAnimations[ i ];\n\n\t\t\t\tobject.animations.push( animations[ uuid ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( data.type === 'LOD' ) {\n\n\t\t\tif ( data.autoUpdate !== undefined ) object.autoUpdate = data.autoUpdate;\n\n\t\t\tconst levels = data.levels;\n\n\t\t\tfor ( let l = 0; l < levels.length; l ++ ) {\n\n\t\t\t\tconst level = levels[ l ];\n\t\t\t\tconst child = object.getObjectByProperty( 'uuid', level.object );\n\n\t\t\t\tif ( child !== undefined ) {\n\n\t\t\t\t\tobject.addLevel( child, level.distance, level.hysteresis );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn object;\n\n\t}\n\n\tbindSkeletons( object, skeletons ) {\n\n\t\tif ( Object.keys( skeletons ).length === 0 ) return;\n\n\t\tobject.traverse( function ( child ) {\n\n\t\t\tif ( child.isSkinnedMesh === true && child.skeleton !== undefined ) {\n\n\t\t\t\tconst skeleton = skeletons[ child.skeleton ];\n\n\t\t\t\tif ( skeleton === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tchild.bind( skeleton, child.bindMatrix );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n}\n\nconst TEXTURE_MAPPING = {\n\tUVMapping: UVMapping,\n\tCubeReflectionMapping: CubeReflectionMapping,\n\tCubeRefractionMapping: CubeRefractionMapping,\n\tEquirectangularReflectionMapping: EquirectangularReflectionMapping,\n\tEquirectangularRefractionMapping: EquirectangularRefractionMapping,\n\tCubeUVReflectionMapping: CubeUVReflectionMapping\n};\n\nconst TEXTURE_WRAPPING = {\n\tRepeatWrapping: RepeatWrapping,\n\tClampToEdgeWrapping: ClampToEdgeWrapping,\n\tMirroredRepeatWrapping: MirroredRepeatWrapping\n};\n\nconst TEXTURE_FILTER = {\n\tNearestFilter: NearestFilter,\n\tNearestMipmapNearestFilter: NearestMipmapNearestFilter,\n\tNearestMipmapLinearFilter: NearestMipmapLinearFilter,\n\tLinearFilter: LinearFilter,\n\tLinearMipmapNearestFilter: LinearMipmapNearestFilter,\n\tLinearMipmapLinearFilter: LinearMipmapLinearFilter\n};\n\nexport { ObjectLoader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}