{"ast":null,"code":"import { Cache } from './Cache.js';\nimport { Loader } from './Loader.js';\nconst loading = {};\nclass HttpError extends Error {\n  constructor(message, response) {\n    super(message);\n    this.response = response;\n  }\n}\nclass FileLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    if (url === undefined) url = '';\n    if (this.path !== undefined) url = this.path + url;\n    url = this.manager.resolveURL(url);\n    const cached = Cache.get(url);\n    if (cached !== undefined) {\n      this.manager.itemStart(url);\n      setTimeout(() => {\n        if (onLoad) onLoad(cached);\n        this.manager.itemEnd(url);\n      }, 0);\n      return cached;\n    }\n\n    // Check if request is duplicate\n\n    if (loading[url] !== undefined) {\n      loading[url].push({\n        onLoad: onLoad,\n        onProgress: onProgress,\n        onError: onError\n      });\n      return;\n    }\n\n    // Initialise array for duplicate requests\n    loading[url] = [];\n    loading[url].push({\n      onLoad: onLoad,\n      onProgress: onProgress,\n      onError: onError\n    });\n\n    // create request\n    const req = new Request(url, {\n      headers: new Headers(this.requestHeader),\n      credentials: this.withCredentials ? 'include' : 'same-origin'\n      // An abort controller could be added within a future PR\n    });\n\n    // record states ( avoid data race )\n    const mimeType = this.mimeType;\n    const responseType = this.responseType;\n\n    // start the fetch\n    fetch(req).then(response => {\n      if (response.status === 200 || response.status === 0) {\n        // Some browsers return HTTP Status 0 when using non-http protocol\n        // e.g. 'file://' or 'data://'. Handle as success.\n\n        if (response.status === 0) {\n          console.warn('THREE.FileLoader: HTTP Status 0 received.');\n        }\n\n        // Workaround: Checking if response.body === undefined for Alipay browser #23548\n\n        if (typeof ReadableStream === 'undefined' || response.body === undefined || response.body.getReader === undefined) {\n          return response;\n        }\n        const callbacks = loading[url];\n        const reader = response.body.getReader();\n\n        // Nginx needs X-File-Size check\n        // https://serverfault.com/questions/482875/why-does-nginx-remove-content-length-header-for-chunked-content\n        const contentLength = response.headers.get('Content-Length') || response.headers.get('X-File-Size');\n        const total = contentLength ? parseInt(contentLength) : 0;\n        const lengthComputable = total !== 0;\n        let loaded = 0;\n\n        // periodically read data into the new stream tracking while download progress\n        const stream = new ReadableStream({\n          start(controller) {\n            readData();\n            function readData() {\n              reader.read().then(_ref => {\n                let {\n                  done,\n                  value\n                } = _ref;\n                if (done) {\n                  controller.close();\n                } else {\n                  loaded += value.byteLength;\n                  const event = new ProgressEvent('progress', {\n                    lengthComputable,\n                    loaded,\n                    total\n                  });\n                  for (let i = 0, il = callbacks.length; i < il; i++) {\n                    const callback = callbacks[i];\n                    if (callback.onProgress) callback.onProgress(event);\n                  }\n                  controller.enqueue(value);\n                  readData();\n                }\n              });\n            }\n          }\n        });\n        return new Response(stream);\n      } else {\n        throw new HttpError(`fetch for \"${response.url}\" responded with ${response.status}: ${response.statusText}`, response);\n      }\n    }).then(response => {\n      switch (responseType) {\n        case 'arraybuffer':\n          return response.arrayBuffer();\n        case 'blob':\n          return response.blob();\n        case 'document':\n          return response.text().then(text => {\n            const parser = new DOMParser();\n            return parser.parseFromString(text, mimeType);\n          });\n        case 'json':\n          return response.json();\n        default:\n          if (mimeType === undefined) {\n            return response.text();\n          } else {\n            // sniff encoding\n            const re = /charset=\"?([^;\"\\s]*)\"?/i;\n            const exec = re.exec(mimeType);\n            const label = exec && exec[1] ? exec[1].toLowerCase() : undefined;\n            const decoder = new TextDecoder(label);\n            return response.arrayBuffer().then(ab => decoder.decode(ab));\n          }\n      }\n    }).then(data => {\n      // Add to cache only on HTTP success, so that we do not cache\n      // error response bodies as proper responses to requests.\n      Cache.add(url, data);\n      const callbacks = loading[url];\n      delete loading[url];\n      for (let i = 0, il = callbacks.length; i < il; i++) {\n        const callback = callbacks[i];\n        if (callback.onLoad) callback.onLoad(data);\n      }\n    }).catch(err => {\n      // Abort errors and other errors are handled the same\n\n      const callbacks = loading[url];\n      if (callbacks === undefined) {\n        // When onLoad was called and url was deleted in `loading`\n        this.manager.itemError(url);\n        throw err;\n      }\n      delete loading[url];\n      for (let i = 0, il = callbacks.length; i < il; i++) {\n        const callback = callbacks[i];\n        if (callback.onError) callback.onError(err);\n      }\n      this.manager.itemError(url);\n    }).finally(() => {\n      this.manager.itemEnd(url);\n    });\n    this.manager.itemStart(url);\n  }\n  setResponseType(value) {\n    this.responseType = value;\n    return this;\n  }\n  setMimeType(value) {\n    this.mimeType = value;\n    return this;\n  }\n}\nexport { FileLoader };","map":{"version":3,"names":["Cache","Loader","loading","HttpError","Error","constructor","message","response","FileLoader","manager","load","url","onLoad","onProgress","onError","undefined","path","resolveURL","cached","get","itemStart","setTimeout","itemEnd","push","req","Request","headers","Headers","requestHeader","credentials","withCredentials","mimeType","responseType","fetch","then","status","console","warn","ReadableStream","body","getReader","callbacks","reader","contentLength","total","parseInt","lengthComputable","loaded","stream","start","controller","readData","read","done","value","close","byteLength","event","ProgressEvent","i","il","length","callback","enqueue","Response","statusText","arrayBuffer","blob","text","parser","DOMParser","parseFromString","json","re","exec","label","toLowerCase","decoder","TextDecoder","ab","decode","data","add","catch","err","itemError","finally","setResponseType","setMimeType"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/loaders/FileLoader.js"],"sourcesContent":["import { Cache } from './Cache.js';\nimport { Loader } from './Loader.js';\n\nconst loading = {};\n\nclass HttpError extends Error {\n\n\tconstructor( message, response ) {\n\n\t\tsuper( message );\n\t\tthis.response = response;\n\n\t}\n\n}\n\nclass FileLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tif ( url === undefined ) url = '';\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\turl = this.manager.resolveURL( url );\n\n\t\tconst cached = Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tthis.manager.itemStart( url );\n\n\t\t\tsetTimeout( () => {\n\n\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\tthis.manager.itemEnd( url );\n\n\t\t\t}, 0 );\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\t// Check if request is duplicate\n\n\t\tif ( loading[ url ] !== undefined ) {\n\n\t\t\tloading[ url ].push( {\n\n\t\t\t\tonLoad: onLoad,\n\t\t\t\tonProgress: onProgress,\n\t\t\t\tonError: onError\n\n\t\t\t} );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// Initialise array for duplicate requests\n\t\tloading[ url ] = [];\n\n\t\tloading[ url ].push( {\n\t\t\tonLoad: onLoad,\n\t\t\tonProgress: onProgress,\n\t\t\tonError: onError,\n\t\t} );\n\n\t\t// create request\n\t\tconst req = new Request( url, {\n\t\t\theaders: new Headers( this.requestHeader ),\n\t\t\tcredentials: this.withCredentials ? 'include' : 'same-origin',\n\t\t\t// An abort controller could be added within a future PR\n\t\t} );\n\n\t\t// record states ( avoid data race )\n\t\tconst mimeType = this.mimeType;\n\t\tconst responseType = this.responseType;\n\n\t\t// start the fetch\n\t\tfetch( req )\n\t\t\t.then( response => {\n\n\t\t\t\tif ( response.status === 200 || response.status === 0 ) {\n\n\t\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\n\t\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\n\n\t\t\t\t\tif ( response.status === 0 ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.FileLoader: HTTP Status 0 received.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Workaround: Checking if response.body === undefined for Alipay browser #23548\n\n\t\t\t\t\tif ( typeof ReadableStream === 'undefined' || response.body === undefined || response.body.getReader === undefined ) {\n\n\t\t\t\t\t\treturn response;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst callbacks = loading[ url ];\n\t\t\t\t\tconst reader = response.body.getReader();\n\n\t\t\t\t\t// Nginx needs X-File-Size check\n\t\t\t\t\t// https://serverfault.com/questions/482875/why-does-nginx-remove-content-length-header-for-chunked-content\n\t\t\t\t\tconst contentLength = response.headers.get( 'Content-Length' ) || response.headers.get( 'X-File-Size' );\n\t\t\t\t\tconst total = contentLength ? parseInt( contentLength ) : 0;\n\t\t\t\t\tconst lengthComputable = total !== 0;\n\t\t\t\t\tlet loaded = 0;\n\n\t\t\t\t\t// periodically read data into the new stream tracking while download progress\n\t\t\t\t\tconst stream = new ReadableStream( {\n\t\t\t\t\t\tstart( controller ) {\n\n\t\t\t\t\t\t\treadData();\n\n\t\t\t\t\t\t\tfunction readData() {\n\n\t\t\t\t\t\t\t\treader.read().then( ( { done, value } ) => {\n\n\t\t\t\t\t\t\t\t\tif ( done ) {\n\n\t\t\t\t\t\t\t\t\t\tcontroller.close();\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tloaded += value.byteLength;\n\n\t\t\t\t\t\t\t\t\t\tconst event = new ProgressEvent( 'progress', { lengthComputable, loaded, total } );\n\t\t\t\t\t\t\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\t\t\t\t\t\t\tif ( callback.onProgress ) callback.onProgress( event );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tcontroller.enqueue( value );\n\t\t\t\t\t\t\t\t\t\treadData();\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t\treturn new Response( stream );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new HttpError( `fetch for \"${response.url}\" responded with ${response.status}: ${response.statusText}`, response );\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.then( response => {\n\n\t\t\t\tswitch ( responseType ) {\n\n\t\t\t\t\tcase 'arraybuffer':\n\n\t\t\t\t\t\treturn response.arrayBuffer();\n\n\t\t\t\t\tcase 'blob':\n\n\t\t\t\t\t\treturn response.blob();\n\n\t\t\t\t\tcase 'document':\n\n\t\t\t\t\t\treturn response.text()\n\t\t\t\t\t\t\t.then( text => {\n\n\t\t\t\t\t\t\t\tconst parser = new DOMParser();\n\t\t\t\t\t\t\t\treturn parser.parseFromString( text, mimeType );\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\tcase 'json':\n\n\t\t\t\t\t\treturn response.json();\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tif ( mimeType === undefined ) {\n\n\t\t\t\t\t\t\treturn response.text();\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// sniff encoding\n\t\t\t\t\t\t\tconst re = /charset=\"?([^;\"\\s]*)\"?/i;\n\t\t\t\t\t\t\tconst exec = re.exec( mimeType );\n\t\t\t\t\t\t\tconst label = exec && exec[ 1 ] ? exec[ 1 ].toLowerCase() : undefined;\n\t\t\t\t\t\t\tconst decoder = new TextDecoder( label );\n\t\t\t\t\t\t\treturn response.arrayBuffer().then( ab => decoder.decode( ab ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.then( data => {\n\n\t\t\t\t// Add to cache only on HTTP success, so that we do not cache\n\t\t\t\t// error response bodies as proper responses to requests.\n\t\t\t\tCache.add( url, data );\n\n\t\t\t\tconst callbacks = loading[ url ];\n\t\t\t\tdelete loading[ url ];\n\n\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\tif ( callback.onLoad ) callback.onLoad( data );\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.catch( err => {\n\n\t\t\t\t// Abort errors and other errors are handled the same\n\n\t\t\t\tconst callbacks = loading[ url ];\n\n\t\t\t\tif ( callbacks === undefined ) {\n\n\t\t\t\t\t// When onLoad was called and url was deleted in `loading`\n\t\t\t\t\tthis.manager.itemError( url );\n\t\t\t\t\tthrow err;\n\n\t\t\t\t}\n\n\t\t\t\tdelete loading[ url ];\n\n\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\tif ( callback.onError ) callback.onError( err );\n\n\t\t\t\t}\n\n\t\t\t\tthis.manager.itemError( url );\n\n\t\t\t} )\n\t\t\t.finally( () => {\n\n\t\t\t\tthis.manager.itemEnd( url );\n\n\t\t\t} );\n\n\t\tthis.manager.itemStart( url );\n\n\t}\n\n\tsetResponseType( value ) {\n\n\t\tthis.responseType = value;\n\t\treturn this;\n\n\t}\n\n\tsetMimeType( value ) {\n\n\t\tthis.mimeType = value;\n\t\treturn this;\n\n\t}\n\n}\n\n\nexport { FileLoader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}