{"ast":null,"code":"import { ArrayCamera } from '../../cameras/ArrayCamera.js';\nimport { EventDispatcher } from '../../core/EventDispatcher.js';\nimport { PerspectiveCamera } from '../../cameras/PerspectiveCamera.js';\nimport { Vector3 } from '../../math/Vector3.js';\nimport { Vector4 } from '../../math/Vector4.js';\nimport { WebGLAnimation } from '../webgl/WebGLAnimation.js';\nimport { WebGLRenderTarget } from '../WebGLRenderTarget.js';\nimport { WebXRController } from './WebXRController.js';\nimport { DepthTexture } from '../../textures/DepthTexture.js';\nimport { DepthFormat, DepthStencilFormat, RGBAFormat, UnsignedByteType, UnsignedIntType, UnsignedInt248Type } from '../../constants.js';\nclass WebXRManager extends EventDispatcher {\n  constructor(renderer, gl) {\n    super();\n    const scope = this;\n    let session = null;\n    let framebufferScaleFactor = 1.0;\n    let referenceSpace = null;\n    let referenceSpaceType = 'local-floor';\n    let customReferenceSpace = null;\n    let pose = null;\n    let glBinding = null;\n    let glProjLayer = null;\n    let glBaseLayer = null;\n    let xrFrame = null;\n    const attributes = gl.getContextAttributes();\n    let initialRenderTarget = null;\n    let newRenderTarget = null;\n    const controllers = [];\n    const controllerInputSources = [];\n    const planes = new Set();\n    const planesLastChangedTimes = new Map();\n\n    //\n\n    const cameraL = new PerspectiveCamera();\n    cameraL.layers.enable(1);\n    cameraL.viewport = new Vector4();\n    const cameraR = new PerspectiveCamera();\n    cameraR.layers.enable(2);\n    cameraR.viewport = new Vector4();\n    const cameras = [cameraL, cameraR];\n    const cameraVR = new ArrayCamera();\n    cameraVR.layers.enable(1);\n    cameraVR.layers.enable(2);\n    let _currentDepthNear = null;\n    let _currentDepthFar = null;\n\n    //\n\n    this.cameraAutoUpdate = true;\n    this.enabled = false;\n    this.isPresenting = false;\n    this.getController = function (index) {\n      let controller = controllers[index];\n      if (controller === undefined) {\n        controller = new WebXRController();\n        controllers[index] = controller;\n      }\n      return controller.getTargetRaySpace();\n    };\n    this.getControllerGrip = function (index) {\n      let controller = controllers[index];\n      if (controller === undefined) {\n        controller = new WebXRController();\n        controllers[index] = controller;\n      }\n      return controller.getGripSpace();\n    };\n    this.getHand = function (index) {\n      let controller = controllers[index];\n      if (controller === undefined) {\n        controller = new WebXRController();\n        controllers[index] = controller;\n      }\n      return controller.getHandSpace();\n    };\n\n    //\n\n    function onSessionEvent(event) {\n      const controllerIndex = controllerInputSources.indexOf(event.inputSource);\n      if (controllerIndex === -1) {\n        return;\n      }\n      const controller = controllers[controllerIndex];\n      if (controller !== undefined) {\n        controller.dispatchEvent({\n          type: event.type,\n          data: event.inputSource\n        });\n      }\n    }\n    function onSessionEnd() {\n      session.removeEventListener('select', onSessionEvent);\n      session.removeEventListener('selectstart', onSessionEvent);\n      session.removeEventListener('selectend', onSessionEvent);\n      session.removeEventListener('squeeze', onSessionEvent);\n      session.removeEventListener('squeezestart', onSessionEvent);\n      session.removeEventListener('squeezeend', onSessionEvent);\n      session.removeEventListener('end', onSessionEnd);\n      session.removeEventListener('inputsourceschange', onInputSourcesChange);\n      for (let i = 0; i < controllers.length; i++) {\n        const inputSource = controllerInputSources[i];\n        if (inputSource === null) continue;\n        controllerInputSources[i] = null;\n        controllers[i].disconnect(inputSource);\n      }\n      _currentDepthNear = null;\n      _currentDepthFar = null;\n\n      // restore framebuffer/rendering state\n\n      renderer.setRenderTarget(initialRenderTarget);\n      glBaseLayer = null;\n      glProjLayer = null;\n      glBinding = null;\n      session = null;\n      newRenderTarget = null;\n\n      //\n\n      animation.stop();\n      scope.isPresenting = false;\n      scope.dispatchEvent({\n        type: 'sessionend'\n      });\n    }\n    this.setFramebufferScaleFactor = function (value) {\n      framebufferScaleFactor = value;\n      if (scope.isPresenting === true) {\n        console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');\n      }\n    };\n    this.setReferenceSpaceType = function (value) {\n      referenceSpaceType = value;\n      if (scope.isPresenting === true) {\n        console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');\n      }\n    };\n    this.getReferenceSpace = function () {\n      return customReferenceSpace || referenceSpace;\n    };\n    this.setReferenceSpace = function (space) {\n      customReferenceSpace = space;\n    };\n    this.getBaseLayer = function () {\n      return glProjLayer !== null ? glProjLayer : glBaseLayer;\n    };\n    this.getBinding = function () {\n      return glBinding;\n    };\n    this.getFrame = function () {\n      return xrFrame;\n    };\n    this.getSession = function () {\n      return session;\n    };\n    this.setSession = async function (value) {\n      session = value;\n      if (session !== null) {\n        initialRenderTarget = renderer.getRenderTarget();\n        session.addEventListener('select', onSessionEvent);\n        session.addEventListener('selectstart', onSessionEvent);\n        session.addEventListener('selectend', onSessionEvent);\n        session.addEventListener('squeeze', onSessionEvent);\n        session.addEventListener('squeezestart', onSessionEvent);\n        session.addEventListener('squeezeend', onSessionEvent);\n        session.addEventListener('end', onSessionEnd);\n        session.addEventListener('inputsourceschange', onInputSourcesChange);\n        if (attributes.xrCompatible !== true) {\n          await gl.makeXRCompatible();\n        }\n        if (session.renderState.layers === undefined || renderer.capabilities.isWebGL2 === false) {\n          const layerInit = {\n            antialias: session.renderState.layers === undefined ? attributes.antialias : true,\n            alpha: attributes.alpha,\n            depth: attributes.depth,\n            stencil: attributes.stencil,\n            framebufferScaleFactor: framebufferScaleFactor\n          };\n          glBaseLayer = new XRWebGLLayer(session, gl, layerInit);\n          session.updateRenderState({\n            baseLayer: glBaseLayer\n          });\n          newRenderTarget = new WebGLRenderTarget(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, {\n            format: RGBAFormat,\n            type: UnsignedByteType,\n            encoding: renderer.outputEncoding,\n            stencilBuffer: attributes.stencil\n          });\n        } else {\n          let depthFormat = null;\n          let depthType = null;\n          let glDepthFormat = null;\n          if (attributes.depth) {\n            glDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;\n            depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;\n            depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;\n          }\n          const projectionlayerInit = {\n            colorFormat: gl.RGBA8,\n            depthFormat: glDepthFormat,\n            scaleFactor: framebufferScaleFactor\n          };\n          glBinding = new XRWebGLBinding(session, gl);\n          glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);\n          session.updateRenderState({\n            layers: [glProjLayer]\n          });\n          newRenderTarget = new WebGLRenderTarget(glProjLayer.textureWidth, glProjLayer.textureHeight, {\n            format: RGBAFormat,\n            type: UnsignedByteType,\n            depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat),\n            stencilBuffer: attributes.stencil,\n            encoding: renderer.outputEncoding,\n            samples: attributes.antialias ? 4 : 0\n          });\n          const renderTargetProperties = renderer.properties.get(newRenderTarget);\n          renderTargetProperties.__ignoreDepthValues = glProjLayer.ignoreDepthValues;\n        }\n        newRenderTarget.isXRRenderTarget = true; // TODO Remove this when possible, see #23278\n\n        // Set foveation to maximum.\n        this.setFoveation(1.0);\n        customReferenceSpace = null;\n        referenceSpace = await session.requestReferenceSpace(referenceSpaceType);\n        animation.setContext(session);\n        animation.start();\n        scope.isPresenting = true;\n        scope.dispatchEvent({\n          type: 'sessionstart'\n        });\n      }\n    };\n    function onInputSourcesChange(event) {\n      // Notify disconnected\n\n      for (let i = 0; i < event.removed.length; i++) {\n        const inputSource = event.removed[i];\n        const index = controllerInputSources.indexOf(inputSource);\n        if (index >= 0) {\n          controllerInputSources[index] = null;\n          controllers[index].disconnect(inputSource);\n        }\n      }\n\n      // Notify connected\n\n      for (let i = 0; i < event.added.length; i++) {\n        const inputSource = event.added[i];\n        let controllerIndex = controllerInputSources.indexOf(inputSource);\n        if (controllerIndex === -1) {\n          // Assign input source a controller that currently has no input source\n\n          for (let i = 0; i < controllers.length; i++) {\n            if (i >= controllerInputSources.length) {\n              controllerInputSources.push(inputSource);\n              controllerIndex = i;\n              break;\n            } else if (controllerInputSources[i] === null) {\n              controllerInputSources[i] = inputSource;\n              controllerIndex = i;\n              break;\n            }\n          }\n\n          // If all controllers do currently receive input we ignore new ones\n\n          if (controllerIndex === -1) break;\n        }\n        const controller = controllers[controllerIndex];\n        if (controller) {\n          controller.connect(inputSource);\n        }\n      }\n    }\n\n    //\n\n    const cameraLPos = new Vector3();\n    const cameraRPos = new Vector3();\n\n    /**\n     * Assumes 2 cameras that are parallel and share an X-axis, and that\n     * the cameras' projection and world matrices have already been set.\n     * And that near and far planes are identical for both cameras.\n     * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765\n     */\n    function setProjectionFromUnion(camera, cameraL, cameraR) {\n      cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);\n      cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);\n      const ipd = cameraLPos.distanceTo(cameraRPos);\n      const projL = cameraL.projectionMatrix.elements;\n      const projR = cameraR.projectionMatrix.elements;\n\n      // VR systems will have identical far and near planes, and\n      // most likely identical top and bottom frustum extents.\n      // Use the left camera for these values.\n      const near = projL[14] / (projL[10] - 1);\n      const far = projL[14] / (projL[10] + 1);\n      const topFov = (projL[9] + 1) / projL[5];\n      const bottomFov = (projL[9] - 1) / projL[5];\n      const leftFov = (projL[8] - 1) / projL[0];\n      const rightFov = (projR[8] + 1) / projR[0];\n      const left = near * leftFov;\n      const right = near * rightFov;\n\n      // Calculate the new camera's position offset from the\n      // left camera. xOffset should be roughly half `ipd`.\n      const zOffset = ipd / (-leftFov + rightFov);\n      const xOffset = zOffset * -leftFov;\n\n      // TODO: Better way to apply this offset?\n      cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);\n      camera.translateX(xOffset);\n      camera.translateZ(zOffset);\n      camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);\n      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();\n\n      // Find the union of the frustum values of the cameras and scale\n      // the values so that the near plane's position does not change in world space,\n      // although must now be relative to the new union camera.\n      const near2 = near + zOffset;\n      const far2 = far + zOffset;\n      const left2 = left - xOffset;\n      const right2 = right + (ipd - xOffset);\n      const top2 = topFov * far / far2 * near2;\n      const bottom2 = bottomFov * far / far2 * near2;\n      camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);\n    }\n    function updateCamera(camera, parent) {\n      if (parent === null) {\n        camera.matrixWorld.copy(camera.matrix);\n      } else {\n        camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);\n      }\n      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();\n    }\n    this.updateCamera = function (camera) {\n      if (session === null) return;\n      cameraVR.near = cameraR.near = cameraL.near = camera.near;\n      cameraVR.far = cameraR.far = cameraL.far = camera.far;\n      if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {\n        // Note that the new renderState won't apply until the next frame. See #18320\n\n        session.updateRenderState({\n          depthNear: cameraVR.near,\n          depthFar: cameraVR.far\n        });\n        _currentDepthNear = cameraVR.near;\n        _currentDepthFar = cameraVR.far;\n      }\n      const parent = camera.parent;\n      const cameras = cameraVR.cameras;\n      updateCamera(cameraVR, parent);\n      for (let i = 0; i < cameras.length; i++) {\n        updateCamera(cameras[i], parent);\n      }\n      cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale);\n\n      // update user camera and its children\n\n      camera.matrix.copy(cameraVR.matrix);\n      camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);\n      const children = camera.children;\n      for (let i = 0, l = children.length; i < l; i++) {\n        children[i].updateMatrixWorld(true);\n      }\n\n      // update projection matrix for proper view frustum culling\n\n      if (cameras.length === 2) {\n        setProjectionFromUnion(cameraVR, cameraL, cameraR);\n      } else {\n        // assume single camera setup (AR)\n\n        cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);\n      }\n    };\n    this.getCamera = function () {\n      return cameraVR;\n    };\n    this.getFoveation = function () {\n      if (glProjLayer !== null) {\n        return glProjLayer.fixedFoveation;\n      }\n      if (glBaseLayer !== null) {\n        return glBaseLayer.fixedFoveation;\n      }\n      return undefined;\n    };\n    this.setFoveation = function (foveation) {\n      // 0 = no foveation = full resolution\n      // 1 = maximum foveation = the edges render at lower resolution\n\n      if (glProjLayer !== null) {\n        glProjLayer.fixedFoveation = foveation;\n      }\n      if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined) {\n        glBaseLayer.fixedFoveation = foveation;\n      }\n    };\n    this.getPlanes = function () {\n      return planes;\n    };\n\n    // Animation Loop\n\n    let onAnimationFrameCallback = null;\n    function onAnimationFrame(time, frame) {\n      pose = frame.getViewerPose(customReferenceSpace || referenceSpace);\n      xrFrame = frame;\n      if (pose !== null) {\n        const views = pose.views;\n        if (glBaseLayer !== null) {\n          renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);\n          renderer.setRenderTarget(newRenderTarget);\n        }\n        let cameraVRNeedsUpdate = false;\n\n        // check if it's necessary to rebuild cameraVR's camera list\n\n        if (views.length !== cameraVR.cameras.length) {\n          cameraVR.cameras.length = 0;\n          cameraVRNeedsUpdate = true;\n        }\n        for (let i = 0; i < views.length; i++) {\n          const view = views[i];\n          let viewport = null;\n          if (glBaseLayer !== null) {\n            viewport = glBaseLayer.getViewport(view);\n          } else {\n            const glSubImage = glBinding.getViewSubImage(glProjLayer, view);\n            viewport = glSubImage.viewport;\n\n            // For side-by-side projection, we only produce a single texture for both eyes.\n            if (i === 0) {\n              renderer.setRenderTargetTextures(newRenderTarget, glSubImage.colorTexture, glProjLayer.ignoreDepthValues ? undefined : glSubImage.depthStencilTexture);\n              renderer.setRenderTarget(newRenderTarget);\n            }\n          }\n          let camera = cameras[i];\n          if (camera === undefined) {\n            camera = new PerspectiveCamera();\n            camera.layers.enable(i);\n            camera.viewport = new Vector4();\n            cameras[i] = camera;\n          }\n          camera.matrix.fromArray(view.transform.matrix);\n          camera.projectionMatrix.fromArray(view.projectionMatrix);\n          camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);\n          if (i === 0) {\n            cameraVR.matrix.copy(camera.matrix);\n          }\n          if (cameraVRNeedsUpdate === true) {\n            cameraVR.cameras.push(camera);\n          }\n        }\n      }\n\n      //\n\n      for (let i = 0; i < controllers.length; i++) {\n        const inputSource = controllerInputSources[i];\n        const controller = controllers[i];\n        if (inputSource !== null && controller !== undefined) {\n          controller.update(inputSource, frame, customReferenceSpace || referenceSpace);\n        }\n      }\n      if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);\n      if (frame.detectedPlanes) {\n        scope.dispatchEvent({\n          type: 'planesdetected',\n          data: frame.detectedPlanes\n        });\n        let planesToRemove = null;\n        for (const plane of planes) {\n          if (!frame.detectedPlanes.has(plane)) {\n            if (planesToRemove === null) {\n              planesToRemove = [];\n            }\n            planesToRemove.push(plane);\n          }\n        }\n        if (planesToRemove !== null) {\n          for (const plane of planesToRemove) {\n            planes.delete(plane);\n            planesLastChangedTimes.delete(plane);\n            scope.dispatchEvent({\n              type: 'planeremoved',\n              data: plane\n            });\n          }\n        }\n        for (const plane of frame.detectedPlanes) {\n          if (!planes.has(plane)) {\n            planes.add(plane);\n            planesLastChangedTimes.set(plane, frame.lastChangedTime);\n            scope.dispatchEvent({\n              type: 'planeadded',\n              data: plane\n            });\n          } else {\n            const lastKnownTime = planesLastChangedTimes.get(plane);\n            if (plane.lastChangedTime > lastKnownTime) {\n              planesLastChangedTimes.set(plane, plane.lastChangedTime);\n              scope.dispatchEvent({\n                type: 'planechanged',\n                data: plane\n              });\n            }\n          }\n        }\n      }\n      xrFrame = null;\n    }\n    const animation = new WebGLAnimation();\n    animation.setAnimationLoop(onAnimationFrame);\n    this.setAnimationLoop = function (callback) {\n      onAnimationFrameCallback = callback;\n    };\n    this.dispose = function () {};\n  }\n}\nexport { WebXRManager };","map":{"version":3,"names":["ArrayCamera","EventDispatcher","PerspectiveCamera","Vector3","Vector4","WebGLAnimation","WebGLRenderTarget","WebXRController","DepthTexture","DepthFormat","DepthStencilFormat","RGBAFormat","UnsignedByteType","UnsignedIntType","UnsignedInt248Type","WebXRManager","constructor","renderer","gl","scope","session","framebufferScaleFactor","referenceSpace","referenceSpaceType","customReferenceSpace","pose","glBinding","glProjLayer","glBaseLayer","xrFrame","attributes","getContextAttributes","initialRenderTarget","newRenderTarget","controllers","controllerInputSources","planes","Set","planesLastChangedTimes","Map","cameraL","layers","enable","viewport","cameraR","cameras","cameraVR","_currentDepthNear","_currentDepthFar","cameraAutoUpdate","enabled","isPresenting","getController","index","controller","undefined","getTargetRaySpace","getControllerGrip","getGripSpace","getHand","getHandSpace","onSessionEvent","event","controllerIndex","indexOf","inputSource","dispatchEvent","type","data","onSessionEnd","removeEventListener","onInputSourcesChange","i","length","disconnect","setRenderTarget","animation","stop","setFramebufferScaleFactor","value","console","warn","setReferenceSpaceType","getReferenceSpace","setReferenceSpace","space","getBaseLayer","getBinding","getFrame","getSession","setSession","getRenderTarget","addEventListener","xrCompatible","makeXRCompatible","renderState","capabilities","isWebGL2","layerInit","antialias","alpha","depth","stencil","XRWebGLLayer","updateRenderState","baseLayer","framebufferWidth","framebufferHeight","format","encoding","outputEncoding","stencilBuffer","depthFormat","depthType","glDepthFormat","DEPTH24_STENCIL8","DEPTH_COMPONENT24","projectionlayerInit","colorFormat","RGBA8","scaleFactor","XRWebGLBinding","createProjectionLayer","textureWidth","textureHeight","depthTexture","samples","renderTargetProperties","properties","get","__ignoreDepthValues","ignoreDepthValues","isXRRenderTarget","setFoveation","requestReferenceSpace","setContext","start","removed","added","push","connect","cameraLPos","cameraRPos","setProjectionFromUnion","camera","setFromMatrixPosition","matrixWorld","ipd","distanceTo","projL","projectionMatrix","elements","projR","near","far","topFov","bottomFov","leftFov","rightFov","left","right","zOffset","xOffset","decompose","position","quaternion","scale","translateX","translateZ","compose","matrixWorldInverse","copy","invert","near2","far2","left2","right2","top2","bottom2","makePerspective","updateCamera","parent","matrix","multiplyMatrices","depthNear","depthFar","children","l","updateMatrixWorld","getCamera","getFoveation","fixedFoveation","foveation","getPlanes","onAnimationFrameCallback","onAnimationFrame","time","frame","getViewerPose","views","setRenderTargetFramebuffer","framebuffer","cameraVRNeedsUpdate","view","getViewport","glSubImage","getViewSubImage","setRenderTargetTextures","colorTexture","depthStencilTexture","fromArray","transform","set","x","y","width","height","update","detectedPlanes","planesToRemove","plane","has","delete","add","lastChangedTime","lastKnownTime","setAnimationLoop","callback","dispose"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/renderers/webxr/WebXRManager.js"],"sourcesContent":["import { ArrayCamera } from '../../cameras/ArrayCamera.js';\nimport { EventDispatcher } from '../../core/EventDispatcher.js';\nimport { PerspectiveCamera } from '../../cameras/PerspectiveCamera.js';\nimport { Vector3 } from '../../math/Vector3.js';\nimport { Vector4 } from '../../math/Vector4.js';\nimport { WebGLAnimation } from '../webgl/WebGLAnimation.js';\nimport { WebGLRenderTarget } from '../WebGLRenderTarget.js';\nimport { WebXRController } from './WebXRController.js';\nimport { DepthTexture } from '../../textures/DepthTexture.js';\nimport {\n\tDepthFormat,\n\tDepthStencilFormat,\n\tRGBAFormat,\n\tUnsignedByteType,\n\tUnsignedIntType,\n\tUnsignedInt248Type,\n} from '../../constants.js';\n\nclass WebXRManager extends EventDispatcher {\n\n\tconstructor( renderer, gl ) {\n\n\t\tsuper();\n\n\t\tconst scope = this;\n\n\t\tlet session = null;\n\t\tlet framebufferScaleFactor = 1.0;\n\n\t\tlet referenceSpace = null;\n\t\tlet referenceSpaceType = 'local-floor';\n\t\tlet customReferenceSpace = null;\n\n\t\tlet pose = null;\n\t\tlet glBinding = null;\n\t\tlet glProjLayer = null;\n\t\tlet glBaseLayer = null;\n\t\tlet xrFrame = null;\n\t\tconst attributes = gl.getContextAttributes();\n\t\tlet initialRenderTarget = null;\n\t\tlet newRenderTarget = null;\n\n\t\tconst controllers = [];\n\t\tconst controllerInputSources = [];\n\n\t\tconst planes = new Set();\n\t\tconst planesLastChangedTimes = new Map();\n\n\t\t//\n\n\t\tconst cameraL = new PerspectiveCamera();\n\t\tcameraL.layers.enable( 1 );\n\t\tcameraL.viewport = new Vector4();\n\n\t\tconst cameraR = new PerspectiveCamera();\n\t\tcameraR.layers.enable( 2 );\n\t\tcameraR.viewport = new Vector4();\n\n\t\tconst cameras = [ cameraL, cameraR ];\n\n\t\tconst cameraVR = new ArrayCamera();\n\t\tcameraVR.layers.enable( 1 );\n\t\tcameraVR.layers.enable( 2 );\n\n\t\tlet _currentDepthNear = null;\n\t\tlet _currentDepthFar = null;\n\n\t\t//\n\n\t\tthis.cameraAutoUpdate = true;\n\t\tthis.enabled = false;\n\n\t\tthis.isPresenting = false;\n\n\t\tthis.getController = function ( index ) {\n\n\t\t\tlet controller = controllers[ index ];\n\n\t\t\tif ( controller === undefined ) {\n\n\t\t\t\tcontroller = new WebXRController();\n\t\t\t\tcontrollers[ index ] = controller;\n\n\t\t\t}\n\n\t\t\treturn controller.getTargetRaySpace();\n\n\t\t};\n\n\t\tthis.getControllerGrip = function ( index ) {\n\n\t\t\tlet controller = controllers[ index ];\n\n\t\t\tif ( controller === undefined ) {\n\n\t\t\t\tcontroller = new WebXRController();\n\t\t\t\tcontrollers[ index ] = controller;\n\n\t\t\t}\n\n\t\t\treturn controller.getGripSpace();\n\n\t\t};\n\n\t\tthis.getHand = function ( index ) {\n\n\t\t\tlet controller = controllers[ index ];\n\n\t\t\tif ( controller === undefined ) {\n\n\t\t\t\tcontroller = new WebXRController();\n\t\t\t\tcontrollers[ index ] = controller;\n\n\t\t\t}\n\n\t\t\treturn controller.getHandSpace();\n\n\t\t};\n\n\t\t//\n\n\t\tfunction onSessionEvent( event ) {\n\n\t\t\tconst controllerIndex = controllerInputSources.indexOf( event.inputSource );\n\n\t\t\tif ( controllerIndex === - 1 ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tconst controller = controllers[ controllerIndex ];\n\n\t\t\tif ( controller !== undefined ) {\n\n\t\t\t\tcontroller.dispatchEvent( { type: event.type, data: event.inputSource } );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onSessionEnd() {\n\n\t\t\tsession.removeEventListener( 'select', onSessionEvent );\n\t\t\tsession.removeEventListener( 'selectstart', onSessionEvent );\n\t\t\tsession.removeEventListener( 'selectend', onSessionEvent );\n\t\t\tsession.removeEventListener( 'squeeze', onSessionEvent );\n\t\t\tsession.removeEventListener( 'squeezestart', onSessionEvent );\n\t\t\tsession.removeEventListener( 'squeezeend', onSessionEvent );\n\t\t\tsession.removeEventListener( 'end', onSessionEnd );\n\t\t\tsession.removeEventListener( 'inputsourceschange', onInputSourcesChange );\n\n\t\t\tfor ( let i = 0; i < controllers.length; i ++ ) {\n\n\t\t\t\tconst inputSource = controllerInputSources[ i ];\n\n\t\t\t\tif ( inputSource === null ) continue;\n\n\t\t\t\tcontrollerInputSources[ i ] = null;\n\n\t\t\t\tcontrollers[ i ].disconnect( inputSource );\n\n\t\t\t}\n\n\t\t\t_currentDepthNear = null;\n\t\t\t_currentDepthFar = null;\n\n\t\t\t// restore framebuffer/rendering state\n\n\t\t\trenderer.setRenderTarget( initialRenderTarget );\n\n\t\t\tglBaseLayer = null;\n\t\t\tglProjLayer = null;\n\t\t\tglBinding = null;\n\t\t\tsession = null;\n\t\t\tnewRenderTarget = null;\n\n\t\t\t//\n\n\t\t\tanimation.stop();\n\n\t\t\tscope.isPresenting = false;\n\n\t\t\tscope.dispatchEvent( { type: 'sessionend' } );\n\n\t\t}\n\n\t\tthis.setFramebufferScaleFactor = function ( value ) {\n\n\t\t\tframebufferScaleFactor = value;\n\n\t\t\tif ( scope.isPresenting === true ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebXRManager: Cannot change framebuffer scale while presenting.' );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.setReferenceSpaceType = function ( value ) {\n\n\t\t\treferenceSpaceType = value;\n\n\t\t\tif ( scope.isPresenting === true ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebXRManager: Cannot change reference space type while presenting.' );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.getReferenceSpace = function () {\n\n\t\t\treturn customReferenceSpace || referenceSpace;\n\n\t\t};\n\n\t\tthis.setReferenceSpace = function ( space ) {\n\n\t\t\tcustomReferenceSpace = space;\n\n\t\t};\n\n\t\tthis.getBaseLayer = function () {\n\n\t\t\treturn glProjLayer !== null ? glProjLayer : glBaseLayer;\n\n\t\t};\n\n\t\tthis.getBinding = function () {\n\n\t\t\treturn glBinding;\n\n\t\t};\n\n\t\tthis.getFrame = function () {\n\n\t\t\treturn xrFrame;\n\n\t\t};\n\n\t\tthis.getSession = function () {\n\n\t\t\treturn session;\n\n\t\t};\n\n\t\tthis.setSession = async function ( value ) {\n\n\t\t\tsession = value;\n\n\t\t\tif ( session !== null ) {\n\n\t\t\t\tinitialRenderTarget = renderer.getRenderTarget();\n\n\t\t\t\tsession.addEventListener( 'select', onSessionEvent );\n\t\t\t\tsession.addEventListener( 'selectstart', onSessionEvent );\n\t\t\t\tsession.addEventListener( 'selectend', onSessionEvent );\n\t\t\t\tsession.addEventListener( 'squeeze', onSessionEvent );\n\t\t\t\tsession.addEventListener( 'squeezestart', onSessionEvent );\n\t\t\t\tsession.addEventListener( 'squeezeend', onSessionEvent );\n\t\t\t\tsession.addEventListener( 'end', onSessionEnd );\n\t\t\t\tsession.addEventListener( 'inputsourceschange', onInputSourcesChange );\n\n\t\t\t\tif ( attributes.xrCompatible !== true ) {\n\n\t\t\t\t\tawait gl.makeXRCompatible();\n\n\t\t\t\t}\n\n\t\t\t\tif ( ( session.renderState.layers === undefined ) || ( renderer.capabilities.isWebGL2 === false ) ) {\n\n\t\t\t\t\tconst layerInit = {\n\t\t\t\t\t\tantialias: ( session.renderState.layers === undefined ) ? attributes.antialias : true,\n\t\t\t\t\t\talpha: attributes.alpha,\n\t\t\t\t\t\tdepth: attributes.depth,\n\t\t\t\t\t\tstencil: attributes.stencil,\n\t\t\t\t\t\tframebufferScaleFactor: framebufferScaleFactor\n\t\t\t\t\t};\n\n\t\t\t\t\tglBaseLayer = new XRWebGLLayer( session, gl, layerInit );\n\n\t\t\t\t\tsession.updateRenderState( { baseLayer: glBaseLayer } );\n\n\t\t\t\t\tnewRenderTarget = new WebGLRenderTarget(\n\t\t\t\t\t\tglBaseLayer.framebufferWidth,\n\t\t\t\t\t\tglBaseLayer.framebufferHeight,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tformat: RGBAFormat,\n\t\t\t\t\t\t\ttype: UnsignedByteType,\n\t\t\t\t\t\t\tencoding: renderer.outputEncoding,\n\t\t\t\t\t\t\tstencilBuffer: attributes.stencil\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlet depthFormat = null;\n\t\t\t\t\tlet depthType = null;\n\t\t\t\t\tlet glDepthFormat = null;\n\n\t\t\t\t\tif ( attributes.depth ) {\n\n\t\t\t\t\t\tglDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;\n\t\t\t\t\t\tdepthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;\n\t\t\t\t\t\tdepthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst projectionlayerInit = {\n\t\t\t\t\t\tcolorFormat: gl.RGBA8,\n\t\t\t\t\t\tdepthFormat: glDepthFormat,\n\t\t\t\t\t\tscaleFactor: framebufferScaleFactor\n\t\t\t\t\t};\n\n\t\t\t\t\tglBinding = new XRWebGLBinding( session, gl );\n\n\t\t\t\t\tglProjLayer = glBinding.createProjectionLayer( projectionlayerInit );\n\n\t\t\t\t\tsession.updateRenderState( { layers: [ glProjLayer ] } );\n\n\t\t\t\t\tnewRenderTarget = new WebGLRenderTarget(\n\t\t\t\t\t\tglProjLayer.textureWidth,\n\t\t\t\t\t\tglProjLayer.textureHeight,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tformat: RGBAFormat,\n\t\t\t\t\t\t\ttype: UnsignedByteType,\n\t\t\t\t\t\t\tdepthTexture: new DepthTexture( glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat ),\n\t\t\t\t\t\t\tstencilBuffer: attributes.stencil,\n\t\t\t\t\t\t\tencoding: renderer.outputEncoding,\n\t\t\t\t\t\t\tsamples: attributes.antialias ? 4 : 0\n\t\t\t\t\t\t} );\n\n\t\t\t\t\tconst renderTargetProperties = renderer.properties.get( newRenderTarget );\n\t\t\t\t\trenderTargetProperties.__ignoreDepthValues = glProjLayer.ignoreDepthValues;\n\n\t\t\t\t}\n\n\t\t\t\tnewRenderTarget.isXRRenderTarget = true; // TODO Remove this when possible, see #23278\n\n\t\t\t\t// Set foveation to maximum.\n\t\t\t\tthis.setFoveation( 1.0 );\n\n\t\t\t\tcustomReferenceSpace = null;\n\t\t\t\treferenceSpace = await session.requestReferenceSpace( referenceSpaceType );\n\n\t\t\t\tanimation.setContext( session );\n\t\t\t\tanimation.start();\n\n\t\t\t\tscope.isPresenting = true;\n\n\t\t\t\tscope.dispatchEvent( { type: 'sessionstart' } );\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction onInputSourcesChange( event ) {\n\n\t\t\t// Notify disconnected\n\n\t\t\tfor ( let i = 0; i < event.removed.length; i ++ ) {\n\n\t\t\t\tconst inputSource = event.removed[ i ];\n\t\t\t\tconst index = controllerInputSources.indexOf( inputSource );\n\n\t\t\t\tif ( index >= 0 ) {\n\n\t\t\t\t\tcontrollerInputSources[ index ] = null;\n\t\t\t\t\tcontrollers[ index ].disconnect( inputSource );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Notify connected\n\n\t\t\tfor ( let i = 0; i < event.added.length; i ++ ) {\n\n\t\t\t\tconst inputSource = event.added[ i ];\n\n\t\t\t\tlet controllerIndex = controllerInputSources.indexOf( inputSource );\n\n\t\t\t\tif ( controllerIndex === - 1 ) {\n\n\t\t\t\t\t// Assign input source a controller that currently has no input source\n\n\t\t\t\t\tfor ( let i = 0; i < controllers.length; i ++ ) {\n\n\t\t\t\t\t\tif ( i >= controllerInputSources.length ) {\n\n\t\t\t\t\t\t\tcontrollerInputSources.push( inputSource );\n\t\t\t\t\t\t\tcontrollerIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t} else if ( controllerInputSources[ i ] === null ) {\n\n\t\t\t\t\t\t\tcontrollerInputSources[ i ] = inputSource;\n\t\t\t\t\t\t\tcontrollerIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// If all controllers do currently receive input we ignore new ones\n\n\t\t\t\t\tif ( controllerIndex === - 1 ) break;\n\n\t\t\t\t}\n\n\t\t\t\tconst controller = controllers[ controllerIndex ];\n\n\t\t\t\tif ( controller ) {\n\n\t\t\t\t\tcontroller.connect( inputSource );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst cameraLPos = new Vector3();\n\t\tconst cameraRPos = new Vector3();\n\n\t\t/**\n\t\t * Assumes 2 cameras that are parallel and share an X-axis, and that\n\t\t * the cameras' projection and world matrices have already been set.\n\t\t * And that near and far planes are identical for both cameras.\n\t\t * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765\n\t\t */\n\t\tfunction setProjectionFromUnion( camera, cameraL, cameraR ) {\n\n\t\t\tcameraLPos.setFromMatrixPosition( cameraL.matrixWorld );\n\t\t\tcameraRPos.setFromMatrixPosition( cameraR.matrixWorld );\n\n\t\t\tconst ipd = cameraLPos.distanceTo( cameraRPos );\n\n\t\t\tconst projL = cameraL.projectionMatrix.elements;\n\t\t\tconst projR = cameraR.projectionMatrix.elements;\n\n\t\t\t// VR systems will have identical far and near planes, and\n\t\t\t// most likely identical top and bottom frustum extents.\n\t\t\t// Use the left camera for these values.\n\t\t\tconst near = projL[ 14 ] / ( projL[ 10 ] - 1 );\n\t\t\tconst far = projL[ 14 ] / ( projL[ 10 ] + 1 );\n\t\t\tconst topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];\n\t\t\tconst bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];\n\n\t\t\tconst leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];\n\t\t\tconst rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];\n\t\t\tconst left = near * leftFov;\n\t\t\tconst right = near * rightFov;\n\n\t\t\t// Calculate the new camera's position offset from the\n\t\t\t// left camera. xOffset should be roughly half `ipd`.\n\t\t\tconst zOffset = ipd / ( - leftFov + rightFov );\n\t\t\tconst xOffset = zOffset * - leftFov;\n\n\t\t\t// TODO: Better way to apply this offset?\n\t\t\tcameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );\n\t\t\tcamera.translateX( xOffset );\n\t\t\tcamera.translateZ( zOffset );\n\t\t\tcamera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );\n\t\t\tcamera.matrixWorldInverse.copy( camera.matrixWorld ).invert();\n\n\t\t\t// Find the union of the frustum values of the cameras and scale\n\t\t\t// the values so that the near plane's position does not change in world space,\n\t\t\t// although must now be relative to the new union camera.\n\t\t\tconst near2 = near + zOffset;\n\t\t\tconst far2 = far + zOffset;\n\t\t\tconst left2 = left - xOffset;\n\t\t\tconst right2 = right + ( ipd - xOffset );\n\t\t\tconst top2 = topFov * far / far2 * near2;\n\t\t\tconst bottom2 = bottomFov * far / far2 * near2;\n\n\t\t\tcamera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );\n\n\t\t}\n\n\t\tfunction updateCamera( camera, parent ) {\n\n\t\t\tif ( parent === null ) {\n\n\t\t\t\tcamera.matrixWorld.copy( camera.matrix );\n\n\t\t\t} else {\n\n\t\t\t\tcamera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );\n\n\t\t\t}\n\n\t\t\tcamera.matrixWorldInverse.copy( camera.matrixWorld ).invert();\n\n\t\t}\n\n\t\tthis.updateCamera = function ( camera ) {\n\n\t\t\tif ( session === null ) return;\n\n\t\t\tcameraVR.near = cameraR.near = cameraL.near = camera.near;\n\t\t\tcameraVR.far = cameraR.far = cameraL.far = camera.far;\n\n\t\t\tif ( _currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far ) {\n\n\t\t\t\t// Note that the new renderState won't apply until the next frame. See #18320\n\n\t\t\t\tsession.updateRenderState( {\n\t\t\t\t\tdepthNear: cameraVR.near,\n\t\t\t\t\tdepthFar: cameraVR.far\n\t\t\t\t} );\n\n\t\t\t\t_currentDepthNear = cameraVR.near;\n\t\t\t\t_currentDepthFar = cameraVR.far;\n\n\t\t\t}\n\n\t\t\tconst parent = camera.parent;\n\t\t\tconst cameras = cameraVR.cameras;\n\n\t\t\tupdateCamera( cameraVR, parent );\n\n\t\t\tfor ( let i = 0; i < cameras.length; i ++ ) {\n\n\t\t\t\tupdateCamera( cameras[ i ], parent );\n\n\t\t\t}\n\n\t\t\tcameraVR.matrixWorld.decompose( cameraVR.position, cameraVR.quaternion, cameraVR.scale );\n\n\t\t\t// update user camera and its children\n\n\t\t\tcamera.matrix.copy( cameraVR.matrix );\n\t\t\tcamera.matrix.decompose( camera.position, camera.quaternion, camera.scale );\n\n\t\t\tconst children = camera.children;\n\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tchildren[ i ].updateMatrixWorld( true );\n\n\t\t\t}\n\n\t\t\t// update projection matrix for proper view frustum culling\n\n\t\t\tif ( cameras.length === 2 ) {\n\n\t\t\t\tsetProjectionFromUnion( cameraVR, cameraL, cameraR );\n\n\t\t\t} else {\n\n\t\t\t\t// assume single camera setup (AR)\n\n\t\t\t\tcameraVR.projectionMatrix.copy( cameraL.projectionMatrix );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.getCamera = function () {\n\n\t\t\treturn cameraVR;\n\n\t\t};\n\n\t\tthis.getFoveation = function () {\n\n\t\t\tif ( glProjLayer !== null ) {\n\n\t\t\t\treturn glProjLayer.fixedFoveation;\n\n\t\t\t}\n\n\t\t\tif ( glBaseLayer !== null ) {\n\n\t\t\t\treturn glBaseLayer.fixedFoveation;\n\n\t\t\t}\n\n\t\t\treturn undefined;\n\n\t\t};\n\n\t\tthis.setFoveation = function ( foveation ) {\n\n\t\t\t// 0 = no foveation = full resolution\n\t\t\t// 1 = maximum foveation = the edges render at lower resolution\n\n\t\t\tif ( glProjLayer !== null ) {\n\n\t\t\t\tglProjLayer.fixedFoveation = foveation;\n\n\t\t\t}\n\n\t\t\tif ( glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined ) {\n\n\t\t\t\tglBaseLayer.fixedFoveation = foveation;\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.getPlanes = function () {\n\n\t\t\treturn planes;\n\n\t\t};\n\n\t\t// Animation Loop\n\n\t\tlet onAnimationFrameCallback = null;\n\n\t\tfunction onAnimationFrame( time, frame ) {\n\n\t\t\tpose = frame.getViewerPose( customReferenceSpace || referenceSpace );\n\t\t\txrFrame = frame;\n\n\t\t\tif ( pose !== null ) {\n\n\t\t\t\tconst views = pose.views;\n\n\t\t\t\tif ( glBaseLayer !== null ) {\n\n\t\t\t\t\trenderer.setRenderTargetFramebuffer( newRenderTarget, glBaseLayer.framebuffer );\n\t\t\t\t\trenderer.setRenderTarget( newRenderTarget );\n\n\t\t\t\t}\n\n\t\t\t\tlet cameraVRNeedsUpdate = false;\n\n\t\t\t\t// check if it's necessary to rebuild cameraVR's camera list\n\n\t\t\t\tif ( views.length !== cameraVR.cameras.length ) {\n\n\t\t\t\t\tcameraVR.cameras.length = 0;\n\t\t\t\t\tcameraVRNeedsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0; i < views.length; i ++ ) {\n\n\t\t\t\t\tconst view = views[ i ];\n\n\t\t\t\t\tlet viewport = null;\n\n\t\t\t\t\tif ( glBaseLayer !== null ) {\n\n\t\t\t\t\t\tviewport = glBaseLayer.getViewport( view );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst glSubImage = glBinding.getViewSubImage( glProjLayer, view );\n\t\t\t\t\t\tviewport = glSubImage.viewport;\n\n\t\t\t\t\t\t// For side-by-side projection, we only produce a single texture for both eyes.\n\t\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\t\trenderer.setRenderTargetTextures(\n\t\t\t\t\t\t\t\tnewRenderTarget,\n\t\t\t\t\t\t\t\tglSubImage.colorTexture,\n\t\t\t\t\t\t\t\tglProjLayer.ignoreDepthValues ? undefined : glSubImage.depthStencilTexture );\n\n\t\t\t\t\t\t\trenderer.setRenderTarget( newRenderTarget );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet camera = cameras[ i ];\n\n\t\t\t\t\tif ( camera === undefined ) {\n\n\t\t\t\t\t\tcamera = new PerspectiveCamera();\n\t\t\t\t\t\tcamera.layers.enable( i );\n\t\t\t\t\t\tcamera.viewport = new Vector4();\n\t\t\t\t\t\tcameras[ i ] = camera;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcamera.matrix.fromArray( view.transform.matrix );\n\t\t\t\t\tcamera.projectionMatrix.fromArray( view.projectionMatrix );\n\t\t\t\t\tcamera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );\n\n\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\tcameraVR.matrix.copy( camera.matrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( cameraVRNeedsUpdate === true ) {\n\n\t\t\t\t\t\tcameraVR.cameras.push( camera );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfor ( let i = 0; i < controllers.length; i ++ ) {\n\n\t\t\t\tconst inputSource = controllerInputSources[ i ];\n\t\t\t\tconst controller = controllers[ i ];\n\n\t\t\t\tif ( inputSource !== null && controller !== undefined ) {\n\n\t\t\t\t\tcontroller.update( inputSource, frame, customReferenceSpace || referenceSpace );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( onAnimationFrameCallback ) onAnimationFrameCallback( time, frame );\n\n\t\t\tif ( frame.detectedPlanes ) {\n\n\t\t\t\tscope.dispatchEvent( { type: 'planesdetected', data: frame.detectedPlanes } );\n\n\t\t\t\tlet planesToRemove = null;\n\n\t\t\t\tfor ( const plane of planes ) {\n\n\t\t\t\t\tif ( ! frame.detectedPlanes.has( plane ) ) {\n\n\t\t\t\t\t\tif ( planesToRemove === null ) {\n\n\t\t\t\t\t\t\tplanesToRemove = [];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tplanesToRemove.push( plane );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( planesToRemove !== null ) {\n\n\t\t\t\t\tfor ( const plane of planesToRemove ) {\n\n\t\t\t\t\t\tplanes.delete( plane );\n\t\t\t\t\t\tplanesLastChangedTimes.delete( plane );\n\t\t\t\t\t\tscope.dispatchEvent( { type: 'planeremoved', data: plane } );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( const plane of frame.detectedPlanes ) {\n\n\t\t\t\t\tif ( ! planes.has( plane ) ) {\n\n\t\t\t\t\t\tplanes.add( plane );\n\t\t\t\t\t\tplanesLastChangedTimes.set( plane, frame.lastChangedTime );\n\t\t\t\t\t\tscope.dispatchEvent( { type: 'planeadded', data: plane } );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst lastKnownTime = planesLastChangedTimes.get( plane );\n\n\t\t\t\t\t\tif ( plane.lastChangedTime > lastKnownTime ) {\n\n\t\t\t\t\t\t\tplanesLastChangedTimes.set( plane, plane.lastChangedTime );\n\t\t\t\t\t\t\tscope.dispatchEvent( { type: 'planechanged', data: plane } );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\txrFrame = null;\n\n\t\t}\n\n\t\tconst animation = new WebGLAnimation();\n\n\t\tanimation.setAnimationLoop( onAnimationFrame );\n\n\t\tthis.setAnimationLoop = function ( callback ) {\n\n\t\t\tonAnimationFrameCallback = callback;\n\n\t\t};\n\n\t\tthis.dispose = function () {};\n\n\t}\n\n}\n\nexport { WebXRManager };\n"],"mappings":"AAAA,SAASA,WAAW,QAAQ,8BAA8B;AAC1D,SAASC,eAAe,QAAQ,+BAA+B;AAC/D,SAASC,iBAAiB,QAAQ,oCAAoC;AACtE,SAASC,OAAO,QAAQ,uBAAuB;AAC/C,SAASC,OAAO,QAAQ,uBAAuB;AAC/C,SAASC,cAAc,QAAQ,4BAA4B;AAC3D,SAASC,iBAAiB,QAAQ,yBAAyB;AAC3D,SAASC,eAAe,QAAQ,sBAAsB;AACtD,SAASC,YAAY,QAAQ,gCAAgC;AAC7D,SACCC,WAAW,EACXC,kBAAkB,EAClBC,UAAU,EACVC,gBAAgB,EAChBC,eAAe,EACfC,kBAAkB,QACZ,oBAAoB;AAE3B,MAAMC,YAAY,SAASd,eAAe,CAAC;EAE1Ce,WAAW,CAAEC,QAAQ,EAAEC,EAAE,EAAG;IAE3B,KAAK,EAAE;IAEP,MAAMC,KAAK,GAAG,IAAI;IAElB,IAAIC,OAAO,GAAG,IAAI;IAClB,IAAIC,sBAAsB,GAAG,GAAG;IAEhC,IAAIC,cAAc,GAAG,IAAI;IACzB,IAAIC,kBAAkB,GAAG,aAAa;IACtC,IAAIC,oBAAoB,GAAG,IAAI;IAE/B,IAAIC,IAAI,GAAG,IAAI;IACf,IAAIC,SAAS,GAAG,IAAI;IACpB,IAAIC,WAAW,GAAG,IAAI;IACtB,IAAIC,WAAW,GAAG,IAAI;IACtB,IAAIC,OAAO,GAAG,IAAI;IAClB,MAAMC,UAAU,GAAGZ,EAAE,CAACa,oBAAoB,EAAE;IAC5C,IAAIC,mBAAmB,GAAG,IAAI;IAC9B,IAAIC,eAAe,GAAG,IAAI;IAE1B,MAAMC,WAAW,GAAG,EAAE;IACtB,MAAMC,sBAAsB,GAAG,EAAE;IAEjC,MAAMC,MAAM,GAAG,IAAIC,GAAG,EAAE;IACxB,MAAMC,sBAAsB,GAAG,IAAIC,GAAG,EAAE;;IAExC;;IAEA,MAAMC,OAAO,GAAG,IAAItC,iBAAiB,EAAE;IACvCsC,OAAO,CAACC,MAAM,CAACC,MAAM,CAAE,CAAC,CAAE;IAC1BF,OAAO,CAACG,QAAQ,GAAG,IAAIvC,OAAO,EAAE;IAEhC,MAAMwC,OAAO,GAAG,IAAI1C,iBAAiB,EAAE;IACvC0C,OAAO,CAACH,MAAM,CAACC,MAAM,CAAE,CAAC,CAAE;IAC1BE,OAAO,CAACD,QAAQ,GAAG,IAAIvC,OAAO,EAAE;IAEhC,MAAMyC,OAAO,GAAG,CAAEL,OAAO,EAAEI,OAAO,CAAE;IAEpC,MAAME,QAAQ,GAAG,IAAI9C,WAAW,EAAE;IAClC8C,QAAQ,CAACL,MAAM,CAACC,MAAM,CAAE,CAAC,CAAE;IAC3BI,QAAQ,CAACL,MAAM,CAACC,MAAM,CAAE,CAAC,CAAE;IAE3B,IAAIK,iBAAiB,GAAG,IAAI;IAC5B,IAAIC,gBAAgB,GAAG,IAAI;;IAE3B;;IAEA,IAAI,CAACC,gBAAgB,GAAG,IAAI;IAC5B,IAAI,CAACC,OAAO,GAAG,KAAK;IAEpB,IAAI,CAACC,YAAY,GAAG,KAAK;IAEzB,IAAI,CAACC,aAAa,GAAG,UAAWC,KAAK,EAAG;MAEvC,IAAIC,UAAU,GAAGpB,WAAW,CAAEmB,KAAK,CAAE;MAErC,IAAKC,UAAU,KAAKC,SAAS,EAAG;QAE/BD,UAAU,GAAG,IAAI/C,eAAe,EAAE;QAClC2B,WAAW,CAAEmB,KAAK,CAAE,GAAGC,UAAU;MAElC;MAEA,OAAOA,UAAU,CAACE,iBAAiB,EAAE;IAEtC,CAAC;IAED,IAAI,CAACC,iBAAiB,GAAG,UAAWJ,KAAK,EAAG;MAE3C,IAAIC,UAAU,GAAGpB,WAAW,CAAEmB,KAAK,CAAE;MAErC,IAAKC,UAAU,KAAKC,SAAS,EAAG;QAE/BD,UAAU,GAAG,IAAI/C,eAAe,EAAE;QAClC2B,WAAW,CAAEmB,KAAK,CAAE,GAAGC,UAAU;MAElC;MAEA,OAAOA,UAAU,CAACI,YAAY,EAAE;IAEjC,CAAC;IAED,IAAI,CAACC,OAAO,GAAG,UAAWN,KAAK,EAAG;MAEjC,IAAIC,UAAU,GAAGpB,WAAW,CAAEmB,KAAK,CAAE;MAErC,IAAKC,UAAU,KAAKC,SAAS,EAAG;QAE/BD,UAAU,GAAG,IAAI/C,eAAe,EAAE;QAClC2B,WAAW,CAAEmB,KAAK,CAAE,GAAGC,UAAU;MAElC;MAEA,OAAOA,UAAU,CAACM,YAAY,EAAE;IAEjC,CAAC;;IAED;;IAEA,SAASC,cAAc,CAAEC,KAAK,EAAG;MAEhC,MAAMC,eAAe,GAAG5B,sBAAsB,CAAC6B,OAAO,CAAEF,KAAK,CAACG,WAAW,CAAE;MAE3E,IAAKF,eAAe,KAAK,CAAE,CAAC,EAAG;QAE9B;MAED;MAEA,MAAMT,UAAU,GAAGpB,WAAW,CAAE6B,eAAe,CAAE;MAEjD,IAAKT,UAAU,KAAKC,SAAS,EAAG;QAE/BD,UAAU,CAACY,aAAa,CAAE;UAAEC,IAAI,EAAEL,KAAK,CAACK,IAAI;UAAEC,IAAI,EAAEN,KAAK,CAACG;QAAY,CAAC,CAAE;MAE1E;IAED;IAEA,SAASI,YAAY,GAAG;MAEvBjD,OAAO,CAACkD,mBAAmB,CAAE,QAAQ,EAAET,cAAc,CAAE;MACvDzC,OAAO,CAACkD,mBAAmB,CAAE,aAAa,EAAET,cAAc,CAAE;MAC5DzC,OAAO,CAACkD,mBAAmB,CAAE,WAAW,EAAET,cAAc,CAAE;MAC1DzC,OAAO,CAACkD,mBAAmB,CAAE,SAAS,EAAET,cAAc,CAAE;MACxDzC,OAAO,CAACkD,mBAAmB,CAAE,cAAc,EAAET,cAAc,CAAE;MAC7DzC,OAAO,CAACkD,mBAAmB,CAAE,YAAY,EAAET,cAAc,CAAE;MAC3DzC,OAAO,CAACkD,mBAAmB,CAAE,KAAK,EAAED,YAAY,CAAE;MAClDjD,OAAO,CAACkD,mBAAmB,CAAE,oBAAoB,EAAEC,oBAAoB,CAAE;MAEzE,KAAM,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGtC,WAAW,CAACuC,MAAM,EAAED,CAAC,EAAG,EAAG;QAE/C,MAAMP,WAAW,GAAG9B,sBAAsB,CAAEqC,CAAC,CAAE;QAE/C,IAAKP,WAAW,KAAK,IAAI,EAAG;QAE5B9B,sBAAsB,CAAEqC,CAAC,CAAE,GAAG,IAAI;QAElCtC,WAAW,CAAEsC,CAAC,CAAE,CAACE,UAAU,CAAET,WAAW,CAAE;MAE3C;MAEAlB,iBAAiB,GAAG,IAAI;MACxBC,gBAAgB,GAAG,IAAI;;MAEvB;;MAEA/B,QAAQ,CAAC0D,eAAe,CAAE3C,mBAAmB,CAAE;MAE/CJ,WAAW,GAAG,IAAI;MAClBD,WAAW,GAAG,IAAI;MAClBD,SAAS,GAAG,IAAI;MAChBN,OAAO,GAAG,IAAI;MACda,eAAe,GAAG,IAAI;;MAEtB;;MAEA2C,SAAS,CAACC,IAAI,EAAE;MAEhB1D,KAAK,CAACgC,YAAY,GAAG,KAAK;MAE1BhC,KAAK,CAAC+C,aAAa,CAAE;QAAEC,IAAI,EAAE;MAAa,CAAC,CAAE;IAE9C;IAEA,IAAI,CAACW,yBAAyB,GAAG,UAAWC,KAAK,EAAG;MAEnD1D,sBAAsB,GAAG0D,KAAK;MAE9B,IAAK5D,KAAK,CAACgC,YAAY,KAAK,IAAI,EAAG;QAElC6B,OAAO,CAACC,IAAI,CAAE,uEAAuE,CAAE;MAExF;IAED,CAAC;IAED,IAAI,CAACC,qBAAqB,GAAG,UAAWH,KAAK,EAAG;MAE/CxD,kBAAkB,GAAGwD,KAAK;MAE1B,IAAK5D,KAAK,CAACgC,YAAY,KAAK,IAAI,EAAG;QAElC6B,OAAO,CAACC,IAAI,CAAE,0EAA0E,CAAE;MAE3F;IAED,CAAC;IAED,IAAI,CAACE,iBAAiB,GAAG,YAAY;MAEpC,OAAO3D,oBAAoB,IAAIF,cAAc;IAE9C,CAAC;IAED,IAAI,CAAC8D,iBAAiB,GAAG,UAAWC,KAAK,EAAG;MAE3C7D,oBAAoB,GAAG6D,KAAK;IAE7B,CAAC;IAED,IAAI,CAACC,YAAY,GAAG,YAAY;MAE/B,OAAO3D,WAAW,KAAK,IAAI,GAAGA,WAAW,GAAGC,WAAW;IAExD,CAAC;IAED,IAAI,CAAC2D,UAAU,GAAG,YAAY;MAE7B,OAAO7D,SAAS;IAEjB,CAAC;IAED,IAAI,CAAC8D,QAAQ,GAAG,YAAY;MAE3B,OAAO3D,OAAO;IAEf,CAAC;IAED,IAAI,CAAC4D,UAAU,GAAG,YAAY;MAE7B,OAAOrE,OAAO;IAEf,CAAC;IAED,IAAI,CAACsE,UAAU,GAAG,gBAAiBX,KAAK,EAAG;MAE1C3D,OAAO,GAAG2D,KAAK;MAEf,IAAK3D,OAAO,KAAK,IAAI,EAAG;QAEvBY,mBAAmB,GAAGf,QAAQ,CAAC0E,eAAe,EAAE;QAEhDvE,OAAO,CAACwE,gBAAgB,CAAE,QAAQ,EAAE/B,cAAc,CAAE;QACpDzC,OAAO,CAACwE,gBAAgB,CAAE,aAAa,EAAE/B,cAAc,CAAE;QACzDzC,OAAO,CAACwE,gBAAgB,CAAE,WAAW,EAAE/B,cAAc,CAAE;QACvDzC,OAAO,CAACwE,gBAAgB,CAAE,SAAS,EAAE/B,cAAc,CAAE;QACrDzC,OAAO,CAACwE,gBAAgB,CAAE,cAAc,EAAE/B,cAAc,CAAE;QAC1DzC,OAAO,CAACwE,gBAAgB,CAAE,YAAY,EAAE/B,cAAc,CAAE;QACxDzC,OAAO,CAACwE,gBAAgB,CAAE,KAAK,EAAEvB,YAAY,CAAE;QAC/CjD,OAAO,CAACwE,gBAAgB,CAAE,oBAAoB,EAAErB,oBAAoB,CAAE;QAEtE,IAAKzC,UAAU,CAAC+D,YAAY,KAAK,IAAI,EAAG;UAEvC,MAAM3E,EAAE,CAAC4E,gBAAgB,EAAE;QAE5B;QAEA,IAAO1E,OAAO,CAAC2E,WAAW,CAACtD,MAAM,KAAKc,SAAS,IAAQtC,QAAQ,CAAC+E,YAAY,CAACC,QAAQ,KAAK,KAAO,EAAG;UAEnG,MAAMC,SAAS,GAAG;YACjBC,SAAS,EAAI/E,OAAO,CAAC2E,WAAW,CAACtD,MAAM,KAAKc,SAAS,GAAKzB,UAAU,CAACqE,SAAS,GAAG,IAAI;YACrFC,KAAK,EAAEtE,UAAU,CAACsE,KAAK;YACvBC,KAAK,EAAEvE,UAAU,CAACuE,KAAK;YACvBC,OAAO,EAAExE,UAAU,CAACwE,OAAO;YAC3BjF,sBAAsB,EAAEA;UACzB,CAAC;UAEDO,WAAW,GAAG,IAAI2E,YAAY,CAAEnF,OAAO,EAAEF,EAAE,EAAEgF,SAAS,CAAE;UAExD9E,OAAO,CAACoF,iBAAiB,CAAE;YAAEC,SAAS,EAAE7E;UAAY,CAAC,CAAE;UAEvDK,eAAe,GAAG,IAAI3B,iBAAiB,CACtCsB,WAAW,CAAC8E,gBAAgB,EAC5B9E,WAAW,CAAC+E,iBAAiB,EAC7B;YACCC,MAAM,EAAEjG,UAAU;YAClBwD,IAAI,EAAEvD,gBAAgB;YACtBiG,QAAQ,EAAE5F,QAAQ,CAAC6F,cAAc;YACjCC,aAAa,EAAEjF,UAAU,CAACwE;UAC3B,CAAC,CACD;QAEF,CAAC,MAAM;UAEN,IAAIU,WAAW,GAAG,IAAI;UACtB,IAAIC,SAAS,GAAG,IAAI;UACpB,IAAIC,aAAa,GAAG,IAAI;UAExB,IAAKpF,UAAU,CAACuE,KAAK,EAAG;YAEvBa,aAAa,GAAGpF,UAAU,CAACwE,OAAO,GAAGpF,EAAE,CAACiG,gBAAgB,GAAGjG,EAAE,CAACkG,iBAAiB;YAC/EJ,WAAW,GAAGlF,UAAU,CAACwE,OAAO,GAAG5F,kBAAkB,GAAGD,WAAW;YACnEwG,SAAS,GAAGnF,UAAU,CAACwE,OAAO,GAAGxF,kBAAkB,GAAGD,eAAe;UAEtE;UAEA,MAAMwG,mBAAmB,GAAG;YAC3BC,WAAW,EAAEpG,EAAE,CAACqG,KAAK;YACrBP,WAAW,EAAEE,aAAa;YAC1BM,WAAW,EAAEnG;UACd,CAAC;UAEDK,SAAS,GAAG,IAAI+F,cAAc,CAAErG,OAAO,EAAEF,EAAE,CAAE;UAE7CS,WAAW,GAAGD,SAAS,CAACgG,qBAAqB,CAAEL,mBAAmB,CAAE;UAEpEjG,OAAO,CAACoF,iBAAiB,CAAE;YAAE/D,MAAM,EAAE,CAAEd,WAAW;UAAG,CAAC,CAAE;UAExDM,eAAe,GAAG,IAAI3B,iBAAiB,CACtCqB,WAAW,CAACgG,YAAY,EACxBhG,WAAW,CAACiG,aAAa,EACzB;YACChB,MAAM,EAAEjG,UAAU;YAClBwD,IAAI,EAAEvD,gBAAgB;YACtBiH,YAAY,EAAE,IAAIrH,YAAY,CAAEmB,WAAW,CAACgG,YAAY,EAAEhG,WAAW,CAACiG,aAAa,EAAEX,SAAS,EAAE1D,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEyD,WAAW,CAAE;YAC/KD,aAAa,EAAEjF,UAAU,CAACwE,OAAO;YACjCO,QAAQ,EAAE5F,QAAQ,CAAC6F,cAAc;YACjCgB,OAAO,EAAEhG,UAAU,CAACqE,SAAS,GAAG,CAAC,GAAG;UACrC,CAAC,CAAE;UAEJ,MAAM4B,sBAAsB,GAAG9G,QAAQ,CAAC+G,UAAU,CAACC,GAAG,CAAEhG,eAAe,CAAE;UACzE8F,sBAAsB,CAACG,mBAAmB,GAAGvG,WAAW,CAACwG,iBAAiB;QAE3E;QAEAlG,eAAe,CAACmG,gBAAgB,GAAG,IAAI,CAAC,CAAC;;QAEzC;QACA,IAAI,CAACC,YAAY,CAAE,GAAG,CAAE;QAExB7G,oBAAoB,GAAG,IAAI;QAC3BF,cAAc,GAAG,MAAMF,OAAO,CAACkH,qBAAqB,CAAE/G,kBAAkB,CAAE;QAE1EqD,SAAS,CAAC2D,UAAU,CAAEnH,OAAO,CAAE;QAC/BwD,SAAS,CAAC4D,KAAK,EAAE;QAEjBrH,KAAK,CAACgC,YAAY,GAAG,IAAI;QAEzBhC,KAAK,CAAC+C,aAAa,CAAE;UAAEC,IAAI,EAAE;QAAe,CAAC,CAAE;MAEhD;IAED,CAAC;IAED,SAASI,oBAAoB,CAAET,KAAK,EAAG;MAEtC;;MAEA,KAAM,IAAIU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,KAAK,CAAC2E,OAAO,CAAChE,MAAM,EAAED,CAAC,EAAG,EAAG;QAEjD,MAAMP,WAAW,GAAGH,KAAK,CAAC2E,OAAO,CAAEjE,CAAC,CAAE;QACtC,MAAMnB,KAAK,GAAGlB,sBAAsB,CAAC6B,OAAO,CAAEC,WAAW,CAAE;QAE3D,IAAKZ,KAAK,IAAI,CAAC,EAAG;UAEjBlB,sBAAsB,CAAEkB,KAAK,CAAE,GAAG,IAAI;UACtCnB,WAAW,CAAEmB,KAAK,CAAE,CAACqB,UAAU,CAAET,WAAW,CAAE;QAE/C;MAED;;MAEA;;MAEA,KAAM,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,KAAK,CAAC4E,KAAK,CAACjE,MAAM,EAAED,CAAC,EAAG,EAAG;QAE/C,MAAMP,WAAW,GAAGH,KAAK,CAAC4E,KAAK,CAAElE,CAAC,CAAE;QAEpC,IAAIT,eAAe,GAAG5B,sBAAsB,CAAC6B,OAAO,CAAEC,WAAW,CAAE;QAEnE,IAAKF,eAAe,KAAK,CAAE,CAAC,EAAG;UAE9B;;UAEA,KAAM,IAAIS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGtC,WAAW,CAACuC,MAAM,EAAED,CAAC,EAAG,EAAG;YAE/C,IAAKA,CAAC,IAAIrC,sBAAsB,CAACsC,MAAM,EAAG;cAEzCtC,sBAAsB,CAACwG,IAAI,CAAE1E,WAAW,CAAE;cAC1CF,eAAe,GAAGS,CAAC;cACnB;YAED,CAAC,MAAM,IAAKrC,sBAAsB,CAAEqC,CAAC,CAAE,KAAK,IAAI,EAAG;cAElDrC,sBAAsB,CAAEqC,CAAC,CAAE,GAAGP,WAAW;cACzCF,eAAe,GAAGS,CAAC;cACnB;YAED;UAED;;UAEA;;UAEA,IAAKT,eAAe,KAAK,CAAE,CAAC,EAAG;QAEhC;QAEA,MAAMT,UAAU,GAAGpB,WAAW,CAAE6B,eAAe,CAAE;QAEjD,IAAKT,UAAU,EAAG;UAEjBA,UAAU,CAACsF,OAAO,CAAE3E,WAAW,CAAE;QAElC;MAED;IAED;;IAEA;;IAEA,MAAM4E,UAAU,GAAG,IAAI1I,OAAO,EAAE;IAChC,MAAM2I,UAAU,GAAG,IAAI3I,OAAO,EAAE;;IAEhC;AACF;AACA;AACA;AACA;AACA;IACE,SAAS4I,sBAAsB,CAAEC,MAAM,EAAExG,OAAO,EAAEI,OAAO,EAAG;MAE3DiG,UAAU,CAACI,qBAAqB,CAAEzG,OAAO,CAAC0G,WAAW,CAAE;MACvDJ,UAAU,CAACG,qBAAqB,CAAErG,OAAO,CAACsG,WAAW,CAAE;MAEvD,MAAMC,GAAG,GAAGN,UAAU,CAACO,UAAU,CAAEN,UAAU,CAAE;MAE/C,MAAMO,KAAK,GAAG7G,OAAO,CAAC8G,gBAAgB,CAACC,QAAQ;MAC/C,MAAMC,KAAK,GAAG5G,OAAO,CAAC0G,gBAAgB,CAACC,QAAQ;;MAE/C;MACA;MACA;MACA,MAAME,IAAI,GAAGJ,KAAK,CAAE,EAAE,CAAE,IAAKA,KAAK,CAAE,EAAE,CAAE,GAAG,CAAC,CAAE;MAC9C,MAAMK,GAAG,GAAGL,KAAK,CAAE,EAAE,CAAE,IAAKA,KAAK,CAAE,EAAE,CAAE,GAAG,CAAC,CAAE;MAC7C,MAAMM,MAAM,GAAG,CAAEN,KAAK,CAAE,CAAC,CAAE,GAAG,CAAC,IAAKA,KAAK,CAAE,CAAC,CAAE;MAC9C,MAAMO,SAAS,GAAG,CAAEP,KAAK,CAAE,CAAC,CAAE,GAAG,CAAC,IAAKA,KAAK,CAAE,CAAC,CAAE;MAEjD,MAAMQ,OAAO,GAAG,CAAER,KAAK,CAAE,CAAC,CAAE,GAAG,CAAC,IAAKA,KAAK,CAAE,CAAC,CAAE;MAC/C,MAAMS,QAAQ,GAAG,CAAEN,KAAK,CAAE,CAAC,CAAE,GAAG,CAAC,IAAKA,KAAK,CAAE,CAAC,CAAE;MAChD,MAAMO,IAAI,GAAGN,IAAI,GAAGI,OAAO;MAC3B,MAAMG,KAAK,GAAGP,IAAI,GAAGK,QAAQ;;MAE7B;MACA;MACA,MAAMG,OAAO,GAAGd,GAAG,IAAK,CAAEU,OAAO,GAAGC,QAAQ,CAAE;MAC9C,MAAMI,OAAO,GAAGD,OAAO,GAAG,CAAEJ,OAAO;;MAEnC;MACArH,OAAO,CAAC0G,WAAW,CAACiB,SAAS,CAAEnB,MAAM,CAACoB,QAAQ,EAAEpB,MAAM,CAACqB,UAAU,EAAErB,MAAM,CAACsB,KAAK,CAAE;MACjFtB,MAAM,CAACuB,UAAU,CAAEL,OAAO,CAAE;MAC5BlB,MAAM,CAACwB,UAAU,CAAEP,OAAO,CAAE;MAC5BjB,MAAM,CAACE,WAAW,CAACuB,OAAO,CAAEzB,MAAM,CAACoB,QAAQ,EAAEpB,MAAM,CAACqB,UAAU,EAAErB,MAAM,CAACsB,KAAK,CAAE;MAC9EtB,MAAM,CAAC0B,kBAAkB,CAACC,IAAI,CAAE3B,MAAM,CAACE,WAAW,CAAE,CAAC0B,MAAM,EAAE;;MAE7D;MACA;MACA;MACA,MAAMC,KAAK,GAAGpB,IAAI,GAAGQ,OAAO;MAC5B,MAAMa,IAAI,GAAGpB,GAAG,GAAGO,OAAO;MAC1B,MAAMc,KAAK,GAAGhB,IAAI,GAAGG,OAAO;MAC5B,MAAMc,MAAM,GAAGhB,KAAK,IAAKb,GAAG,GAAGe,OAAO,CAAE;MACxC,MAAMe,IAAI,GAAGtB,MAAM,GAAGD,GAAG,GAAGoB,IAAI,GAAGD,KAAK;MACxC,MAAMK,OAAO,GAAGtB,SAAS,GAAGF,GAAG,GAAGoB,IAAI,GAAGD,KAAK;MAE9C7B,MAAM,CAACM,gBAAgB,CAAC6B,eAAe,CAAEJ,KAAK,EAAEC,MAAM,EAAEC,IAAI,EAAEC,OAAO,EAAEL,KAAK,EAAEC,IAAI,CAAE;IAErF;IAEA,SAASM,YAAY,CAAEpC,MAAM,EAAEqC,MAAM,EAAG;MAEvC,IAAKA,MAAM,KAAK,IAAI,EAAG;QAEtBrC,MAAM,CAACE,WAAW,CAACyB,IAAI,CAAE3B,MAAM,CAACsC,MAAM,CAAE;MAEzC,CAAC,MAAM;QAENtC,MAAM,CAACE,WAAW,CAACqC,gBAAgB,CAAEF,MAAM,CAACnC,WAAW,EAAEF,MAAM,CAACsC,MAAM,CAAE;MAEzE;MAEAtC,MAAM,CAAC0B,kBAAkB,CAACC,IAAI,CAAE3B,MAAM,CAACE,WAAW,CAAE,CAAC0B,MAAM,EAAE;IAE9D;IAEA,IAAI,CAACQ,YAAY,GAAG,UAAWpC,MAAM,EAAG;MAEvC,IAAK5H,OAAO,KAAK,IAAI,EAAG;MAExB0B,QAAQ,CAAC2G,IAAI,GAAG7G,OAAO,CAAC6G,IAAI,GAAGjH,OAAO,CAACiH,IAAI,GAAGT,MAAM,CAACS,IAAI;MACzD3G,QAAQ,CAAC4G,GAAG,GAAG9G,OAAO,CAAC8G,GAAG,GAAGlH,OAAO,CAACkH,GAAG,GAAGV,MAAM,CAACU,GAAG;MAErD,IAAK3G,iBAAiB,KAAKD,QAAQ,CAAC2G,IAAI,IAAIzG,gBAAgB,KAAKF,QAAQ,CAAC4G,GAAG,EAAG;QAE/E;;QAEAtI,OAAO,CAACoF,iBAAiB,CAAE;UAC1BgF,SAAS,EAAE1I,QAAQ,CAAC2G,IAAI;UACxBgC,QAAQ,EAAE3I,QAAQ,CAAC4G;QACpB,CAAC,CAAE;QAEH3G,iBAAiB,GAAGD,QAAQ,CAAC2G,IAAI;QACjCzG,gBAAgB,GAAGF,QAAQ,CAAC4G,GAAG;MAEhC;MAEA,MAAM2B,MAAM,GAAGrC,MAAM,CAACqC,MAAM;MAC5B,MAAMxI,OAAO,GAAGC,QAAQ,CAACD,OAAO;MAEhCuI,YAAY,CAAEtI,QAAQ,EAAEuI,MAAM,CAAE;MAEhC,KAAM,IAAI7G,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG3B,OAAO,CAAC4B,MAAM,EAAED,CAAC,EAAG,EAAG;QAE3C4G,YAAY,CAAEvI,OAAO,CAAE2B,CAAC,CAAE,EAAE6G,MAAM,CAAE;MAErC;MAEAvI,QAAQ,CAACoG,WAAW,CAACiB,SAAS,CAAErH,QAAQ,CAACsH,QAAQ,EAAEtH,QAAQ,CAACuH,UAAU,EAAEvH,QAAQ,CAACwH,KAAK,CAAE;;MAExF;;MAEAtB,MAAM,CAACsC,MAAM,CAACX,IAAI,CAAE7H,QAAQ,CAACwI,MAAM,CAAE;MACrCtC,MAAM,CAACsC,MAAM,CAACnB,SAAS,CAAEnB,MAAM,CAACoB,QAAQ,EAAEpB,MAAM,CAACqB,UAAU,EAAErB,MAAM,CAACsB,KAAK,CAAE;MAE3E,MAAMoB,QAAQ,GAAG1C,MAAM,CAAC0C,QAAQ;MAEhC,KAAM,IAAIlH,CAAC,GAAG,CAAC,EAAEmH,CAAC,GAAGD,QAAQ,CAACjH,MAAM,EAAED,CAAC,GAAGmH,CAAC,EAAEnH,CAAC,EAAG,EAAG;QAEnDkH,QAAQ,CAAElH,CAAC,CAAE,CAACoH,iBAAiB,CAAE,IAAI,CAAE;MAExC;;MAEA;;MAEA,IAAK/I,OAAO,CAAC4B,MAAM,KAAK,CAAC,EAAG;QAE3BsE,sBAAsB,CAAEjG,QAAQ,EAAEN,OAAO,EAAEI,OAAO,CAAE;MAErD,CAAC,MAAM;QAEN;;QAEAE,QAAQ,CAACwG,gBAAgB,CAACqB,IAAI,CAAEnI,OAAO,CAAC8G,gBAAgB,CAAE;MAE3D;IAED,CAAC;IAED,IAAI,CAACuC,SAAS,GAAG,YAAY;MAE5B,OAAO/I,QAAQ;IAEhB,CAAC;IAED,IAAI,CAACgJ,YAAY,GAAG,YAAY;MAE/B,IAAKnK,WAAW,KAAK,IAAI,EAAG;QAE3B,OAAOA,WAAW,CAACoK,cAAc;MAElC;MAEA,IAAKnK,WAAW,KAAK,IAAI,EAAG;QAE3B,OAAOA,WAAW,CAACmK,cAAc;MAElC;MAEA,OAAOxI,SAAS;IAEjB,CAAC;IAED,IAAI,CAAC8E,YAAY,GAAG,UAAW2D,SAAS,EAAG;MAE1C;MACA;;MAEA,IAAKrK,WAAW,KAAK,IAAI,EAAG;QAE3BA,WAAW,CAACoK,cAAc,GAAGC,SAAS;MAEvC;MAEA,IAAKpK,WAAW,KAAK,IAAI,IAAIA,WAAW,CAACmK,cAAc,KAAKxI,SAAS,EAAG;QAEvE3B,WAAW,CAACmK,cAAc,GAAGC,SAAS;MAEvC;IAED,CAAC;IAED,IAAI,CAACC,SAAS,GAAG,YAAY;MAE5B,OAAO7J,MAAM;IAEd,CAAC;;IAED;;IAEA,IAAI8J,wBAAwB,GAAG,IAAI;IAEnC,SAASC,gBAAgB,CAAEC,IAAI,EAAEC,KAAK,EAAG;MAExC5K,IAAI,GAAG4K,KAAK,CAACC,aAAa,CAAE9K,oBAAoB,IAAIF,cAAc,CAAE;MACpEO,OAAO,GAAGwK,KAAK;MAEf,IAAK5K,IAAI,KAAK,IAAI,EAAG;QAEpB,MAAM8K,KAAK,GAAG9K,IAAI,CAAC8K,KAAK;QAExB,IAAK3K,WAAW,KAAK,IAAI,EAAG;UAE3BX,QAAQ,CAACuL,0BAA0B,CAAEvK,eAAe,EAAEL,WAAW,CAAC6K,WAAW,CAAE;UAC/ExL,QAAQ,CAAC0D,eAAe,CAAE1C,eAAe,CAAE;QAE5C;QAEA,IAAIyK,mBAAmB,GAAG,KAAK;;QAE/B;;QAEA,IAAKH,KAAK,CAAC9H,MAAM,KAAK3B,QAAQ,CAACD,OAAO,CAAC4B,MAAM,EAAG;UAE/C3B,QAAQ,CAACD,OAAO,CAAC4B,MAAM,GAAG,CAAC;UAC3BiI,mBAAmB,GAAG,IAAI;QAE3B;QAEA,KAAM,IAAIlI,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+H,KAAK,CAAC9H,MAAM,EAAED,CAAC,EAAG,EAAG;UAEzC,MAAMmI,IAAI,GAAGJ,KAAK,CAAE/H,CAAC,CAAE;UAEvB,IAAI7B,QAAQ,GAAG,IAAI;UAEnB,IAAKf,WAAW,KAAK,IAAI,EAAG;YAE3Be,QAAQ,GAAGf,WAAW,CAACgL,WAAW,CAAED,IAAI,CAAE;UAE3C,CAAC,MAAM;YAEN,MAAME,UAAU,GAAGnL,SAAS,CAACoL,eAAe,CAAEnL,WAAW,EAAEgL,IAAI,CAAE;YACjEhK,QAAQ,GAAGkK,UAAU,CAAClK,QAAQ;;YAE9B;YACA,IAAK6B,CAAC,KAAK,CAAC,EAAG;cAEdvD,QAAQ,CAAC8L,uBAAuB,CAC/B9K,eAAe,EACf4K,UAAU,CAACG,YAAY,EACvBrL,WAAW,CAACwG,iBAAiB,GAAG5E,SAAS,GAAGsJ,UAAU,CAACI,mBAAmB,CAAE;cAE7EhM,QAAQ,CAAC0D,eAAe,CAAE1C,eAAe,CAAE;YAE5C;UAED;UAEA,IAAI+G,MAAM,GAAGnG,OAAO,CAAE2B,CAAC,CAAE;UAEzB,IAAKwE,MAAM,KAAKzF,SAAS,EAAG;YAE3ByF,MAAM,GAAG,IAAI9I,iBAAiB,EAAE;YAChC8I,MAAM,CAACvG,MAAM,CAACC,MAAM,CAAE8B,CAAC,CAAE;YACzBwE,MAAM,CAACrG,QAAQ,GAAG,IAAIvC,OAAO,EAAE;YAC/ByC,OAAO,CAAE2B,CAAC,CAAE,GAAGwE,MAAM;UAEtB;UAEAA,MAAM,CAACsC,MAAM,CAAC4B,SAAS,CAAEP,IAAI,CAACQ,SAAS,CAAC7B,MAAM,CAAE;UAChDtC,MAAM,CAACM,gBAAgB,CAAC4D,SAAS,CAAEP,IAAI,CAACrD,gBAAgB,CAAE;UAC1DN,MAAM,CAACrG,QAAQ,CAACyK,GAAG,CAAEzK,QAAQ,CAAC0K,CAAC,EAAE1K,QAAQ,CAAC2K,CAAC,EAAE3K,QAAQ,CAAC4K,KAAK,EAAE5K,QAAQ,CAAC6K,MAAM,CAAE;UAE9E,IAAKhJ,CAAC,KAAK,CAAC,EAAG;YAEd1B,QAAQ,CAACwI,MAAM,CAACX,IAAI,CAAE3B,MAAM,CAACsC,MAAM,CAAE;UAEtC;UAEA,IAAKoB,mBAAmB,KAAK,IAAI,EAAG;YAEnC5J,QAAQ,CAACD,OAAO,CAAC8F,IAAI,CAAEK,MAAM,CAAE;UAEhC;QAED;MAED;;MAEA;;MAEA,KAAM,IAAIxE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGtC,WAAW,CAACuC,MAAM,EAAED,CAAC,EAAG,EAAG;QAE/C,MAAMP,WAAW,GAAG9B,sBAAsB,CAAEqC,CAAC,CAAE;QAC/C,MAAMlB,UAAU,GAAGpB,WAAW,CAAEsC,CAAC,CAAE;QAEnC,IAAKP,WAAW,KAAK,IAAI,IAAIX,UAAU,KAAKC,SAAS,EAAG;UAEvDD,UAAU,CAACmK,MAAM,CAAExJ,WAAW,EAAEoI,KAAK,EAAE7K,oBAAoB,IAAIF,cAAc,CAAE;QAEhF;MAED;MAEA,IAAK4K,wBAAwB,EAAGA,wBAAwB,CAAEE,IAAI,EAAEC,KAAK,CAAE;MAEvE,IAAKA,KAAK,CAACqB,cAAc,EAAG;QAE3BvM,KAAK,CAAC+C,aAAa,CAAE;UAAEC,IAAI,EAAE,gBAAgB;UAAEC,IAAI,EAAEiI,KAAK,CAACqB;QAAe,CAAC,CAAE;QAE7E,IAAIC,cAAc,GAAG,IAAI;QAEzB,KAAM,MAAMC,KAAK,IAAIxL,MAAM,EAAG;UAE7B,IAAK,CAAEiK,KAAK,CAACqB,cAAc,CAACG,GAAG,CAAED,KAAK,CAAE,EAAG;YAE1C,IAAKD,cAAc,KAAK,IAAI,EAAG;cAE9BA,cAAc,GAAG,EAAE;YAEpB;YAEAA,cAAc,CAAChF,IAAI,CAAEiF,KAAK,CAAE;UAE7B;QAED;QAEA,IAAKD,cAAc,KAAK,IAAI,EAAG;UAE9B,KAAM,MAAMC,KAAK,IAAID,cAAc,EAAG;YAErCvL,MAAM,CAAC0L,MAAM,CAAEF,KAAK,CAAE;YACtBtL,sBAAsB,CAACwL,MAAM,CAAEF,KAAK,CAAE;YACtCzM,KAAK,CAAC+C,aAAa,CAAE;cAAEC,IAAI,EAAE,cAAc;cAAEC,IAAI,EAAEwJ;YAAM,CAAC,CAAE;UAE7D;QAED;QAEA,KAAM,MAAMA,KAAK,IAAIvB,KAAK,CAACqB,cAAc,EAAG;UAE3C,IAAK,CAAEtL,MAAM,CAACyL,GAAG,CAAED,KAAK,CAAE,EAAG;YAE5BxL,MAAM,CAAC2L,GAAG,CAAEH,KAAK,CAAE;YACnBtL,sBAAsB,CAAC8K,GAAG,CAAEQ,KAAK,EAAEvB,KAAK,CAAC2B,eAAe,CAAE;YAC1D7M,KAAK,CAAC+C,aAAa,CAAE;cAAEC,IAAI,EAAE,YAAY;cAAEC,IAAI,EAAEwJ;YAAM,CAAC,CAAE;UAE3D,CAAC,MAAM;YAEN,MAAMK,aAAa,GAAG3L,sBAAsB,CAAC2F,GAAG,CAAE2F,KAAK,CAAE;YAEzD,IAAKA,KAAK,CAACI,eAAe,GAAGC,aAAa,EAAG;cAE5C3L,sBAAsB,CAAC8K,GAAG,CAAEQ,KAAK,EAAEA,KAAK,CAACI,eAAe,CAAE;cAC1D7M,KAAK,CAAC+C,aAAa,CAAE;gBAAEC,IAAI,EAAE,cAAc;gBAAEC,IAAI,EAAEwJ;cAAM,CAAC,CAAE;YAE7D;UAED;QAED;MAED;MAEA/L,OAAO,GAAG,IAAI;IAEf;IAEA,MAAM+C,SAAS,GAAG,IAAIvE,cAAc,EAAE;IAEtCuE,SAAS,CAACsJ,gBAAgB,CAAE/B,gBAAgB,CAAE;IAE9C,IAAI,CAAC+B,gBAAgB,GAAG,UAAWC,QAAQ,EAAG;MAE7CjC,wBAAwB,GAAGiC,QAAQ;IAEpC,CAAC;IAED,IAAI,CAACC,OAAO,GAAG,YAAY,CAAC,CAAC;EAE9B;AAED;AAEA,SAASrN,YAAY"},"metadata":{},"sourceType":"module","externalDependencies":[]}