{"ast":null,"code":"import { AnimationAction } from './AnimationAction.js';\nimport { EventDispatcher } from '../core/EventDispatcher.js';\nimport { LinearInterpolant } from '../math/interpolants/LinearInterpolant.js';\nimport { PropertyBinding } from './PropertyBinding.js';\nimport { PropertyMixer } from './PropertyMixer.js';\nimport { AnimationClip } from './AnimationClip.js';\nimport { NormalAnimationBlendMode } from '../constants.js';\nconst _controlInterpolantsResultBuffer = new Float32Array(1);\nclass AnimationMixer extends EventDispatcher {\n  constructor(root) {\n    super();\n    this._root = root;\n    this._initMemoryManager();\n    this._accuIndex = 0;\n    this.time = 0;\n    this.timeScale = 1.0;\n  }\n  _bindAction(action, prototypeAction) {\n    const root = action._localRoot || this._root,\n      tracks = action._clip.tracks,\n      nTracks = tracks.length,\n      bindings = action._propertyBindings,\n      interpolants = action._interpolants,\n      rootUuid = root.uuid,\n      bindingsByRoot = this._bindingsByRootAndName;\n    let bindingsByName = bindingsByRoot[rootUuid];\n    if (bindingsByName === undefined) {\n      bindingsByName = {};\n      bindingsByRoot[rootUuid] = bindingsByName;\n    }\n    for (let i = 0; i !== nTracks; ++i) {\n      const track = tracks[i],\n        trackName = track.name;\n      let binding = bindingsByName[trackName];\n      if (binding !== undefined) {\n        ++binding.referenceCount;\n        bindings[i] = binding;\n      } else {\n        binding = bindings[i];\n        if (binding !== undefined) {\n          // existing binding, make sure the cache knows\n\n          if (binding._cacheIndex === null) {\n            ++binding.referenceCount;\n            this._addInactiveBinding(binding, rootUuid, trackName);\n          }\n          continue;\n        }\n        const path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;\n        binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());\n        ++binding.referenceCount;\n        this._addInactiveBinding(binding, rootUuid, trackName);\n        bindings[i] = binding;\n      }\n      interpolants[i].resultBuffer = binding.buffer;\n    }\n  }\n  _activateAction(action) {\n    if (!this._isActiveAction(action)) {\n      if (action._cacheIndex === null) {\n        // this action has been forgotten by the cache, but the user\n        // appears to be still using it -> rebind\n\n        const rootUuid = (action._localRoot || this._root).uuid,\n          clipUuid = action._clip.uuid,\n          actionsForClip = this._actionsByClip[clipUuid];\n        this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);\n        this._addInactiveAction(action, clipUuid, rootUuid);\n      }\n      const bindings = action._propertyBindings;\n\n      // increment reference counts / sort out state\n      for (let i = 0, n = bindings.length; i !== n; ++i) {\n        const binding = bindings[i];\n        if (binding.useCount++ === 0) {\n          this._lendBinding(binding);\n          binding.saveOriginalState();\n        }\n      }\n      this._lendAction(action);\n    }\n  }\n  _deactivateAction(action) {\n    if (this._isActiveAction(action)) {\n      const bindings = action._propertyBindings;\n\n      // decrement reference counts / sort out state\n      for (let i = 0, n = bindings.length; i !== n; ++i) {\n        const binding = bindings[i];\n        if (--binding.useCount === 0) {\n          binding.restoreOriginalState();\n          this._takeBackBinding(binding);\n        }\n      }\n      this._takeBackAction(action);\n    }\n  }\n\n  // Memory manager\n\n  _initMemoryManager() {\n    this._actions = []; // 'nActiveActions' followed by inactive ones\n    this._nActiveActions = 0;\n    this._actionsByClip = {};\n    // inside:\n    // {\n    // \tknownActions: Array< AnimationAction > - used as prototypes\n    // \tactionByRoot: AnimationAction - lookup\n    // }\n\n    this._bindings = []; // 'nActiveBindings' followed by inactive ones\n    this._nActiveBindings = 0;\n    this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n    this._controlInterpolants = []; // same game as above\n    this._nActiveControlInterpolants = 0;\n    const scope = this;\n    this.stats = {\n      actions: {\n        get total() {\n          return scope._actions.length;\n        },\n        get inUse() {\n          return scope._nActiveActions;\n        }\n      },\n      bindings: {\n        get total() {\n          return scope._bindings.length;\n        },\n        get inUse() {\n          return scope._nActiveBindings;\n        }\n      },\n      controlInterpolants: {\n        get total() {\n          return scope._controlInterpolants.length;\n        },\n        get inUse() {\n          return scope._nActiveControlInterpolants;\n        }\n      }\n    };\n  }\n\n  // Memory management for AnimationAction objects\n\n  _isActiveAction(action) {\n    const index = action._cacheIndex;\n    return index !== null && index < this._nActiveActions;\n  }\n  _addInactiveAction(action, clipUuid, rootUuid) {\n    const actions = this._actions,\n      actionsByClip = this._actionsByClip;\n    let actionsForClip = actionsByClip[clipUuid];\n    if (actionsForClip === undefined) {\n      actionsForClip = {\n        knownActions: [action],\n        actionByRoot: {}\n      };\n      action._byClipCacheIndex = 0;\n      actionsByClip[clipUuid] = actionsForClip;\n    } else {\n      const knownActions = actionsForClip.knownActions;\n      action._byClipCacheIndex = knownActions.length;\n      knownActions.push(action);\n    }\n    action._cacheIndex = actions.length;\n    actions.push(action);\n    actionsForClip.actionByRoot[rootUuid] = action;\n  }\n  _removeInactiveAction(action) {\n    const actions = this._actions,\n      lastInactiveAction = actions[actions.length - 1],\n      cacheIndex = action._cacheIndex;\n    lastInactiveAction._cacheIndex = cacheIndex;\n    actions[cacheIndex] = lastInactiveAction;\n    actions.pop();\n    action._cacheIndex = null;\n    const clipUuid = action._clip.uuid,\n      actionsByClip = this._actionsByClip,\n      actionsForClip = actionsByClip[clipUuid],\n      knownActionsForClip = actionsForClip.knownActions,\n      lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1],\n      byClipCacheIndex = action._byClipCacheIndex;\n    lastKnownAction._byClipCacheIndex = byClipCacheIndex;\n    knownActionsForClip[byClipCacheIndex] = lastKnownAction;\n    knownActionsForClip.pop();\n    action._byClipCacheIndex = null;\n    const actionByRoot = actionsForClip.actionByRoot,\n      rootUuid = (action._localRoot || this._root).uuid;\n    delete actionByRoot[rootUuid];\n    if (knownActionsForClip.length === 0) {\n      delete actionsByClip[clipUuid];\n    }\n    this._removeInactiveBindingsForAction(action);\n  }\n  _removeInactiveBindingsForAction(action) {\n    const bindings = action._propertyBindings;\n    for (let i = 0, n = bindings.length; i !== n; ++i) {\n      const binding = bindings[i];\n      if (--binding.referenceCount === 0) {\n        this._removeInactiveBinding(binding);\n      }\n    }\n  }\n  _lendAction(action) {\n    // [ active actions |  inactive actions  ]\n    // [  active actions >| inactive actions ]\n    //                 s        a\n    //                  <-swap->\n    //                 a        s\n\n    const actions = this._actions,\n      prevIndex = action._cacheIndex,\n      lastActiveIndex = this._nActiveActions++,\n      firstInactiveAction = actions[lastActiveIndex];\n    action._cacheIndex = lastActiveIndex;\n    actions[lastActiveIndex] = action;\n    firstInactiveAction._cacheIndex = prevIndex;\n    actions[prevIndex] = firstInactiveAction;\n  }\n  _takeBackAction(action) {\n    // [  active actions  | inactive actions ]\n    // [ active actions |< inactive actions  ]\n    //        a        s\n    //         <-swap->\n    //        s        a\n\n    const actions = this._actions,\n      prevIndex = action._cacheIndex,\n      firstInactiveIndex = --this._nActiveActions,\n      lastActiveAction = actions[firstInactiveIndex];\n    action._cacheIndex = firstInactiveIndex;\n    actions[firstInactiveIndex] = action;\n    lastActiveAction._cacheIndex = prevIndex;\n    actions[prevIndex] = lastActiveAction;\n  }\n\n  // Memory management for PropertyMixer objects\n\n  _addInactiveBinding(binding, rootUuid, trackName) {\n    const bindingsByRoot = this._bindingsByRootAndName,\n      bindings = this._bindings;\n    let bindingByName = bindingsByRoot[rootUuid];\n    if (bindingByName === undefined) {\n      bindingByName = {};\n      bindingsByRoot[rootUuid] = bindingByName;\n    }\n    bindingByName[trackName] = binding;\n    binding._cacheIndex = bindings.length;\n    bindings.push(binding);\n  }\n  _removeInactiveBinding(binding) {\n    const bindings = this._bindings,\n      propBinding = binding.binding,\n      rootUuid = propBinding.rootNode.uuid,\n      trackName = propBinding.path,\n      bindingsByRoot = this._bindingsByRootAndName,\n      bindingByName = bindingsByRoot[rootUuid],\n      lastInactiveBinding = bindings[bindings.length - 1],\n      cacheIndex = binding._cacheIndex;\n    lastInactiveBinding._cacheIndex = cacheIndex;\n    bindings[cacheIndex] = lastInactiveBinding;\n    bindings.pop();\n    delete bindingByName[trackName];\n    if (Object.keys(bindingByName).length === 0) {\n      delete bindingsByRoot[rootUuid];\n    }\n  }\n  _lendBinding(binding) {\n    const bindings = this._bindings,\n      prevIndex = binding._cacheIndex,\n      lastActiveIndex = this._nActiveBindings++,\n      firstInactiveBinding = bindings[lastActiveIndex];\n    binding._cacheIndex = lastActiveIndex;\n    bindings[lastActiveIndex] = binding;\n    firstInactiveBinding._cacheIndex = prevIndex;\n    bindings[prevIndex] = firstInactiveBinding;\n  }\n  _takeBackBinding(binding) {\n    const bindings = this._bindings,\n      prevIndex = binding._cacheIndex,\n      firstInactiveIndex = --this._nActiveBindings,\n      lastActiveBinding = bindings[firstInactiveIndex];\n    binding._cacheIndex = firstInactiveIndex;\n    bindings[firstInactiveIndex] = binding;\n    lastActiveBinding._cacheIndex = prevIndex;\n    bindings[prevIndex] = lastActiveBinding;\n  }\n\n  // Memory management of Interpolants for weight and time scale\n\n  _lendControlInterpolant() {\n    const interpolants = this._controlInterpolants,\n      lastActiveIndex = this._nActiveControlInterpolants++;\n    let interpolant = interpolants[lastActiveIndex];\n    if (interpolant === undefined) {\n      interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, _controlInterpolantsResultBuffer);\n      interpolant.__cacheIndex = lastActiveIndex;\n      interpolants[lastActiveIndex] = interpolant;\n    }\n    return interpolant;\n  }\n  _takeBackControlInterpolant(interpolant) {\n    const interpolants = this._controlInterpolants,\n      prevIndex = interpolant.__cacheIndex,\n      firstInactiveIndex = --this._nActiveControlInterpolants,\n      lastActiveInterpolant = interpolants[firstInactiveIndex];\n    interpolant.__cacheIndex = firstInactiveIndex;\n    interpolants[firstInactiveIndex] = interpolant;\n    lastActiveInterpolant.__cacheIndex = prevIndex;\n    interpolants[prevIndex] = lastActiveInterpolant;\n  }\n\n  // return an action for a clip optionally using a custom root target\n  // object (this method allocates a lot of dynamic memory in case a\n  // previously unknown clip/root combination is specified)\n  clipAction(clip, optionalRoot, blendMode) {\n    const root = optionalRoot || this._root,\n      rootUuid = root.uuid;\n    let clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip;\n    const clipUuid = clipObject !== null ? clipObject.uuid : clip;\n    const actionsForClip = this._actionsByClip[clipUuid];\n    let prototypeAction = null;\n    if (blendMode === undefined) {\n      if (clipObject !== null) {\n        blendMode = clipObject.blendMode;\n      } else {\n        blendMode = NormalAnimationBlendMode;\n      }\n    }\n    if (actionsForClip !== undefined) {\n      const existingAction = actionsForClip.actionByRoot[rootUuid];\n      if (existingAction !== undefined && existingAction.blendMode === blendMode) {\n        return existingAction;\n      }\n\n      // we know the clip, so we don't have to parse all\n      // the bindings again but can just copy\n      prototypeAction = actionsForClip.knownActions[0];\n\n      // also, take the clip from the prototype action\n      if (clipObject === null) clipObject = prototypeAction._clip;\n    }\n\n    // clip must be known when specified via string\n    if (clipObject === null) return null;\n\n    // allocate all resources required to run it\n    const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);\n    this._bindAction(newAction, prototypeAction);\n\n    // and make the action known to the memory manager\n    this._addInactiveAction(newAction, clipUuid, rootUuid);\n    return newAction;\n  }\n\n  // get an existing action\n  existingAction(clip, optionalRoot) {\n    const root = optionalRoot || this._root,\n      rootUuid = root.uuid,\n      clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,\n      clipUuid = clipObject ? clipObject.uuid : clip,\n      actionsForClip = this._actionsByClip[clipUuid];\n    if (actionsForClip !== undefined) {\n      return actionsForClip.actionByRoot[rootUuid] || null;\n    }\n    return null;\n  }\n\n  // deactivates all previously scheduled actions\n  stopAllAction() {\n    const actions = this._actions,\n      nActions = this._nActiveActions;\n    for (let i = nActions - 1; i >= 0; --i) {\n      actions[i].stop();\n    }\n    return this;\n  }\n\n  // advance the time and update apply the animation\n  update(deltaTime) {\n    deltaTime *= this.timeScale;\n    const actions = this._actions,\n      nActions = this._nActiveActions,\n      time = this.time += deltaTime,\n      timeDirection = Math.sign(deltaTime),\n      accuIndex = this._accuIndex ^= 1;\n\n    // run active actions\n\n    for (let i = 0; i !== nActions; ++i) {\n      const action = actions[i];\n      action._update(time, deltaTime, timeDirection, accuIndex);\n    }\n\n    // update scene graph\n\n    const bindings = this._bindings,\n      nBindings = this._nActiveBindings;\n    for (let i = 0; i !== nBindings; ++i) {\n      bindings[i].apply(accuIndex);\n    }\n    return this;\n  }\n\n  // Allows you to seek to a specific time in an animation.\n  setTime(timeInSeconds) {\n    this.time = 0; // Zero out time attribute for AnimationMixer object;\n    for (let i = 0; i < this._actions.length; i++) {\n      this._actions[i].time = 0; // Zero out time attribute for all associated AnimationAction objects.\n    }\n\n    return this.update(timeInSeconds); // Update used to set exact time. Returns \"this\" AnimationMixer object.\n  }\n\n  // return this mixer's root target object\n  getRoot() {\n    return this._root;\n  }\n\n  // free all resources specific to a particular clip\n  uncacheClip(clip) {\n    const actions = this._actions,\n      clipUuid = clip.uuid,\n      actionsByClip = this._actionsByClip,\n      actionsForClip = actionsByClip[clipUuid];\n    if (actionsForClip !== undefined) {\n      // note: just calling _removeInactiveAction would mess up the\n      // iteration state and also require updating the state we can\n      // just throw away\n\n      const actionsToRemove = actionsForClip.knownActions;\n      for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {\n        const action = actionsToRemove[i];\n        this._deactivateAction(action);\n        const cacheIndex = action._cacheIndex,\n          lastInactiveAction = actions[actions.length - 1];\n        action._cacheIndex = null;\n        action._byClipCacheIndex = null;\n        lastInactiveAction._cacheIndex = cacheIndex;\n        actions[cacheIndex] = lastInactiveAction;\n        actions.pop();\n        this._removeInactiveBindingsForAction(action);\n      }\n      delete actionsByClip[clipUuid];\n    }\n  }\n\n  // free all resources specific to a particular root target object\n  uncacheRoot(root) {\n    const rootUuid = root.uuid,\n      actionsByClip = this._actionsByClip;\n    for (const clipUuid in actionsByClip) {\n      const actionByRoot = actionsByClip[clipUuid].actionByRoot,\n        action = actionByRoot[rootUuid];\n      if (action !== undefined) {\n        this._deactivateAction(action);\n        this._removeInactiveAction(action);\n      }\n    }\n    const bindingsByRoot = this._bindingsByRootAndName,\n      bindingByName = bindingsByRoot[rootUuid];\n    if (bindingByName !== undefined) {\n      for (const trackName in bindingByName) {\n        const binding = bindingByName[trackName];\n        binding.restoreOriginalState();\n        this._removeInactiveBinding(binding);\n      }\n    }\n  }\n\n  // remove a targeted clip from the cache\n  uncacheAction(clip, optionalRoot) {\n    const action = this.existingAction(clip, optionalRoot);\n    if (action !== null) {\n      this._deactivateAction(action);\n      this._removeInactiveAction(action);\n    }\n  }\n}\nexport { AnimationMixer };","map":{"version":3,"names":["AnimationAction","EventDispatcher","LinearInterpolant","PropertyBinding","PropertyMixer","AnimationClip","NormalAnimationBlendMode","_controlInterpolantsResultBuffer","Float32Array","AnimationMixer","constructor","root","_root","_initMemoryManager","_accuIndex","time","timeScale","_bindAction","action","prototypeAction","_localRoot","tracks","_clip","nTracks","length","bindings","_propertyBindings","interpolants","_interpolants","rootUuid","uuid","bindingsByRoot","_bindingsByRootAndName","bindingsByName","undefined","i","track","trackName","name","binding","referenceCount","_cacheIndex","_addInactiveBinding","path","parsedPath","create","ValueTypeName","getValueSize","resultBuffer","buffer","_activateAction","_isActiveAction","clipUuid","actionsForClip","_actionsByClip","knownActions","_addInactiveAction","n","useCount","_lendBinding","saveOriginalState","_lendAction","_deactivateAction","restoreOriginalState","_takeBackBinding","_takeBackAction","_actions","_nActiveActions","_bindings","_nActiveBindings","_controlInterpolants","_nActiveControlInterpolants","scope","stats","actions","total","inUse","controlInterpolants","index","actionsByClip","actionByRoot","_byClipCacheIndex","push","_removeInactiveAction","lastInactiveAction","cacheIndex","pop","knownActionsForClip","lastKnownAction","byClipCacheIndex","_removeInactiveBindingsForAction","_removeInactiveBinding","prevIndex","lastActiveIndex","firstInactiveAction","firstInactiveIndex","lastActiveAction","bindingByName","propBinding","rootNode","lastInactiveBinding","Object","keys","firstInactiveBinding","lastActiveBinding","_lendControlInterpolant","interpolant","__cacheIndex","_takeBackControlInterpolant","lastActiveInterpolant","clipAction","clip","optionalRoot","blendMode","clipObject","findByName","existingAction","newAction","stopAllAction","nActions","stop","update","deltaTime","timeDirection","Math","sign","accuIndex","_update","nBindings","apply","setTime","timeInSeconds","getRoot","uncacheClip","actionsToRemove","uncacheRoot","uncacheAction"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/animation/AnimationMixer.js"],"sourcesContent":["import { AnimationAction } from './AnimationAction.js';\nimport { EventDispatcher } from '../core/EventDispatcher.js';\nimport { LinearInterpolant } from '../math/interpolants/LinearInterpolant.js';\nimport { PropertyBinding } from './PropertyBinding.js';\nimport { PropertyMixer } from './PropertyMixer.js';\nimport { AnimationClip } from './AnimationClip.js';\nimport { NormalAnimationBlendMode } from '../constants.js';\n\n\nconst _controlInterpolantsResultBuffer = new Float32Array( 1 );\n\n\nclass AnimationMixer extends EventDispatcher {\n\n\tconstructor( root ) {\n\n\t\tsuper();\n\n\t\tthis._root = root;\n\t\tthis._initMemoryManager();\n\t\tthis._accuIndex = 0;\n\t\tthis.time = 0;\n\t\tthis.timeScale = 1.0;\n\n\t}\n\n\t_bindAction( action, prototypeAction ) {\n\n\t\tconst root = action._localRoot || this._root,\n\t\t\ttracks = action._clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tbindings = action._propertyBindings,\n\t\t\tinterpolants = action._interpolants,\n\t\t\trootUuid = root.uuid,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName;\n\n\t\tlet bindingsByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingsByName === undefined ) {\n\n\t\t\tbindingsByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\n\n\t\t}\n\n\t\tfor ( let i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tconst track = tracks[ i ],\n\t\t\t\ttrackName = track.name;\n\n\t\t\tlet binding = bindingsByName[ trackName ];\n\n\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t++ binding.referenceCount;\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t} else {\n\n\t\t\t\tbinding = bindings[ i ];\n\n\t\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t\t// existing binding, make sure the cache knows\n\n\t\t\t\t\tif ( binding._cacheIndex === null ) {\n\n\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tconst path = prototypeAction && prototypeAction.\n\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\n\n\t\t\t\tbinding = new PropertyMixer(\n\t\t\t\t\tPropertyBinding.create( root, trackName, path ),\n\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\n\n\t\t\t\t++ binding.referenceCount;\n\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t}\n\n\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\n\n\t\t}\n\n\t}\n\n\t_activateAction( action ) {\n\n\t\tif ( ! this._isActiveAction( action ) ) {\n\n\t\t\tif ( action._cacheIndex === null ) {\n\n\t\t\t\t// this action has been forgotten by the cache, but the user\n\t\t\t\t// appears to be still using it -> rebind\n\n\t\t\t\tconst rootUuid = ( action._localRoot || this._root ).uuid,\n\t\t\t\t\tclipUuid = action._clip.uuid,\n\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\t\t\tthis._bindAction( action,\n\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\n\n\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\n\n\t\t\t}\n\n\t\t\tconst bindings = action._propertyBindings;\n\n\t\t\t// increment reference counts / sort out state\n\t\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tconst binding = bindings[ i ];\n\n\t\t\t\tif ( binding.useCount ++ === 0 ) {\n\n\t\t\t\t\tthis._lendBinding( binding );\n\t\t\t\t\tbinding.saveOriginalState();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._lendAction( action );\n\n\t\t}\n\n\t}\n\n\t_deactivateAction( action ) {\n\n\t\tif ( this._isActiveAction( action ) ) {\n\n\t\t\tconst bindings = action._propertyBindings;\n\n\t\t\t// decrement reference counts / sort out state\n\t\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tconst binding = bindings[ i ];\n\n\t\t\t\tif ( -- binding.useCount === 0 ) {\n\n\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\tthis._takeBackBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._takeBackAction( action );\n\n\t\t}\n\n\t}\n\n\t// Memory manager\n\n\t_initMemoryManager() {\n\n\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\n\t\tthis._nActiveActions = 0;\n\n\t\tthis._actionsByClip = {};\n\t\t// inside:\n\t\t// {\n\t\t// \tknownActions: Array< AnimationAction > - used as prototypes\n\t\t// \tactionByRoot: AnimationAction - lookup\n\t\t// }\n\n\n\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\n\t\tthis._nActiveBindings = 0;\n\n\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n\n\t\tthis._controlInterpolants = []; // same game as above\n\t\tthis._nActiveControlInterpolants = 0;\n\n\t\tconst scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tactions: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._actions.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveActions;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tbindings: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._bindings.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveBindings;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tcontrolInterpolants: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._controlInterpolants.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveControlInterpolants;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t// Memory management for AnimationAction objects\n\n\t_isActiveAction( action ) {\n\n\t\tconst index = action._cacheIndex;\n\t\treturn index !== null && index < this._nActiveActions;\n\n\t}\n\n\t_addInactiveAction( action, clipUuid, rootUuid ) {\n\n\t\tconst actions = this._actions,\n\t\t\tactionsByClip = this._actionsByClip;\n\n\t\tlet actionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip === undefined ) {\n\n\t\t\tactionsForClip = {\n\n\t\t\t\tknownActions: [ action ],\n\t\t\t\tactionByRoot: {}\n\n\t\t\t};\n\n\t\t\taction._byClipCacheIndex = 0;\n\n\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\n\n\t\t} else {\n\n\t\t\tconst knownActions = actionsForClip.knownActions;\n\n\t\t\taction._byClipCacheIndex = knownActions.length;\n\t\t\tknownActions.push( action );\n\n\t\t}\n\n\t\taction._cacheIndex = actions.length;\n\t\tactions.push( action );\n\n\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\n\n\t}\n\n\t_removeInactiveAction( action ) {\n\n\t\tconst actions = this._actions,\n\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\n\t\t\tcacheIndex = action._cacheIndex;\n\n\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\tactions.pop();\n\n\t\taction._cacheIndex = null;\n\n\n\t\tconst clipUuid = action._clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ],\n\t\t\tknownActionsForClip = actionsForClip.knownActions,\n\n\t\t\tlastKnownAction =\n\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\n\n\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\n\n\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\n\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\n\t\tknownActionsForClip.pop();\n\n\t\taction._byClipCacheIndex = null;\n\n\n\t\tconst actionByRoot = actionsForClip.actionByRoot,\n\t\t\trootUuid = ( action._localRoot || this._root ).uuid;\n\n\t\tdelete actionByRoot[ rootUuid ];\n\n\t\tif ( knownActionsForClip.length === 0 ) {\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t\tthis._removeInactiveBindingsForAction( action );\n\n\t}\n\n\t_removeInactiveBindingsForAction( action ) {\n\n\t\tconst bindings = action._propertyBindings;\n\n\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tconst binding = bindings[ i ];\n\n\t\t\tif ( -- binding.referenceCount === 0 ) {\n\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_lendAction( action ) {\n\n\t\t// [ active actions |  inactive actions  ]\n\t\t// [  active actions >| inactive actions ]\n\t\t//                 s        a\n\t\t//                  <-swap->\n\t\t//                 a        s\n\n\t\tconst actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveActions ++,\n\n\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\n\n\t\taction._cacheIndex = lastActiveIndex;\n\t\tactions[ lastActiveIndex ] = action;\n\n\t\tfirstInactiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = firstInactiveAction;\n\n\t}\n\n\t_takeBackAction( action ) {\n\n\t\t// [  active actions  | inactive actions ]\n\t\t// [ active actions |< inactive actions  ]\n\t\t//        a        s\n\t\t//         <-swap->\n\t\t//        s        a\n\n\t\tconst actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveActions,\n\n\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\n\n\t\taction._cacheIndex = firstInactiveIndex;\n\t\tactions[ firstInactiveIndex ] = action;\n\n\t\tlastActiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = lastActiveAction;\n\n\t}\n\n\t// Memory management for PropertyMixer objects\n\n\t_addInactiveBinding( binding, rootUuid, trackName ) {\n\n\t\tconst bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindings = this._bindings;\n\n\t\tlet bindingByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingByName === undefined ) {\n\n\t\t\tbindingByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\n\n\t\t}\n\n\t\tbindingByName[ trackName ] = binding;\n\n\t\tbinding._cacheIndex = bindings.length;\n\t\tbindings.push( binding );\n\n\t}\n\n\t_removeInactiveBinding( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tpropBinding = binding.binding,\n\t\t\trootUuid = propBinding.rootNode.uuid,\n\t\t\ttrackName = propBinding.path,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\n\t\t\tcacheIndex = binding._cacheIndex;\n\n\t\tlastInactiveBinding._cacheIndex = cacheIndex;\n\t\tbindings[ cacheIndex ] = lastInactiveBinding;\n\t\tbindings.pop();\n\n\t\tdelete bindingByName[ trackName ];\n\n\t\tif ( Object.keys( bindingByName ).length === 0 ) {\n\n\t\t\tdelete bindingsByRoot[ rootUuid ];\n\n\t\t}\n\n\t}\n\n\t_lendBinding( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveBindings ++,\n\n\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\n\n\t\tbinding._cacheIndex = lastActiveIndex;\n\t\tbindings[ lastActiveIndex ] = binding;\n\n\t\tfirstInactiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = firstInactiveBinding;\n\n\t}\n\n\t_takeBackBinding( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\n\n\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\n\n\t\tbinding._cacheIndex = firstInactiveIndex;\n\t\tbindings[ firstInactiveIndex ] = binding;\n\n\t\tlastActiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = lastActiveBinding;\n\n\t}\n\n\n\t// Memory management of Interpolants for weight and time scale\n\n\t_lendControlInterpolant() {\n\n\t\tconst interpolants = this._controlInterpolants,\n\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++;\n\n\t\tlet interpolant = interpolants[ lastActiveIndex ];\n\n\t\tif ( interpolant === undefined ) {\n\n\t\t\tinterpolant = new LinearInterpolant(\n\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\n\t\t\t\t1, _controlInterpolantsResultBuffer );\n\n\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\n\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\n\n\t\t}\n\n\t\treturn interpolant;\n\n\t}\n\n\t_takeBackControlInterpolant( interpolant ) {\n\n\t\tconst interpolants = this._controlInterpolants,\n\t\t\tprevIndex = interpolant.__cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\n\n\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\n\n\t\tinterpolant.__cacheIndex = firstInactiveIndex;\n\t\tinterpolants[ firstInactiveIndex ] = interpolant;\n\n\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\n\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\n\n\t}\n\n\t// return an action for a clip optionally using a custom root target\n\t// object (this method allocates a lot of dynamic memory in case a\n\t// previously unknown clip/root combination is specified)\n\tclipAction( clip, optionalRoot, blendMode ) {\n\n\t\tconst root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid;\n\n\t\tlet clipObject = typeof clip === 'string' ? AnimationClip.findByName( root, clip ) : clip;\n\n\t\tconst clipUuid = clipObject !== null ? clipObject.uuid : clip;\n\n\t\tconst actionsForClip = this._actionsByClip[ clipUuid ];\n\t\tlet prototypeAction = null;\n\n\t\tif ( blendMode === undefined ) {\n\n\t\t\tif ( clipObject !== null ) {\n\n\t\t\t\tblendMode = clipObject.blendMode;\n\n\t\t\t} else {\n\n\t\t\t\tblendMode = NormalAnimationBlendMode;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\tconst existingAction = actionsForClip.actionByRoot[ rootUuid ];\n\n\t\t\tif ( existingAction !== undefined && existingAction.blendMode === blendMode ) {\n\n\t\t\t\treturn existingAction;\n\n\t\t\t}\n\n\t\t\t// we know the clip, so we don't have to parse all\n\t\t\t// the bindings again but can just copy\n\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\n\n\t\t\t// also, take the clip from the prototype action\n\t\t\tif ( clipObject === null )\n\t\t\t\tclipObject = prototypeAction._clip;\n\n\t\t}\n\n\t\t// clip must be known when specified via string\n\t\tif ( clipObject === null ) return null;\n\n\t\t// allocate all resources required to run it\n\t\tconst newAction = new AnimationAction( this, clipObject, optionalRoot, blendMode );\n\n\t\tthis._bindAction( newAction, prototypeAction );\n\n\t\t// and make the action known to the memory manager\n\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\n\n\t\treturn newAction;\n\n\t}\n\n\t// get an existing action\n\texistingAction( clip, optionalRoot ) {\n\n\t\tconst root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid,\n\n\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\n\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\n\n\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t// deactivates all previously scheduled actions\n\tstopAllAction() {\n\n\t\tconst actions = this._actions,\n\t\t\tnActions = this._nActiveActions;\n\n\t\tfor ( let i = nActions - 1; i >= 0; -- i ) {\n\n\t\t\tactions[ i ].stop();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// advance the time and update apply the animation\n\tupdate( deltaTime ) {\n\n\t\tdeltaTime *= this.timeScale;\n\n\t\tconst actions = this._actions,\n\t\t\tnActions = this._nActiveActions,\n\n\t\t\ttime = this.time += deltaTime,\n\t\t\ttimeDirection = Math.sign( deltaTime ),\n\n\t\t\taccuIndex = this._accuIndex ^= 1;\n\n\t\t// run active actions\n\n\t\tfor ( let i = 0; i !== nActions; ++ i ) {\n\n\t\t\tconst action = actions[ i ];\n\n\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\n\n\t\t}\n\n\t\t// update scene graph\n\n\t\tconst bindings = this._bindings,\n\t\t\tnBindings = this._nActiveBindings;\n\n\t\tfor ( let i = 0; i !== nBindings; ++ i ) {\n\n\t\t\tbindings[ i ].apply( accuIndex );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Allows you to seek to a specific time in an animation.\n\tsetTime( timeInSeconds ) {\n\n\t\tthis.time = 0; // Zero out time attribute for AnimationMixer object;\n\t\tfor ( let i = 0; i < this._actions.length; i ++ ) {\n\n\t\t\tthis._actions[ i ].time = 0; // Zero out time attribute for all associated AnimationAction objects.\n\n\t\t}\n\n\t\treturn this.update( timeInSeconds ); // Update used to set exact time. Returns \"this\" AnimationMixer object.\n\n\t}\n\n\t// return this mixer's root target object\n\tgetRoot() {\n\n\t\treturn this._root;\n\n\t}\n\n\t// free all resources specific to a particular clip\n\tuncacheClip( clip ) {\n\n\t\tconst actions = this._actions,\n\t\t\tclipUuid = clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t// note: just calling _removeInactiveAction would mess up the\n\t\t\t// iteration state and also require updating the state we can\n\t\t\t// just throw away\n\n\t\t\tconst actionsToRemove = actionsForClip.knownActions;\n\n\t\t\tfor ( let i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\n\n\t\t\t\tconst action = actionsToRemove[ i ];\n\n\t\t\t\tthis._deactivateAction( action );\n\n\t\t\t\tconst cacheIndex = action._cacheIndex,\n\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\n\n\t\t\t\taction._cacheIndex = null;\n\t\t\t\taction._byClipCacheIndex = null;\n\n\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\tactions.pop();\n\n\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\n\t\t\t}\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t}\n\n\t// free all resources specific to a particular root target object\n\tuncacheRoot( root ) {\n\n\t\tconst rootUuid = root.uuid,\n\t\t\tactionsByClip = this._actionsByClip;\n\n\t\tfor ( const clipUuid in actionsByClip ) {\n\n\t\t\tconst actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\n\t\t\t\taction = actionByRoot[ rootUuid ];\n\n\t\t\tif ( action !== undefined ) {\n\n\t\t\t\tthis._deactivateAction( action );\n\t\t\t\tthis._removeInactiveAction( action );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingByName !== undefined ) {\n\n\t\t\tfor ( const trackName in bindingByName ) {\n\n\t\t\t\tconst binding = bindingByName[ trackName ];\n\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// remove a targeted clip from the cache\n\tuncacheAction( clip, optionalRoot ) {\n\n\t\tconst action = this.existingAction( clip, optionalRoot );\n\n\t\tif ( action !== null ) {\n\n\t\t\tthis._deactivateAction( action );\n\t\t\tthis._removeInactiveAction( action );\n\n\t\t}\n\n\t}\n\n}\n\nexport { AnimationMixer };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}