{"ast":null,"code":"import { Quaternion } from '../math/Quaternion.js';\nimport { AdditiveAnimationBlendMode } from '../constants.js';\n\n// same as Array.prototype.slice, but also works on typed arrays\nfunction arraySlice(array, from, to) {\n  if (isTypedArray(array)) {\n    // in ios9 array.subarray(from, undefined) will return empty array\n    // but array.subarray(from) or array.subarray(from, len) is correct\n    return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));\n  }\n  return array.slice(from, to);\n}\n\n// converts an array to a specific type\nfunction convertArray(array, type, forceClone) {\n  if (!array ||\n  // let 'undefined' and 'null' pass\n  !forceClone && array.constructor === type) return array;\n  if (typeof type.BYTES_PER_ELEMENT === 'number') {\n    return new type(array); // create typed array\n  }\n\n  return Array.prototype.slice.call(array); // create Array\n}\n\nfunction isTypedArray(object) {\n  return ArrayBuffer.isView(object) && !(object instanceof DataView);\n}\n\n// returns an array by which times and values can be sorted\nfunction getKeyframeOrder(times) {\n  function compareTime(i, j) {\n    return times[i] - times[j];\n  }\n  const n = times.length;\n  const result = new Array(n);\n  for (let i = 0; i !== n; ++i) result[i] = i;\n  result.sort(compareTime);\n  return result;\n}\n\n// uses the array previously returned by 'getKeyframeOrder' to sort data\nfunction sortedArray(values, stride, order) {\n  const nValues = values.length;\n  const result = new values.constructor(nValues);\n  for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {\n    const srcOffset = order[i] * stride;\n    for (let j = 0; j !== stride; ++j) {\n      result[dstOffset++] = values[srcOffset + j];\n    }\n  }\n  return result;\n}\n\n// function for parsing AOS keyframe formats\nfunction flattenJSON(jsonKeys, times, values, valuePropertyName) {\n  let i = 1,\n    key = jsonKeys[0];\n  while (key !== undefined && key[valuePropertyName] === undefined) {\n    key = jsonKeys[i++];\n  }\n  if (key === undefined) return; // no data\n\n  let value = key[valuePropertyName];\n  if (value === undefined) return; // no data\n\n  if (Array.isArray(value)) {\n    do {\n      value = key[valuePropertyName];\n      if (value !== undefined) {\n        times.push(key.time);\n        values.push.apply(values, value); // push all elements\n      }\n\n      key = jsonKeys[i++];\n    } while (key !== undefined);\n  } else if (value.toArray !== undefined) {\n    // ...assume THREE.Math-ish\n\n    do {\n      value = key[valuePropertyName];\n      if (value !== undefined) {\n        times.push(key.time);\n        value.toArray(values, values.length);\n      }\n      key = jsonKeys[i++];\n    } while (key !== undefined);\n  } else {\n    // otherwise push as-is\n\n    do {\n      value = key[valuePropertyName];\n      if (value !== undefined) {\n        times.push(key.time);\n        values.push(value);\n      }\n      key = jsonKeys[i++];\n    } while (key !== undefined);\n  }\n}\nfunction subclip(sourceClip, name, startFrame, endFrame) {\n  let fps = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 30;\n  const clip = sourceClip.clone();\n  clip.name = name;\n  const tracks = [];\n  for (let i = 0; i < clip.tracks.length; ++i) {\n    const track = clip.tracks[i];\n    const valueSize = track.getValueSize();\n    const times = [];\n    const values = [];\n    for (let j = 0; j < track.times.length; ++j) {\n      const frame = track.times[j] * fps;\n      if (frame < startFrame || frame >= endFrame) continue;\n      times.push(track.times[j]);\n      for (let k = 0; k < valueSize; ++k) {\n        values.push(track.values[j * valueSize + k]);\n      }\n    }\n    if (times.length === 0) continue;\n    track.times = convertArray(times, track.times.constructor);\n    track.values = convertArray(values, track.values.constructor);\n    tracks.push(track);\n  }\n  clip.tracks = tracks;\n\n  // find minimum .times value across all tracks in the trimmed clip\n\n  let minStartTime = Infinity;\n  for (let i = 0; i < clip.tracks.length; ++i) {\n    if (minStartTime > clip.tracks[i].times[0]) {\n      minStartTime = clip.tracks[i].times[0];\n    }\n  }\n\n  // shift all tracks such that clip begins at t=0\n\n  for (let i = 0; i < clip.tracks.length; ++i) {\n    clip.tracks[i].shift(-1 * minStartTime);\n  }\n  clip.resetDuration();\n  return clip;\n}\nfunction makeClipAdditive(targetClip) {\n  let referenceFrame = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let referenceClip = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : targetClip;\n  let fps = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 30;\n  if (fps <= 0) fps = 30;\n  const numTracks = referenceClip.tracks.length;\n  const referenceTime = referenceFrame / fps;\n\n  // Make each track's values relative to the values at the reference frame\n  for (let i = 0; i < numTracks; ++i) {\n    const referenceTrack = referenceClip.tracks[i];\n    const referenceTrackType = referenceTrack.ValueTypeName;\n\n    // Skip this track if it's non-numeric\n    if (referenceTrackType === 'bool' || referenceTrackType === 'string') continue;\n\n    // Find the track in the target clip whose name and type matches the reference track\n    const targetTrack = targetClip.tracks.find(function (track) {\n      return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;\n    });\n    if (targetTrack === undefined) continue;\n    let referenceOffset = 0;\n    const referenceValueSize = referenceTrack.getValueSize();\n    if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n      referenceOffset = referenceValueSize / 3;\n    }\n    let targetOffset = 0;\n    const targetValueSize = targetTrack.getValueSize();\n    if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n      targetOffset = targetValueSize / 3;\n    }\n    const lastIndex = referenceTrack.times.length - 1;\n    let referenceValue;\n\n    // Find the value to subtract out of the track\n    if (referenceTime <= referenceTrack.times[0]) {\n      // Reference frame is earlier than the first keyframe, so just use the first keyframe\n      const startIndex = referenceOffset;\n      const endIndex = referenceValueSize - referenceOffset;\n      referenceValue = arraySlice(referenceTrack.values, startIndex, endIndex);\n    } else if (referenceTime >= referenceTrack.times[lastIndex]) {\n      // Reference frame is after the last keyframe, so just use the last keyframe\n      const startIndex = lastIndex * referenceValueSize + referenceOffset;\n      const endIndex = startIndex + referenceValueSize - referenceOffset;\n      referenceValue = arraySlice(referenceTrack.values, startIndex, endIndex);\n    } else {\n      // Interpolate to the reference value\n      const interpolant = referenceTrack.createInterpolant();\n      const startIndex = referenceOffset;\n      const endIndex = referenceValueSize - referenceOffset;\n      interpolant.evaluate(referenceTime);\n      referenceValue = arraySlice(interpolant.resultBuffer, startIndex, endIndex);\n    }\n\n    // Conjugate the quaternion\n    if (referenceTrackType === 'quaternion') {\n      const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();\n      referenceQuat.toArray(referenceValue);\n    }\n\n    // Subtract the reference value from all of the track values\n\n    const numTimes = targetTrack.times.length;\n    for (let j = 0; j < numTimes; ++j) {\n      const valueStart = j * targetValueSize + targetOffset;\n      if (referenceTrackType === 'quaternion') {\n        // Multiply the conjugate for quaternion track types\n        Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);\n      } else {\n        const valueEnd = targetValueSize - targetOffset * 2;\n\n        // Subtract each value for all other numeric track types\n        for (let k = 0; k < valueEnd; ++k) {\n          targetTrack.values[valueStart + k] -= referenceValue[k];\n        }\n      }\n    }\n  }\n  targetClip.blendMode = AdditiveAnimationBlendMode;\n  return targetClip;\n}\nexport { arraySlice, convertArray, isTypedArray, getKeyframeOrder, sortedArray, flattenJSON, subclip, makeClipAdditive };","map":{"version":3,"names":["Quaternion","AdditiveAnimationBlendMode","arraySlice","array","from","to","isTypedArray","constructor","subarray","undefined","length","slice","convertArray","type","forceClone","BYTES_PER_ELEMENT","Array","prototype","call","object","ArrayBuffer","isView","DataView","getKeyframeOrder","times","compareTime","i","j","n","result","sort","sortedArray","values","stride","order","nValues","dstOffset","srcOffset","flattenJSON","jsonKeys","valuePropertyName","key","value","isArray","push","time","apply","toArray","subclip","sourceClip","name","startFrame","endFrame","fps","clip","clone","tracks","track","valueSize","getValueSize","frame","k","minStartTime","Infinity","shift","resetDuration","makeClipAdditive","targetClip","referenceFrame","referenceClip","numTracks","referenceTime","referenceTrack","referenceTrackType","ValueTypeName","targetTrack","find","referenceOffset","referenceValueSize","createInterpolant","isInterpolantFactoryMethodGLTFCubicSpline","targetOffset","targetValueSize","lastIndex","referenceValue","startIndex","endIndex","interpolant","evaluate","resultBuffer","referenceQuat","fromArray","normalize","conjugate","numTimes","valueStart","multiplyQuaternionsFlat","valueEnd","blendMode"],"sources":["C:/Users/dro1l/source/repos/StaffWork/staffwork.client/node_modules/three/src/animation/AnimationUtils.js"],"sourcesContent":["import { Quaternion } from '../math/Quaternion.js';\nimport { AdditiveAnimationBlendMode } from '../constants.js';\n\n// same as Array.prototype.slice, but also works on typed arrays\nfunction arraySlice( array, from, to ) {\n\n\tif ( isTypedArray( array ) ) {\n\n\t\t// in ios9 array.subarray(from, undefined) will return empty array\n\t\t// but array.subarray(from) or array.subarray(from, len) is correct\n\t\treturn new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );\n\n\t}\n\n\treturn array.slice( from, to );\n\n}\n\n// converts an array to a specific type\nfunction convertArray( array, type, forceClone ) {\n\n\tif ( ! array || // let 'undefined' and 'null' pass\n\t\t! forceClone && array.constructor === type ) return array;\n\n\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\n\n\t\treturn new type( array ); // create typed array\n\n\t}\n\n\treturn Array.prototype.slice.call( array ); // create Array\n\n}\n\nfunction isTypedArray( object ) {\n\n\treturn ArrayBuffer.isView( object ) &&\n\t\t! ( object instanceof DataView );\n\n}\n\n// returns an array by which times and values can be sorted\nfunction getKeyframeOrder( times ) {\n\n\tfunction compareTime( i, j ) {\n\n\t\treturn times[ i ] - times[ j ];\n\n\t}\n\n\tconst n = times.length;\n\tconst result = new Array( n );\n\tfor ( let i = 0; i !== n; ++ i ) result[ i ] = i;\n\n\tresult.sort( compareTime );\n\n\treturn result;\n\n}\n\n// uses the array previously returned by 'getKeyframeOrder' to sort data\nfunction sortedArray( values, stride, order ) {\n\n\tconst nValues = values.length;\n\tconst result = new values.constructor( nValues );\n\n\tfor ( let i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\n\n\t\tconst srcOffset = order[ i ] * stride;\n\n\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\n\n\t\t}\n\n\t}\n\n\treturn result;\n\n}\n\n// function for parsing AOS keyframe formats\nfunction flattenJSON( jsonKeys, times, values, valuePropertyName ) {\n\n\tlet i = 1, key = jsonKeys[ 0 ];\n\n\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\n\n\t\tkey = jsonKeys[ i ++ ];\n\n\t}\n\n\tif ( key === undefined ) return; // no data\n\n\tlet value = key[ valuePropertyName ];\n\tif ( value === undefined ) return; // no data\n\n\tif ( Array.isArray( value ) ) {\n\n\t\tdo {\n\n\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\ttimes.push( key.time );\n\t\t\t\tvalues.push.apply( values, value ); // push all elements\n\n\t\t\t}\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t} while ( key !== undefined );\n\n\t} else if ( value.toArray !== undefined ) {\n\n\t\t// ...assume THREE.Math-ish\n\n\t\tdo {\n\n\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\ttimes.push( key.time );\n\t\t\t\tvalue.toArray( values, values.length );\n\n\t\t\t}\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t} while ( key !== undefined );\n\n\t} else {\n\n\t\t// otherwise push as-is\n\n\t\tdo {\n\n\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\ttimes.push( key.time );\n\t\t\t\tvalues.push( value );\n\n\t\t\t}\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t} while ( key !== undefined );\n\n\t}\n\n}\n\nfunction subclip( sourceClip, name, startFrame, endFrame, fps = 30 ) {\n\n\tconst clip = sourceClip.clone();\n\n\tclip.name = name;\n\n\tconst tracks = [];\n\n\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\tconst track = clip.tracks[ i ];\n\t\tconst valueSize = track.getValueSize();\n\n\t\tconst times = [];\n\t\tconst values = [];\n\n\t\tfor ( let j = 0; j < track.times.length; ++ j ) {\n\n\t\t\tconst frame = track.times[ j ] * fps;\n\n\t\t\tif ( frame < startFrame || frame >= endFrame ) continue;\n\n\t\t\ttimes.push( track.times[ j ] );\n\n\t\t\tfor ( let k = 0; k < valueSize; ++ k ) {\n\n\t\t\t\tvalues.push( track.values[ j * valueSize + k ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( times.length === 0 ) continue;\n\n\t\ttrack.times = convertArray( times, track.times.constructor );\n\t\ttrack.values = convertArray( values, track.values.constructor );\n\n\t\ttracks.push( track );\n\n\t}\n\n\tclip.tracks = tracks;\n\n\t// find minimum .times value across all tracks in the trimmed clip\n\n\tlet minStartTime = Infinity;\n\n\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\tif ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {\n\n\t\t\tminStartTime = clip.tracks[ i ].times[ 0 ];\n\n\t\t}\n\n\t}\n\n\t// shift all tracks such that clip begins at t=0\n\n\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\tclip.tracks[ i ].shift( - 1 * minStartTime );\n\n\t}\n\n\tclip.resetDuration();\n\n\treturn clip;\n\n}\n\nfunction makeClipAdditive( targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30 ) {\n\n\tif ( fps <= 0 ) fps = 30;\n\n\tconst numTracks = referenceClip.tracks.length;\n\tconst referenceTime = referenceFrame / fps;\n\n\t// Make each track's values relative to the values at the reference frame\n\tfor ( let i = 0; i < numTracks; ++ i ) {\n\n\t\tconst referenceTrack = referenceClip.tracks[ i ];\n\t\tconst referenceTrackType = referenceTrack.ValueTypeName;\n\n\t\t// Skip this track if it's non-numeric\n\t\tif ( referenceTrackType === 'bool' || referenceTrackType === 'string' ) continue;\n\n\t\t// Find the track in the target clip whose name and type matches the reference track\n\t\tconst targetTrack = targetClip.tracks.find( function ( track ) {\n\n\t\t\treturn track.name === referenceTrack.name\n\t\t\t\t&& track.ValueTypeName === referenceTrackType;\n\n\t\t} );\n\n\t\tif ( targetTrack === undefined ) continue;\n\n\t\tlet referenceOffset = 0;\n\t\tconst referenceValueSize = referenceTrack.getValueSize();\n\n\t\tif ( referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\treferenceOffset = referenceValueSize / 3;\n\n\t\t}\n\n\t\tlet targetOffset = 0;\n\t\tconst targetValueSize = targetTrack.getValueSize();\n\n\t\tif ( targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\ttargetOffset = targetValueSize / 3;\n\n\t\t}\n\n\t\tconst lastIndex = referenceTrack.times.length - 1;\n\t\tlet referenceValue;\n\n\t\t// Find the value to subtract out of the track\n\t\tif ( referenceTime <= referenceTrack.times[ 0 ] ) {\n\n\t\t\t// Reference frame is earlier than the first keyframe, so just use the first keyframe\n\t\t\tconst startIndex = referenceOffset;\n\t\t\tconst endIndex = referenceValueSize - referenceOffset;\n\t\t\treferenceValue = arraySlice( referenceTrack.values, startIndex, endIndex );\n\n\t\t} else if ( referenceTime >= referenceTrack.times[ lastIndex ] ) {\n\n\t\t\t// Reference frame is after the last keyframe, so just use the last keyframe\n\t\t\tconst startIndex = lastIndex * referenceValueSize + referenceOffset;\n\t\t\tconst endIndex = startIndex + referenceValueSize - referenceOffset;\n\t\t\treferenceValue = arraySlice( referenceTrack.values, startIndex, endIndex );\n\n\t\t} else {\n\n\t\t\t// Interpolate to the reference value\n\t\t\tconst interpolant = referenceTrack.createInterpolant();\n\t\t\tconst startIndex = referenceOffset;\n\t\t\tconst endIndex = referenceValueSize - referenceOffset;\n\t\t\tinterpolant.evaluate( referenceTime );\n\t\t\treferenceValue = arraySlice( interpolant.resultBuffer, startIndex, endIndex );\n\n\t\t}\n\n\t\t// Conjugate the quaternion\n\t\tif ( referenceTrackType === 'quaternion' ) {\n\n\t\t\tconst referenceQuat = new Quaternion().fromArray( referenceValue ).normalize().conjugate();\n\t\t\treferenceQuat.toArray( referenceValue );\n\n\t\t}\n\n\t\t// Subtract the reference value from all of the track values\n\n\t\tconst numTimes = targetTrack.times.length;\n\t\tfor ( let j = 0; j < numTimes; ++ j ) {\n\n\t\t\tconst valueStart = j * targetValueSize + targetOffset;\n\n\t\t\tif ( referenceTrackType === 'quaternion' ) {\n\n\t\t\t\t// Multiply the conjugate for quaternion track types\n\t\t\t\tQuaternion.multiplyQuaternionsFlat(\n\t\t\t\t\ttargetTrack.values,\n\t\t\t\t\tvalueStart,\n\t\t\t\t\treferenceValue,\n\t\t\t\t\t0,\n\t\t\t\t\ttargetTrack.values,\n\t\t\t\t\tvalueStart\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\tconst valueEnd = targetValueSize - targetOffset * 2;\n\n\t\t\t\t// Subtract each value for all other numeric track types\n\t\t\t\tfor ( let k = 0; k < valueEnd; ++ k ) {\n\n\t\t\t\t\ttargetTrack.values[ valueStart + k ] -= referenceValue[ k ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttargetClip.blendMode = AdditiveAnimationBlendMode;\n\n\treturn targetClip;\n\n}\n\nexport {\n\tarraySlice,\n\tconvertArray,\n\tisTypedArray,\n\tgetKeyframeOrder,\n\tsortedArray,\n\tflattenJSON,\n\tsubclip,\n\tmakeClipAdditive\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}